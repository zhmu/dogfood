# Bulgarian translation of GNU coreutis po-file.
# Copyright (C) 2003, 2004, 2005, 2006, 2018, 2019 Free Software Foundation, Inc.
# This file is distributed under the same license as the coreutils package.
# Anton Zinoviev <zinoviev@debian.org>, 2003, 2004, 2005, 2006.
# Alexander Shopov <ash@kambanaria.org>, 2018, 2019.
msgid ""
msgstr ""
"Project-Id-Version: coreutils 8.30.79\n"
"Report-Msgid-Bugs-To: bug-coreutils@gnu.org\n"
"POT-Creation-Date: 2019-03-10 16:38-0700\n"
"PO-Revision-Date: 2019-03-06 12:15+0100\n"
"Last-Translator: Alexander Shopov <ash@kambanaria.org>\n"
"Language-Team: Bulgarian <dict@ludost.net>\n"
"Language: bg\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: lib/argmatch.c:134
#, c-format
msgid "invalid argument %s for %s"
msgstr "аргументът „%s“ на опцията „%s“ е неправилен"

#: lib/argmatch.c:135
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "аргументът „%s“ на опцията „%s“ не е еднозначен"

#: lib/argmatch.c:154
msgid "Valid arguments are:"
msgstr "Възможните аргументи са:"

#: lib/closein.c:100
msgid "error closing file"
msgstr "грешка при затваряне на файл"

#: lib/closeout.c:122 src/basenc.c:950 src/basenc.c:962 src/basenc.c:968
#: src/basenc.c:1011 src/basenc.c:1076 src/cat.c:187 src/cat.c:203
#: src/cat.c:287 src/cksum.c:245 src/expand.c:150 src/expand.c:175
#: src/factor.c:2387 src/mktemp.c:339 src/od.c:969 src/paste.c:163
#: src/seq.c:290 src/shuf.c:590 src/split.c:936 src/split.c:1190
#: src/split.c:1195 src/tail.c:1291 src/tail.c:1445 src/tail.c:2507
#: src/tr.c:1587 src/tr.c:1813 src/tr.c:1905 src/unexpand.c:234
#: src/unexpand.c:250
#, c-format
msgid "write error"
msgstr "грешка при запис"

#: lib/copy-acl.c:54 src/copy.c:1393 src/copy.c:2909
#, c-format
msgid "preserving permissions for %s"
msgstr "режимът за достъп до „%s“ е запазен"

#: lib/error.c:195
msgid "Unknown system error"
msgstr "Неизвестна системна грешка"

#: lib/file-type.c:40
msgid "regular empty file"
msgstr "празен, обикновен файл"

#: lib/file-type.c:40
msgid "regular file"
msgstr "обикновен файл"

#: lib/file-type.c:43
msgid "directory"
msgstr "директория"

#: lib/file-type.c:46
msgid "symbolic link"
msgstr "символна връзка"

#: lib/file-type.c:52
msgid "message queue"
msgstr "опашка за съобщения"

#: lib/file-type.c:55
msgid "semaphore"
msgstr "семафор"

#: lib/file-type.c:58
msgid "shared memory object"
msgstr "споделен обект в паметта"

#: lib/file-type.c:61
msgid "typed memory object"
msgstr "типов обект в паметта"

#: lib/file-type.c:66
msgid "block special file"
msgstr "блоков специален файл"

#: lib/file-type.c:69
msgid "character special file"
msgstr "знаков специален сайт"

#: lib/file-type.c:72
msgid "contiguous data"
msgstr "последователни данни"

#: lib/file-type.c:75
msgid "fifo"
msgstr "програмен канал"

#: lib/file-type.c:78
msgid "door"
msgstr "порта"

#: lib/file-type.c:81
msgid "multiplexed block special file"
msgstr "мултиплексиран блоков специален файл"

#: lib/file-type.c:84
msgid "multiplexed character special file"
msgstr "мултиплексиран знаков специален файл"

#: lib/file-type.c:87
msgid "multiplexed file"
msgstr "мултиплексиран файл"

#: lib/file-type.c:90
msgid "named file"
msgstr "именован файл"

#: lib/file-type.c:93
msgid "network special file"
msgstr "мрежов специален файл"

#: lib/file-type.c:96
msgid "migrated file with data"
msgstr "мигриран файл с данни"

#: lib/file-type.c:99
msgid "migrated file without data"
msgstr "мигриран файл без данни"

#: lib/file-type.c:102
msgid "port"
msgstr "порт"

#: lib/file-type.c:105
msgid "socket"
msgstr "гнездо"

#: lib/file-type.c:108
msgid "whiteout"
msgstr "припокриващо изтриване"

#: lib/file-type.c:110
msgid "weird file"
msgstr "странен файл"

#: lib/gai_strerror.c:57
msgid "Address family for hostname not supported"
msgstr "Този вид адреси за името на хоста не се поддържат"

#: lib/gai_strerror.c:58
msgid "Temporary failure in name resolution"
msgstr "Временен проблем при намиране IP-адреса на хост"

#: lib/gai_strerror.c:59
msgid "Bad value for ai_flags"
msgstr "Неправилна стойност за „ai_flags“"

#: lib/gai_strerror.c:60
msgid "Non-recoverable failure in name resolution"
msgstr "Окончателен неуспех при намиране IP-адреса на хост"

#: lib/gai_strerror.c:61
msgid "ai_family not supported"
msgstr "не се поддържа посочването на вид адреси („ai_family“)"

#: lib/gai_strerror.c:62
msgid "Memory allocation failure"
msgstr "Неуспешно заделяне на памет"

#: lib/gai_strerror.c:63
msgid "No address associated with hostname"
msgstr "Няма IP-адрес с посоченото име на хост"

#: lib/gai_strerror.c:64
msgid "Name or service not known"
msgstr "Името или услугата са непознати"

#: lib/gai_strerror.c:65
msgid "Servname not supported for ai_socktype"
msgstr ""
"Името на услугата не се поддържа за използвания вид гнездо („ai_socktype“)"

#: lib/gai_strerror.c:66
msgid "ai_socktype not supported"
msgstr "посочването на вид гнездо („ai_socktype“) не се поддържа"

#: lib/gai_strerror.c:67
msgid "System error"
msgstr "Системна грешка"

#: lib/gai_strerror.c:68
msgid "Argument buffer too small"
msgstr "Буферът за аргументите е твърде малък"

#: lib/gai_strerror.c:70
msgid "Processing request in progress"
msgstr "Заявката е в процес на изпълнение"

#: lib/gai_strerror.c:71
msgid "Request canceled"
msgstr "Заявката е отменена"

#: lib/gai_strerror.c:72
msgid "Request not canceled"
msgstr "Заявката не е отменена"

#: lib/gai_strerror.c:73
msgid "All requests done"
msgstr "Изпълнени са всички заявки"

#: lib/gai_strerror.c:74
msgid "Interrupted by a signal"
msgstr "Прекъснат със сигнал"

#: lib/gai_strerror.c:75
msgid "Parameter string not correctly encoded"
msgstr "Неправилно кодиран низ на аргумент"

#: lib/gai_strerror.c:87
msgid "Unknown error"
msgstr "Неизвестна грешка"

#: lib/getopt.c:278
#, c-format
msgid "%s: option '%s%s' is ambiguous\n"
msgstr "%s: опцията „%s%s“ не е еднозначна\n"

#: lib/getopt.c:284
#, c-format
msgid "%s: option '%s%s' is ambiguous; possibilities:"
msgstr "%s: опцията „%s%s“ не е еднозначна. Възможности:"

#: lib/getopt.c:319
#, c-format
msgid "%s: unrecognized option '%s%s'\n"
msgstr "%s: непозната опция „%s%s“\n"

#: lib/getopt.c:345
#, c-format
msgid "%s: option '%s%s' doesn't allow an argument\n"
msgstr "%s: опцията „%s%s“ се използва без аргументи\n"

#: lib/getopt.c:360
#, c-format
msgid "%s: option '%s%s' requires an argument\n"
msgstr "%s: опцията „%s%s“ изисква аргумент\n"

#: lib/getopt.c:621
#, c-format
msgid "%s: invalid option -- '%c'\n"
msgstr "%s: неправилна опция — „%c“\n"

#: lib/getopt.c:636 lib/getopt.c:682
#, c-format
msgid "%s: option requires an argument -- '%c'\n"
msgstr "%s: опцията изисква аргумент — „%c“\n"

#: lib/mkdir-p.c:162 src/copy.c:1891 src/copy.c:1963 src/copy.c:2535
#: src/copy.c:2896 src/find-mount-point.c:84 src/install.c:702
#: src/realpath.c:146 src/stat.c:1410 src/truncate.c:338
#, c-format
msgid "cannot stat %s"
msgstr "атрибутите на „%s“ не могат да се получат"

#: lib/mkdir-p.c:190 src/install.c:512
#, c-format
msgid "cannot change permissions of %s"
msgstr "не може да се сменят правата за достъп до %s"

#: lib/mkdir-p.c:200 src/copy.c:2524 src/install.c:740 src/install.c:753
#, c-format
msgid "cannot create directory %s"
msgstr "не може да се създаде директория „%s“"

#: lib/obstack.c:338 lib/obstack.c:340 lib/xalloc-die.c:34 src/csplit.c:233
#: src/tac.c:442
#, c-format
msgid "memory exhausted"
msgstr "паметта е изчерпана"

#: lib/openat-die.c:38
#, c-format
msgid "unable to record current working directory"
msgstr "не може да се запише коя е текущата работна директория"

#: lib/openat-die.c:57 src/find-mount-point.c:107
#, c-format
msgid "failed to return to initial working directory"
msgstr "не може да се върне към първоначалната работна директория"

#. TRANSLATORS:
#. Get translations for open and closing quotation marks.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  For example, a French Unicode local should translate
#. these to U+00AB (LEFT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), respectively.
#.
#. If the catalog has no translation, we will try to
#. use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and
#. Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the
#. current locale is not Unicode, locale_quoting_style
#. will quote 'like this', and clocale_quoting_style will
#. quote "like this".  You should always include translations
#. for "`" and "'" even if U+2018 and U+2019 are appropriate
#. for your locale.
#.
#. If you don't know what to put here, please see
#. <https://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>
#. and use glyphs suitable for your language.
#: lib/quotearg.c:362
msgid "`"
msgstr "„"

#: lib/quotearg.c:363
msgid "'"
msgstr "“"

#: lib/randread.c:128
#, c-format
msgid "%s: end of file"
msgstr "%s: край на файла"

#: lib/randread.c:128 src/du.c:1073 src/md5sum.c:803 src/od.c:953 src/tac.c:251
#: src/tac.c:357 src/tac.c:515 src/tac.c:596 src/wc.c:824
#, c-format
msgid "%s: read error"
msgstr "%s: грешка при четене"

#: lib/regcomp.c:135
msgid "Success"
msgstr "Успех"

#: lib/regcomp.c:138
msgid "No match"
msgstr "Няма съвпадения"

#: lib/regcomp.c:141
msgid "Invalid regular expression"
msgstr "Неправилен регулярен израз"

#: lib/regcomp.c:144
msgid "Invalid collation character"
msgstr "Неправилен знак за подредба"

#: lib/regcomp.c:147
msgid "Invalid character class name"
msgstr "Неправилно име на клас знаци"

#: lib/regcomp.c:150
msgid "Trailing backslash"
msgstr "Самотна „\\“ накрая"

#: lib/regcomp.c:153
msgid "Invalid back reference"
msgstr "Неправилна препратка към съвпадение"

#: lib/regcomp.c:156
msgid "Unmatched [, [^, [:, [., or [="
msgstr "„[“, „[^“, „[:“, „[.“ или „[=“ без еш"

#: lib/regcomp.c:159
msgid "Unmatched ( or \\("
msgstr "„(“ или „\\(“ без еш"

#: lib/regcomp.c:162
msgid "Unmatched \\{"
msgstr "„\\{“ без еш"

#: lib/regcomp.c:165
msgid "Invalid content of \\{\\}"
msgstr "Неправилно съдържание в „\\{\\}“"

#: lib/regcomp.c:168
msgid "Invalid range end"
msgstr "Неправилен край на диапазон"

#: lib/regcomp.c:171
msgid "Memory exhausted"
msgstr "Паметта свърши"

#: lib/regcomp.c:174
msgid "Invalid preceding regular expression"
msgstr "Предхождащият регулярен израз е неправилен"

#: lib/regcomp.c:177
msgid "Premature end of regular expression"
msgstr "Ранен край на регулярен израз"

#: lib/regcomp.c:180
msgid "Regular expression too big"
msgstr "Регулярният израз е прекалено голям"

#: lib/regcomp.c:183
msgid "Unmatched ) or \\)"
msgstr "„)“ или „\\)“ без еш"

#: lib/regcomp.c:676
msgid "No previous regular expression"
msgstr "Няма предхождащ регулярен израз"

#: lib/root-dev-ino.h:37
#, c-format
msgid "it is dangerous to operate recursively on %s"
msgstr "опасно е да се работи рекурсивно върху %s"

#: lib/root-dev-ino.h:41
#, c-format
msgid "it is dangerous to operate recursively on %s (same as %s)"
msgstr "опасно е да се работи рекурсивно върху %s, т.е. върху %s"

#: lib/root-dev-ino.h:43
#, c-format
msgid "use --no-preserve-root to override this failsafe"
msgstr "ползвайте --no-preserve-root, за да отмените тази предпазна мярка"

#. TRANSLATORS: A regular expression testing for an affirmative answer
#. (english: "yes").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^yesexpr='
#: lib/rpmatch.c:150
msgid "^[yY]"
msgstr "^[yYдДщЩ]"

#. TRANSLATORS: A regular expression testing for a negative answer
#. (english: "no").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^noexpr='
#: lib/rpmatch.c:163
msgid "^[nN]"
msgstr "^[nNнНхХ]"

#: lib/set-acl.c:46 src/copy.c:2547 src/cp.c:514
#, c-format
msgid "setting permissions for %s"
msgstr "установява се режим за достъп до „%s“"

#: lib/siglist.h:31
msgid "Hangup"
msgstr "Прекъсване на връзката"

#: lib/siglist.h:34
msgid "Interrupt"
msgstr "Прекъсване"

#: lib/siglist.h:37
msgid "Quit"
msgstr "Спиране"

#: lib/siglist.h:40
msgid "Illegal instruction"
msgstr "Неправилна инструкция"

#: lib/siglist.h:43
msgid "Trace/breakpoint trap"
msgstr ""

#: lib/siglist.h:46
msgid "Aborted"
msgstr ""

#: lib/siglist.h:49
msgid "Floating point exception"
msgstr "Изключение от плаваща запетая"

#: lib/siglist.h:52
msgid "Killed"
msgstr "Убит"

#: lib/siglist.h:55
msgid "Bus error"
msgstr "Грешка в шината"

#: lib/siglist.h:58
msgid "Segmentation fault"
msgstr "Грешка в разделянето"

#: lib/siglist.h:61
msgid "Broken pipe"
msgstr "Прекъснат програмен канал"

#: lib/siglist.h:64
msgid "Alarm clock"
msgstr "Аларма"

#: lib/siglist.h:67
msgid "Terminated"
msgstr "Прекратен"

#: lib/siglist.h:70
#, fuzzy
msgid "Urgent I/O condition"
msgstr "Спешно вх./изх. състояние"

#: lib/siglist.h:73
msgid "Stopped (signal)"
msgstr "Спрян (сигнал)"

#: lib/siglist.h:76
msgid "Stopped"
msgstr "Спрян"

#: lib/siglist.h:79
#, fuzzy
msgid "Continued"
msgstr "Продължаване"

#: lib/siglist.h:82
msgid "Child exited"
msgstr ""

#: lib/siglist.h:85
msgid "Stopped (tty input)"
msgstr "Спиране (вход от tty)"

#: lib/siglist.h:88
msgid "Stopped (tty output)"
msgstr "Спиране (изход към tty)"

#: lib/siglist.h:91
msgid "I/O possible"
msgstr ""

#: lib/siglist.h:94
msgid "CPU time limit exceeded"
msgstr ""

#: lib/siglist.h:97
msgid "File size limit exceeded"
msgstr ""

#: lib/siglist.h:100
msgid "Virtual timer expired"
msgstr ""

#: lib/siglist.h:103
msgid "Profiling timer expired"
msgstr ""

#: lib/siglist.h:106
msgid "Window changed"
msgstr "Прозорецът е преоразмерен"

#: lib/siglist.h:109
#, fuzzy
msgid "User defined signal 1"
msgstr "Потребителски сигнал 1"

#: lib/siglist.h:112
#, fuzzy
msgid "User defined signal 2"
msgstr "Потребителски сигнал 2"

#: lib/siglist.h:117
msgid "EMT trap"
msgstr ""

#: lib/siglist.h:120
msgid "Bad system call"
msgstr "Грешно системно извикване"

#: lib/siglist.h:123
#, fuzzy
msgid "Stack fault"
msgstr "Грешка в разделянето"

#: lib/siglist.h:126
msgid "Information request"
msgstr "Заявка за информация"

#: lib/siglist.h:128
#, fuzzy
msgid "Power failure"
msgstr "Предстои спиране на захранването"

#: lib/siglist.h:131
msgid "Resource lost"
msgstr ""

#: lib/strsignal.c:114
#, c-format
msgid "Real-time signal %d"
msgstr "Сигнал за реално време %d"

#: lib/strsignal.c:118
#, c-format
msgid "Unknown signal %d"
msgstr "Непознат сигнал %d"

#: lib/unicodeio.c:102
msgid "iconv function not usable"
msgstr "функцията iconv не е използваема"

#: lib/unicodeio.c:104
msgid "iconv function not available"
msgstr "функцията iconv е недостъпна"

#: lib/unicodeio.c:111
msgid "character out of range"
msgstr "знак извън диапазона"

#: lib/unicodeio.c:181
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "не може да се конвертира U+%04X в локалното кодиране"

#: lib/unicodeio.c:183
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "не може да се конвертира U+%04X в локалното кодиране: %s"

#: lib/userspec.c:106
msgid "invalid user"
msgstr "несъществуващ потребител"

#: lib/userspec.c:107
msgid "invalid group"
msgstr "несъществуваща група"

#: lib/userspec.c:108
msgid "invalid spec"
msgstr "неправилна спецификация"

#: lib/verror.c:73
#, c-format
msgid "unable to display error message"
msgstr "съобщението за грешка не може да се изведе"

#: lib/version-etc.c:73
#, c-format
msgid "Packaged by %s (%s)\n"
msgstr "Пакетирано от %s (%s)\n"

#: lib/version-etc.c:76
#, c-format
msgid "Packaged by %s\n"
msgstr "Пакетирано от %s\n"

#. TRANSLATORS: Translate "(C)" to the copyright symbol
#. (C-in-a-circle), if this symbol is available in the user's
#. locale.  Otherwise, do not translate "(C)"; leave it as-is.
#: lib/version-etc.c:83
msgid "(C)"
msgstr "©"

#: lib/version-etc.c:85
msgid ""
"\n"
"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl."
"html>.\n"
"This is free software: you are free to change and redistribute it.\n"
"There is NO WARRANTY, to the extent permitted by law.\n"
"\n"
msgstr ""
"\n"
"Лиценз — Общ публичен лиценз на GNU (GNU GPL), както е публикуван от "
"Фондацията\n"
"за свободен софтуер — версия 3 на лиценза или (по ваше решение) по-късна "
"версия.\n"
"<https://gnu.org/licenses/gpl.html>\n"
"Тази програма е свободен софтуер. Можете да я разпространявате и/или "
"променяте.\n"
"Тя се разпространява БЕЗ НИКАКВИ ГАРАНЦИИ доколкото е позволено от закона.\n"

#. TRANSLATORS: %s denotes an author name.
#: lib/version-etc.c:102
#, c-format
msgid "Written by %s.\n"
msgstr "Създадено от %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:106
#, c-format
msgid "Written by %s and %s.\n"
msgstr "Създадено от %s и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:110
#, c-format
msgid "Written by %s, %s, and %s.\n"
msgstr "Създадено от %s, %s и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:117
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"Създадено от %s, %s, %s\n"
"и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:124
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"Създадено от %s, %s, %s,\n"
"%s и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:131
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, and %s.\n"
msgstr ""
"Създадено от %s, %s, %s,\n"
"%s, %s и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:139
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, and %s.\n"
msgstr ""
"Създадено от %s, %s, %s,\n"
"%s, %s, %s и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:147
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"Създадено от %s, %s, %s,\n"
"%s, %s, %s, %s\n"
"и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:156
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"Създадено от %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:167
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, %s, and others.\n"
msgstr ""
"Създадено от %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, %s и др.\n"

#. TRANSLATORS: The placeholder indicates the bug-reporting address
#. for this package.  Please add _another line_ saying
#. "Report translation bugs to <...>\n" with the address for translation
#. bugs (typically your translation team's web or email address).
#: lib/version-etc.c:245
#, c-format
msgid ""
"\n"
"Report bugs to: %s\n"
msgstr ""
"\n"
"Докладвайте грешки в програмата на адрес: %s\n"
"Докладвайте грешки в превода на адрес: <dict@ludost.net>\n"

#: lib/version-etc.c:247
#, c-format
msgid "Report %s bugs to: %s\n"
msgstr "Докладвайте грешки в „%s“ на адрес: %s\n"

#: lib/version-etc.c:251
#, c-format
msgid "%s home page: <%s>\n"
msgstr "Уеб страница на „%s“: <%s>\n"

#: lib/version-etc.c:253
#, c-format
msgid "%s home page: <https://www.gnu.org/software/%s/>\n"
msgstr "Уеб страница на „%s“: <https://www.gnu.org/software/%s/>\n"

#: lib/version-etc.c:256
msgid "General help using GNU software: <https://www.gnu.org/gethelp/>\n"
msgstr "Обща помощ за програмите на GNU: <https://www.gnu.org/gethelp/>\n"

#: lib/xbinary-io.c:37
#, c-format
msgid "failed to set file descriptor text/binary mode"
msgstr "неуспешно задаване на вид на файла като текстов/двоичен"

#: lib/xmemcoll.c:39 src/expr.c:1026
#, c-format
msgid "string comparison failed"
msgstr "сравнението на низове не успя"

#: lib/xmemcoll.c:40
#, c-format
msgid "Set LC_ALL='C' to work around the problem."
msgstr "Използвайте LC_ALL='C', за да заобиколите този проблем."

#: lib/xmemcoll.c:42
#, c-format
msgid "The strings compared were %s and %s."
msgstr "Сравняваните низове бяха %s и %s."

#: lib/xprintf.c:50 lib/xprintf.c:76
#, c-format
msgid "cannot perform formatted output"
msgstr "невъзможно форматиране на изхода"

#: lib/xstrtol-error.c:63
#, c-format
msgid "invalid %s%s argument '%s'"
msgstr "неправилен аргумент „%3$s“ за опцията „%1$s%2$s“"

#: lib/xstrtol-error.c:68
#, c-format
msgid "invalid suffix in %s%s argument '%s'"
msgstr "неправилен суфикс в аргумента „%3$s“ за опцията „%1$s%2$s“"

#: lib/xstrtol-error.c:72
#, c-format
msgid "%s%s argument '%s' too large"
msgstr "прекалено дълъг аргумент „%3$s“ за опцията „%1$s%2$s“"

#. This is a proper name. See the gettext manual, section Names.
#: src/basename.c:29 src/chgrp.c:38 src/chmod.c:39 src/chown.c:37 src/comm.c:39
#: src/cp.c:48 src/csplit.c:45 src/cut.c:46 src/date.c:40 src/dd.c:45
#: src/df.c:48 src/dirname.c:32 src/du.c:54 src/env.c:39 src/expand.c:49
#: src/fold.c:36 src/groups.c:36 src/head.c:47 src/id.c:42 src/install.c:51
#: src/ln.c:52 src/ls.c:131 src/mkdir.c:39 src/mkfifo.c:36 src/mknod.c:37
#: src/mv.c:43 src/nice.c:40 src/nl.c:42 src/paste.c:53 src/pathchk.c:32
#: src/pinky.c:38 src/printenv.c:44 src/printf.c:68 src/rm.c:41 src/rmdir.c:37
#: src/stty.c:68 src/sum.c:39 src/tac.c:58 src/tail.c:77 src/tee.c:38
#: src/touch.c:45 src/tty.c:44 src/uname.c:61 src/unexpand.c:50 src/uniq.c:43
#: src/uptime.c:46 src/users.c:36 src/wc.c:51 src/who.c:51 src/yes.c:32
msgid "David MacKenzie"
msgstr "David MacKenzie"

#: src/basename.c:48
#, c-format
msgid ""
"Usage: %s NAME [SUFFIX]\n"
"  or:  %s OPTION... NAME...\n"
msgstr ""
"Употреба: %s ИМЕ [РАЗШИРЕНИЕ]\n"
"     или: %s ОПЦИЯ… ИМЕ…\n"

#: src/basename.c:53
msgid ""
"Print NAME with any leading directory components removed.\n"
"If specified, also remove a trailing SUFFIX.\n"
msgstr ""
"Отстраняване на началните директории от ИМЕто и отпечатване.\n"
"Ако е посочено, се изтрива и РАЗШИРЕНИЕто в края.\n"

#: src/basename.c:60
msgid ""
"  -a, --multiple       support multiple arguments and treat each as a NAME\n"
"  -s, --suffix=SUFFIX  remove a trailing SUFFIX; implies -a\n"
"  -z, --zero           end each output line with NUL, not newline\n"
msgstr ""
"  -a, --multiple       поддръжка на множество аргументи, които да са ИМЕна\n"
"  -s, --suffix=СУФИКС  премахване на такъв краен СУФИКС, включва опцията „-"
"a“\n"
"  -z, --zero           завършване на редовете с нулев байт, а не знак за нов "
"ред\n"

#: src/basename.c:67
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/sort          -> \"sort\"\n"
"  %s include/stdio.h .h     -> \"stdio\"\n"
"  %s -s .h include/stdio.h  -> \"stdio\"\n"
"  %s -a any/str1 any/str2   -> \"str1\" followed by \"str2\"\n"
msgstr ""
"\n"
"Примери:\n"
"  %s /usr/bin/sort          → „sort“\n"
"  %s include/stdio.h .h     → „stdio“\n"
"  %s -s .h include/stdio.h  → „stdio“\n"
"  %s -a any/str1 any/str2   → „str1“, следвано от „str2“\n"

#: src/basename.c:170 src/chcon.c:536 src/chgrp.c:279 src/chmod.c:529
#: src/chown.c:280 src/chroot.c:278 src/comm.c:481 src/csplit.c:1402
#: src/dirname.c:116 src/expr.c:454 src/join.c:1160 src/link.c:76
#: src/mkdir.c:252 src/mkfifo.c:130 src/mknod.c:171 src/nohup.c:107
#: src/pathchk.c:147 src/printf.c:693 src/readlink.c:145 src/realpath.c:237
#: src/rm.c:338 src/rmdir.c:222 src/seq.c:618 src/sleep.c:116 src/stat.c:1684
#: src/stdbuf.c:371 src/tr.c:1753 src/unlink.c:74
#, c-format
msgid "missing operand"
msgstr "липсващ операнд"

#: src/basename.c:176 src/basenc.c:1230 src/comm.c:489 src/cp.c:621
#: src/date.c:471 src/dircolors.c:449 src/du.c:1018 src/hostid.c:72
#: src/hostname.c:111 src/install.c:985 src/join.c:970 src/link.c:84
#: src/ln.c:593 src/logname.c:70 src/mknod.c:182 src/mv.c:451 src/nproc.c:115
#: src/od.c:1866 src/ptx.c:2082 src/seq.c:624 src/shuf.c:491 src/sort.c:4600
#: src/split.c:1554 src/tr.c:1768 src/tsort.c:559 src/tty.c:113 src/uname.c:252
#: src/uniq.c:533 src/uniq.c:550 src/unlink.c:80 src/uptime.c:251
#: src/users.c:145 src/wc.c:758 src/who.c:831 src/whoami.c:78
#, c-format
msgid "extra operand %s"
msgstr "излишен операнд: „%s“"

#. This is a proper name. See the gettext manual, section Names.
#: src/basenc.c:37 src/basenc.c:40
msgid "Simon Josefsson"
msgstr "Simon Josefsson"

#. This is a proper name. See the gettext manual, section Names.
#: src/basenc.c:38 src/env.c:40 src/numfmt.c:43
msgid "Assaf Gordon"
msgstr "Assaf Gordon"

#: src/basenc.c:101 src/dircolors.c:99 src/uptime.c:198 src/users.c:105
#, c-format
msgid "Usage: %s [OPTION]... [FILE]\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ФАЙЛ]\n"

#: src/basenc.c:106
#, fuzzy
msgid "basenc encode or decode FILE, or standard input, to standard output.\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [ФАЙЛ]\n"
"Кодиране/декодиране при основа %d от ФАЙЛ или стандартния вход към "
"стандартния изход\n"

#: src/basenc.c:110
#, fuzzy, c-format
msgid "Base%d encode or decode FILE, or standard input, to standard output.\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [ФАЙЛ]\n"
"Кодиране/декодиране при основа %d от ФАЙЛ или стандартния вход към "
"стандартния изход\n"

#: src/basenc.c:118
msgid "      --base64          same as 'base64' program (RFC4648 section 4)\n"
msgstr ""

#: src/basenc.c:121
msgid "      --base64url       file- and url-safe base64 (RFC4648 section 5)\n"
msgstr ""

#: src/basenc.c:124
msgid "      --base32          same as 'base32' program (RFC4648 section 6)\n"
msgstr ""

#: src/basenc.c:127
msgid ""
"      --base32hex       extended hex alphabet base32 (RFC4648 section 7)\n"
msgstr ""

#: src/basenc.c:130
msgid "      --base16          hex encoding (RFC4648 section 8)\n"
msgstr ""

#: src/basenc.c:133
msgid ""
"      --base2msbf       bit string with most significant bit (msb) first\n"
msgstr ""

#: src/basenc.c:136
msgid ""
"      --base2lsbf       bit string with least significant bit (lsb) first\n"
msgstr ""

#: src/basenc.c:140
msgid ""
"  -d, --decode          decode data\n"
"  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n"
"  -w, --wrap=COLS       wrap encoded lines after COLS character (default "
"76).\n"
"                          Use 0 to disable line wrapping\n"
"\n"
msgstr ""
"  -d, --decode          декодиране на данни\n"
"  -i, --ignore-garbage  прескачане на знаците извън 0-9, A-Z, a-z\n"
"  -w, --wrap=ЗНАЦИ      пренасяне на редовете на всеки толкова ЗНАЦИ "
"(стандартно\n"
"                        76).  С 0 пренасянето се изключва\n"
"\n"

#: src/basenc.c:148
msgid ""
"      --z85             ascii85-like encoding (ZeroMQ spec:32/Z85);\n"
"                        when encoding, input length must be a multiple of "
"4;\n"
"                        when decoding, input length must be a multiple of 5\n"
msgstr ""

#: src/basenc.c:157
#, fuzzy
msgid ""
"\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"Данните се кодират с азбука „%s“, както това е описано в RFC 4648.\n"
"При декодирането се приемат и нови редове към знаците от азбуката „%s“.\n"
"За да се продължи работата дори и при получаване на неправилни входни\n"
"данни, ползвайте опцията „--ignore-garbage„“.\n"

#: src/basenc.c:164
#, c-format
msgid ""
"\n"
"The data are encoded as described for the %s alphabet in RFC 4648.\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"Данните се кодират с азбука „%s“, както това е описано в RFC 4648.\n"
"При декодирането се приемат и нови редове към знаците от азбуката „%s“.\n"
"За да се продължи работата дори и при получаване на неправилни входни\n"
"данни, ползвайте опцията „--ignore-garbage„“.\n"

#: src/basenc.c:624
msgid "invalid input (length must be multiple of 4 characters)"
msgstr ""

#: src/basenc.c:1014 src/basenc.c:1060 src/csplit.c:277 src/csplit.c:1468
#: src/join.c:465 src/shuf.c:233 src/shuf.c:279 src/shuf.c:554
#: src/tac-pipe.c:76 src/tee.c:263 src/tr.c:1611
#, c-format
msgid "read error"
msgstr "грешка при четене"

#: src/basenc.c:1079
msgid "invalid input"
msgstr "грешни входни данни"

#: src/basenc.c:1126
msgid "invalid wrap size"
msgstr "неправилен брой знаци, след които да се пренася"

#: src/basenc.c:1223
#, fuzzy, c-format
msgid "missing encoding type"
msgstr "липсва операнд след „%s“"

#: src/basenc.c:1261 src/cat.c:764
msgid "closing standard input"
msgstr "затваряне на стандартния вход"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:48 src/cp.c:47 src/df.c:47 src/du.c:53 src/factor.c:129
#: src/split.c:49
msgid "Torbjorn Granlund"
msgstr "Torbjorn Granlund"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:49 src/comm.c:38 src/ls.c:130 src/rm.c:42 src/split.c:50
#: src/tee.c:37 src/uniq.c:42
msgid "Richard M. Stallman"
msgstr "Richard M. Stallman"

#: src/cat.c:88 src/df.c:1510 src/expand.c:69 src/fold.c:66 src/head.c:110
#: src/ls.c:5133 src/nl.c:176 src/paste.c:436 src/pr.c:2736 src/rm.c:133
#: src/sum.c:59 src/tac.c:132 src/tail.c:265 src/tee.c:87 src/unexpand.c:78
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ФАЙЛ]…\n"

#: src/cat.c:92
msgid "Concatenate FILE(s) to standard output.\n"
msgstr "Последователно извеждане на ФАЙЛовете на стандартния изход\n"

#: src/cat.c:98
msgid ""
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonempty output lines, overrides -n\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      suppress repeated empty output lines\n"
msgstr ""
"\n"
"  -A, --show-all           еквивалентно на „-vET“\n"
"  -b, --number-nonblank    номериране на непразните редове на изхода, с\n"
"                           предимство пред „-n“\n"
"  -e                       еквивалентно на „-vE“\n"
"  -E, --show-ends          извеждане на „$“ в края на всеки ред\n"
"  -n, --number             номериране на изведените редове\n"
"  -s, --squeeze-blank      съкращаване на всяка последователност от "
"множество\n"
"                           празни редове в един\n"

#: src/cat.c:107
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       еквивалентно на „-vT“\n"
"  -T, --show-tabs          изобразяване на табулациите като „^I“\n"
"  -u                       (пренебрегва се)\n"
"  -v, --show-nonprinting   вариант с „^“ и „M-“, освен за нов ред и "
"табулация\n"

#: src/cat.c:115
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s f - g  Output f's contents, then standard input, then g's contents.\n"
"  %s        Copy standard input to standard output.\n"
msgstr ""
"\n"
"Примери:\n"
"  %s f - g  Извеждане на съдържанието на „f“, на стандартния изход и после "
"„g“\n"
"  %s        Копиране на стандартния вход на стандартния изход.\n"

#: src/cat.c:327
#, c-format
msgid "cannot do ioctl on %s"
msgstr "не може да се изпълни „ioctl“ за „%s“"

#: src/cat.c:638 src/dd.c:2425 src/sort.c:409 src/tail.c:2444 src/tee.c:207
#: src/yes.c:124
#, c-format
msgid "standard output"
msgstr "стандартен изход"

#: src/cat.c:699
#, c-format
msgid "%s: input file is output file"
msgstr "%s: входният файл е изходен файл"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:36 src/runcon.c:57
msgid "Russell Coker"
msgstr ""

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:37 src/chgrp.c:39 src/chmod.c:40 src/chown.c:38 src/cp.c:49
#: src/cut.c:47 src/dirname.c:33 src/du.c:56 src/head.c:48 src/hostid.c:32
#: src/hostname.c:33 src/mktemp.c:36 src/mv.c:44 src/nohup.c:34 src/od.c:39
#: src/pathchk.c:33 src/pwd.c:32 src/rm.c:43 src/sleep.c:34 src/sync.c:33
#: src/tail.c:79 src/tr.c:38 src/true.c:33
msgid "Jim Meyering"
msgstr "Jim Meyering"

#: src/chcon.c:100 src/runcon.c:202 src/runcon.c:233
#, fuzzy, c-format
msgid "failed to create security context: %s"
msgstr ""
"%s: ПРЕДУПРЕЖДЕНИЕ: контекстът за сигурност на „%s“ не може да се получи: %s"

#: src/chcon.c:112
#, fuzzy, c-format
msgid "failed to set %s security context component to %s"
msgstr ""
"%s: ПРЕДУПРЕЖДЕНИЕ: контекстът за сигурност на „%s“ не може да се получи: %s"

#: src/chcon.c:156 src/chcon.c:547 src/copy.c:924 src/runcon.c:216
#: src/stat.c:795
#, c-format
msgid "failed to get security context of %s"
msgstr "неуспешно получаване на контекста за сигурност на „%s“"

#: src/chcon.c:166
#, c-format
msgid "can't apply partial context to unlabeled file %s"
msgstr ""

#: src/chcon.c:190
#, fuzzy, c-format
msgid "failed to change context of %s to %s"
msgstr "Неуспешна смяна на текущата директория: %s"

#: src/chcon.c:255 src/chmod.c:218 src/chown-core.c:324 src/copy.c:725
#: src/du.c:532 src/ls.c:3245
#, c-format
msgid "cannot access %s"
msgstr "няма достъп до „%s“"

#: src/chcon.c:266 src/chmod.c:231 src/chown-core.c:337 src/du.c:512
#, c-format
msgid "cannot read directory %s"
msgstr "директорията „%s“ не може да се чете"

#: src/chcon.c:293
#, fuzzy, c-format
msgid "changing security context of %s\n"
msgstr ""
"%s: ПРЕДУПРЕЖДЕНИЕ: контекстът за сигурност на „%s“ не може да се получи: %s"

#: src/chcon.c:327 src/chmod.c:349 src/chown-core.c:538 src/remove.c:601
#: src/selinux.c:323
#, c-format
msgid "fts_read failed"
msgstr "неуспешно изпълнение на „fts_read“"

#: src/chcon.c:338 src/chmod.c:360 src/chown-core.c:550 src/du.c:713
#: src/remove.c:615 src/selinux.c:334
#, c-format
msgid "fts_close failed"
msgstr "неуспешно изпълнение на „fts_close“"

#: src/chcon.c:352
#, c-format
msgid ""
"Usage: %s [OPTION]... CONTEXT FILE...\n"
"  or:  %s [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… КОНТЕКСТ ФАЙЛ…\n"
"     или: %s [ОПЦИЯ]… [-u СОБСТВЕНИК] [-r РОЛЯ] [-l ДИАПАЗОН] [-t ВИД] "
"ФАЙЛ…\n"
"     или: %s [ОПЦИЯ]… --reference=ФАЙЛ_ЕТАЛОН ФАЙЛ…\n"

#: src/chcon.c:358
msgid ""
"Change the SELinux security context of each FILE to CONTEXT.\n"
"With --reference, change the security context of each FILE to that of "
"RFILE.\n"
msgstr ""

#: src/chcon.c:365 src/chgrp.c:125 src/chown.c:95
msgid ""
"      --dereference      affect the referent of each symbolic link (this is\n"
"                         the default), rather than the symbolic link itself\n"
"  -h, --no-dereference   affect symbolic links instead of any referenced "
"file\n"
msgstr ""

#: src/chcon.c:370
msgid ""
"  -u, --user=USER        set user USER in the target security context\n"
"  -r, --role=ROLE        set role ROLE in the target security context\n"
"  -t, --type=TYPE        set type TYPE in the target security context\n"
"  -l, --range=RANGE      set range RANGE in the target security context\n"
msgstr ""

#: src/chcon.c:376 src/chgrp.c:134 src/chmod.c:390 src/chown.c:111
#, fuzzy
msgid ""
"      --no-preserve-root  do not treat '/' specially (the default)\n"
"      --preserve-root    fail to operate recursively on '/'\n"
msgstr ""
"      --no-preserve-root да не се обработва „/“ по-особено (по "
"подразбиране)\n"
"      --preserve-root    да не се действа рекурсивно от „/“\n"

#: src/chcon.c:380
msgid ""
"      --reference=RFILE  use RFILE's security context rather than "
"specifying\n"
"                         a CONTEXT value\n"
msgstr ""

#: src/chcon.c:384 src/chgrp.c:142 src/chown.c:119
#, fuzzy
msgid "  -R, --recursive        operate on files and directories recursively\n"
msgstr "-r, --recursive               рекурсивно сравнение на директориите"

#: src/chcon.c:387
msgid "  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""

#: src/chcon.c:390 src/chgrp.c:145 src/chown.c:122
#, fuzzy
msgid ""
"\n"
"The following options modify how a hierarchy is traversed when the -R\n"
"option is also specified.  If more than one is specified, only the final\n"
"one takes effect.\n"
"\n"
"  -H                     if a command line argument is a symbolic link\n"
"                         to a directory, traverse it\n"
"  -L                     traverse every symbolic link to a directory\n"
"                         encountered\n"
"  -P                     do not traverse any symbolic links (default)\n"
"\n"
msgstr ""
"Следните опции влияят на обхождането на йерархията, когато е посочена\n"
"също и опция -R.  Ако е зададена повече от една тях, взема се пред вид\n"
"само последната зададена.\n"
"\n"
"\n"
"  -H                     ако аргумент от командния ред е символна връзка\n"
"                         към каталог, да се обходи и той\n"
"  -L                     да се обхожда всеки каталог, сочен от срещната\n"
"                         символна връзка\n"
"  -P                     да не се обхождат символните връзки (по "
"подразбиране)\n"
"\n"

#: src/chcon.c:517 src/chgrp.c:266 src/chown.c:267
msgid "-R --dereference requires either -H or -L"
msgstr "-R --dereference изисква -H или -L"

#: src/chcon.c:523
msgid "-R -h requires -P"
msgstr "-R -h изисква -P"

#: src/chcon.c:538 src/chgrp.c:281 src/chmod.c:531 src/chown.c:282
#: src/comm.c:483 src/csplit.c:1404 src/join.c:1162 src/link.c:78
#: src/mknod.c:173 src/tr.c:1756
#, c-format
msgid "missing operand after %s"
msgstr "липсва операнд след „%s“"

#: src/chcon.c:561 src/runcon.c:250
#, fuzzy, c-format
msgid "invalid context: %s"
msgstr "неправилен размер на контекста „%s“"

#: src/chcon.c:567
#, fuzzy, c-format
msgid "conflicting security context specifiers given"
msgstr "зададените изрази за съвпадение са в конфликт"

#: src/chcon.c:576 src/chgrp.c:289 src/chgrp.c:307 src/chmod.c:539
#: src/chmod.c:558 src/chown.c:290 src/chown.c:319 src/cp.c:422 src/cp.c:489
#: src/mv.c:99 src/pwd.c:276 src/rm.c:348 src/touch.c:348
#, c-format
msgid "failed to get attributes of %s"
msgstr "атрибутите на „%s“ не може да се получат"

#: src/chgrp.c:93
#, fuzzy, c-format
msgid "invalid group: %s"
msgstr "неправилен режим „%s“"

#: src/chgrp.c:110
#, c-format
msgid ""
"Usage: %s [OPTION]... GROUP FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… ГРУПА ФАЙЛ…\n"
"     или: %s [ОПЦИЯ]… --reference=ФАЙЛ_ЕТАЛОН ФАЙЛ…\n"

#: src/chgrp.c:115
msgid ""
"Change the group of each FILE to GROUP.\n"
"With --reference, change the group of each FILE to that of RFILE.\n"
"\n"
msgstr ""

#: src/chgrp.c:120 src/chmod.c:385 src/chown.c:90
msgid ""
"  -c, --changes          like verbose but report only when a change is made\n"
"  -f, --silent, --quiet  suppress most error messages\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""

#: src/chgrp.c:130 src/chown.c:100
#, fuzzy
msgid ""
"                         (useful only on systems that can change the\n"
"                         ownership of a symlink)\n"
msgstr ""
"  -h, --no-dereference   действа върху символните връзки, вместо върху "
"сочените\n"
"                         файлове (само при системи, позволяващи промяна на\n"
"                         собствеността на символна връзка)\n"

#: src/chgrp.c:138
msgid ""
"      --reference=RFILE  use RFILE's group rather than specifying a\n"
"                         GROUP value\n"
msgstr ""

#: src/chgrp.c:160
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s staff /u      Change the group of /u to \"staff\".\n"
"  %s -hR staff /u  Change the group of /u and subfiles to \"staff\".\n"
msgstr ""
"\n"
"Примери:\n"
"  %s staff /u      прави групата на /u да бъде „staff“.\n"
"  %s -hR staff /u  прави групата на /u и файловете в /u да бъде „staff“.\n"

#: src/chmod.c:127
#, c-format
msgid "getting new attributes of %s"
msgstr "получават се новите атрибути на %s"

#: src/chmod.c:151 src/chown-core.c:146
#, c-format
msgid "neither symbolic link %s nor referent has been changed\n"
msgstr "нито символната връзка %s, нито соченият файл бяха променени\n"

#: src/chmod.c:165
#, fuzzy, c-format
msgid "mode of %s changed from %04lo (%s) to %04lo (%s)\n"
msgstr "режимът за достъп до %s е променен на %04lo (%s)\n"

#: src/chmod.c:168
#, fuzzy, c-format
msgid "failed to change mode of %s from %04lo (%s) to %04lo (%s)\n"
msgstr "режимът за достъп до %s не може да се смени на %04lo (%s)\n"

#: src/chmod.c:171
#, c-format
msgid "mode of %s retained as %04lo (%s)\n"
msgstr "режимът за достъп до %s е запазен на %04lo (%s)\n"

#: src/chmod.c:238
#, fuzzy, c-format
msgid "cannot operate on dangling symlink %s"
msgstr "%s: неуспешно създаване на символна връзка към %s"

#: src/chmod.c:278
#, c-format
msgid "changing permissions of %s"
msgstr "променят се правата за достъп до %s"

#: src/chmod.c:314
#, c-format
msgid "%s: new permissions are %s, not %s"
msgstr "%s: новият режим за достъп е %s, а не %s"

#: src/chmod.c:374
#, c-format
msgid ""
"Usage: %s [OPTION]... MODE[,MODE]... FILE...\n"
"  or:  %s [OPTION]... OCTAL-MODE FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… РЕЖИМ[,РЕЖИМ]… ФАЙЛ…\n"
"     или: %s [ОПЦИЯ]… ОСМИЧЕН_РЕЖИМ ФАЙЛ…\n"
"     или: %s [ОПЦИЯ]… --reference=ФАЙЛ_ЕТАЛОН ФАЙЛ…\n"

#: src/chmod.c:380
msgid ""
"Change the mode of each FILE to MODE.\n"
"With --reference, change the mode of each FILE to that of RFILE.\n"
"\n"
msgstr ""

#: src/chmod.c:394
msgid "      --reference=RFILE  use RFILE's mode instead of MODE values\n"
msgstr ""

#: src/chmod.c:397
#, fuzzy
msgid "  -R, --recursive        change files and directories recursively\n"
msgstr "-r, --recursive               рекурсивно сравнение на директориите"

#: src/chmod.c:402
#, fuzzy
msgid ""
"\n"
"Each MODE is of the form '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.\n"
msgstr ""
"\n"
"Всеки РЕЖИМ е от вида „[ugoa]*([-+=]([rwxXst]*|[ugo]))+“.\n"

#: src/chmod.c:516
#, c-format
msgid "cannot combine mode and --reference options"
msgstr "не може да се комбинират опциите за режим и --reference"

#: src/chmod.c:547
#, c-format
msgid "invalid mode: %s"
msgstr "неправилен режим за достъп %s"

#: src/chown-core.c:157
#, c-format
msgid "changed ownership of %s from %s to %s\n"
msgstr "собственикът на „%s“ е сменен от „%s“ на „%s“\n"

#: src/chown-core.c:158
#, c-format
msgid "changed group of %s from %s to %s\n"
msgstr "групата на „%s“ е сменена от „%s“ на „%s“\n"

#: src/chown-core.c:159
#, c-format
msgid "no change to ownership of %s\n"
msgstr "без промяна на собственика на %s\n"

#: src/chown-core.c:164
#, c-format
msgid "failed to change ownership of %s from %s to %s\n"
msgstr "неуспешна смяна на собственика на „%s“ от „%s“ на „%s“\n"

#: src/chown-core.c:165
#, c-format
msgid "failed to change group of %s from %s to %s\n"
msgstr "неуспешна смяна на групата на „%s“ от „%s“ на „%s“\n"

#: src/chown-core.c:166 src/chown-core.c:172
#, c-format
msgid "failed to change ownership of %s\n"
msgstr "неуспешна промяна на собственик на „%s“\n"

#: src/chown-core.c:170
#, c-format
msgid "failed to change ownership of %s to %s\n"
msgstr "неуспешна промяна на собственик на „%s“ на „%s“\n"

#: src/chown-core.c:171
#, c-format
msgid "failed to change group of %s to %s\n"
msgstr "неуспешна промяна на групата на „%s“ на „%s“\n"

#: src/chown-core.c:179
#, c-format
msgid "ownership of %s retained as %s\n"
msgstr "собственикът на „%s“ остана „%s“\n"

#: src/chown-core.c:180
#, c-format
msgid "group of %s retained as %s\n"
msgstr "групата на „%s“ остана „%s“\n"

#: src/chown-core.c:181
#, c-format
msgid "ownership of %s retained\n"
msgstr "собственикът на „%s“ остана непроменен\n"

#: src/chown-core.c:378
#, c-format
msgid "cannot dereference %s"
msgstr "символната връзка „%s“ не може да бъде последвана"

#: src/chown-core.c:466
#, c-format
msgid "changing ownership of %s"
msgstr "собственикът на „%s“ се променя"

#: src/chown-core.c:467
#, c-format
msgid "changing group of %s"
msgstr "групата на „%s“ се променя"

#: src/chown.c:80
#, c-format
msgid ""
"Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [СОБСТВЕНИК][:[ГРУПА]] ФАЙЛ…\n"
"    или:  %s [ОПЦИЯ]… --reference=ФАЙЛ_ЕТАЛОН ФАЙЛ…\n"

#: src/chown.c:85
msgid ""
"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
"With --reference, change the owner and group of each FILE to those of "
"RFILE.\n"
"\n"
msgstr ""

#: src/chown.c:104
#, fuzzy
msgid ""
"      --from=CURRENT_OWNER:CURRENT_GROUP\n"
"                         change the owner and/or group of each file only if\n"
"                         its current owner and/or group match those "
"specified\n"
"                         here.  Either may be omitted, in which case a "
"match\n"
"                         is not required for the omitted attribute\n"
msgstr ""
"      --from=ТЕКУЩ_СОБСТВЕНИК:ТЕКУЩА_ГРУПА\n"
"                         собственикът и/или групата на всеки файл се "
"променя\n"
"                         само ако текущият му собственик и/или група "
"отговарят\n"
"                         на посочените. Всяко от двете може да се изпусне, "
"при\n"
"                         което съответствие с пропуснатия атрибут не е "
"нужно.\n"

#: src/chown.c:115
msgid ""
"      --reference=RFILE  use RFILE's owner and group rather than\n"
"                         specifying OWNER:GROUP values\n"
msgstr ""

#: src/chown.c:137
#, fuzzy
msgid ""
"\n"
"Owner is unchanged if missing.  Group is unchanged if missing, but changed\n"
"to login group if implied by a ':' following a symbolic OWNER.\n"
"OWNER and GROUP may be numeric as well as symbolic.\n"
msgstr ""
"\n"
"Ако собственик не е посочен, той остава непроменен.  Ако група не е\n"
"посочена, тя остава непроменена, освен ако има „:“, в който случай се "
"използва\n"
"входящата група на новия собственик. СОБСТВЕНИК и ГРУПА могат да бъдат\n"
"както номера, така и имена.\n"

#: src/chown.c:143
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s root /u        Change the owner of /u to \"root\".\n"
"  %s root:staff /u  Likewise, but also change its group to \"staff\".\n"
"  %s -hR root /u    Change the owner of /u and subfiles to \"root\".\n"
msgstr ""
"\n"
"Примери:\n"
"  %s root /u       прави собственика на /u да бъде „root“.\n"
"  %s root:staff /u подобно, но променя и групата на „staff“.\n"
"  %s -hR root /u   прави собственика на /u и файловете в /u да е „root“.\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/chroot.c:39
msgid "Roland McGrath"
msgstr "Roland McGrath"

#: src/chroot.c:138 src/install.c:608
#, c-format
msgid "invalid group %s"
msgstr "неправилна група %s"

#: src/chroot.c:153
#, fuzzy, c-format
msgid "invalid group list %s"
msgstr "неправилна широчина „%s“"

#: src/chroot.c:186
#, fuzzy, c-format
msgid ""
"Usage: %s [OPTION] NEWROOT [COMMAND [ARG]...]\n"
"  or:  %s OPTION\n"
msgstr "Употреба: %s [ОПЦИЯ]… КОМАНДА [ПЪРВОНАЧАЛЕН_АРГУМЕНТ]…\n"

#: src/chroot.c:191
msgid ""
"Run COMMAND with root directory set to NEWROOT.\n"
"\n"
msgstr ""
"Изпълнява КОМАНДА с коренов каталог НОВКОРЕНОВ.\n"
"\n"

#: src/chroot.c:196
msgid "  --groups=G_LIST        specify supplementary groups as g1,g2,..,gN\n"
msgstr ""

#: src/chroot.c:199
msgid "  --userspec=USER:GROUP  specify user and group (ID or name) to use\n"
msgstr ""

#: src/chroot.c:202
#, c-format
msgid "  --skip-chdir           do not change working directory to %s\n"
msgstr ""

#: src/chroot.c:208
#, fuzzy
msgid ""
"\n"
"If no command is given, run '\"$SHELL\" -i' (default: '/bin/sh -i').\n"
msgstr ""
"\n"
"Ако не е посочена команда, изпълнява „${SHELL} -i“ (по подразбиране: /bin/"
"sh).\n"

#: src/chroot.c:287
#, c-format
msgid "option --skip-chdir only permitted if NEWROOT is old %s"
msgstr ""

#: src/chroot.c:330
#, c-format
msgid "cannot change root directory to %s"
msgstr "кореновият каталог не може да се смени на %s"

#: src/chroot.c:334
msgid "cannot chdir to root directory"
msgstr "с chdir не може да се влиза в главния каталог"

#: src/chroot.c:376
#, c-format
msgid "no group specified for unknown uid: %d"
msgstr ""

#: src/chroot.c:401
#, fuzzy
msgid "failed to get supplemental groups"
msgstr "променливата на средата „%s“ не може да се зададе"

#: src/chroot.c:413
#, fuzzy
msgid "failed to set supplemental groups"
msgstr "променливата на средата „%s“ не може да се зададе"

#: src/chroot.c:419
#, fuzzy
msgid "failed to set group-ID"
msgstr "неуспешно задаване на двоичен режим за стандартния вход (STDIN)"

#: src/chroot.c:422
#, fuzzy
msgid "failed to set user-ID"
msgstr "Неуспешно извеждане на стандартната грешка"

#: src/chroot.c:428 src/nohup.c:222 src/stdbuf.c:392 src/timeout.c:519
#, c-format
msgid "failed to run command %s"
msgstr "неуспешно изпълнение на командата „%s“"

#. This is a proper name. See the gettext manual, section Names.
#: src/cksum.c:40
msgid "Q. Frank Xia"
msgstr "Q. Frank Xia"

#: src/cksum.c:210
#, c-format
msgid "%s: file too long"
msgstr "%s: файлът е твърде дълъг"

#: src/cksum.c:257
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Употреба: %s [ФАЙЛ]…\n"
"     или: %s [ОПЦИЯ]\n"

#: src/cksum.c:262
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""
"Извеждане на контролната сума и броя байтове на всеки ФАЙЛ.\n"
"\n"

#: src/comm.c:112 src/join.c:192
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "Употреба: %s [ОПЦИЯ]… ФАЙЛ_1 ФАЙЛ_2\n"

#: src/comm.c:116
msgid "Compare sorted files FILE1 and FILE2 line by line.\n"
msgstr "Сравнява сортираните файлове ФАЙЛ1 и ФАЙЛ2 ред по ред.\n"

#: src/comm.c:119 src/join.c:201
#, fuzzy
msgid ""
"\n"
"When FILE1 or FILE2 (not both) is -, read standard input.\n"
msgstr "Ако за ФАЙЛ е използвано „-“, се чете от стандартния вход."

#: src/comm.c:123
msgid ""
"\n"
"With no options, produce three-column output.  Column one contains\n"
"lines unique to FILE1, column two contains lines unique to FILE2,\n"
"and column three contains lines common to both files.\n"
msgstr ""
"\n"
"Без опции извежда информацията в триколонен формат.  Първият стълб съдържа\n"
"редовете, които са само във ФАЙЛ1.  Вторият стълб съдържа редовете, които\n"
"са само във ФАЙЛ2.  Третият стълб съдържа редовете, общи и за двата файла.\n"

#: src/comm.c:129
#, fuzzy
msgid ""
"\n"
"  -1              suppress column 1 (lines unique to FILE1)\n"
"  -2              suppress column 2 (lines unique to FILE2)\n"
"  -3              suppress column 3 (lines that appear in both files)\n"
msgstr ""
"\n"
"  -1              не извежда редовете, които са само във ФАЙЛ1\n"
"  -2              не извежда редовете, които са само във ФАЙЛ2\n"
"  -3              не извежда редовете, които се появяват и в двата файла\n"

#: src/comm.c:135
msgid ""
"\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
msgstr ""

#: src/comm.c:141
msgid "  --output-delimiter=STR  separate columns with STR\n"
msgstr ""

#: src/comm.c:144
msgid "  --total           output a summary\n"
msgstr ""

#: src/comm.c:147 src/cut.c:178 src/head.c:134 src/numfmt.c:945 src/paste.c:452
#: src/tail.c:312
msgid "  -z, --zero-terminated    line delimiter is NUL, not newline\n"
msgstr ""
"  -z, --zero-terminated     завършване на редовете с нулев байт вместо с нов "
"ред\n"

#: src/comm.c:152
msgid ""
"\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
msgstr ""

#: src/comm.c:156
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s -12 file1 file2  Print only lines present in both file1 and file2.\n"
"  %s -3 file1 file2  Print lines in file1 not in file2, and vice versa.\n"
msgstr ""

#: src/comm.c:238
#, c-format
msgid "file %d is not in sorted order"
msgstr ""

#: src/comm.c:402 src/du.c:1136 src/ls.c:2876 src/wc.c:885
msgid "total"
msgstr "общо"

#: src/comm.c:458
#, fuzzy
msgid "multiple output delimiters specified"
msgstr "мултиплексиран знаков специален файл"

#: src/comm.c:496 src/join.c:1196
msgid "input is not in sorted order"
msgstr ""

#: src/copy.c:194 src/copy.c:465
#, c-format
msgid "cannot lseek %s"
msgstr "не може да се препозиционира с „lseek“ в „%s“"

#: src/copy.c:204 src/copy.c:571
#, c-format
msgid "error deallocating %s"
msgstr "грешка при връщане на заделената памет за „%s“"

#: src/copy.c:242 src/dd.c:1859 src/dd.c:2195 src/du.c:1133 src/head.c:157
#: src/head.c:308 src/head.c:390 src/head.c:586 src/head.c:668 src/head.c:737
#: src/head.c:787 src/head.c:810 src/tail.c:464 src/tail.c:557 src/tail.c:606
#: src/tail.c:699 src/tail.c:827 src/tail.c:875 src/tail.c:912 src/tail.c:2037
#: src/tail.c:2070 src/uniq.c:473
#, c-format
msgid "error reading %s"
msgstr "грешка при четене на „%s“"

#: src/copy.c:275 src/dd.c:2258 src/dd.c:2320 src/head.c:185 src/tail.c:438
#, c-format
msgid "error writing %s"
msgstr "грешка при записа на „%s“"

#: src/copy.c:306
#, c-format
msgid "overflow reading %s"
msgstr "препълване при четене на „%s“"

#: src/copy.c:419
#, c-format
msgid "%s: failed to get extents info"
msgstr "%s: неуспешно получаване на информацията за обхватите"

#: src/copy.c:491
#, c-format
msgid "%s: write failed"
msgstr "%s: неуспешен запис"

#: src/copy.c:564 src/copy.c:1308
#, c-format
msgid "failed to extend %s"
msgstr "неуспешно разширяване на „%s“"

#: src/copy.c:806
#, c-format
msgid "clearing permissions for %s"
msgstr "задаване на правата за достъп до „%s“"

#: src/copy.c:841 src/copy.c:2755 src/cp.c:318
#, c-format
msgid "failed to preserve ownership for %s"
msgstr "собствеността на „%s“ не можа да се запази"

#: src/copy.c:867
#, c-format
msgid "failed to lookup file %s"
msgstr "файлът „%s“ не може да се търси"

#: src/copy.c:872
#, c-format
msgid "failed to preserve authorship for %s"
msgstr "авторството на „%s“ не можа да се запази"

#: src/copy.c:909 src/cp.c:1205 src/install.c:961 src/mkdir.c:269
#: src/mkfifo.c:144 src/mknod.c:200
#, c-format
msgid "failed to set default file creation context to %s"
msgstr ""
"неуспешно задаване на стандартния контекст за създаването на файла да е „%s“"

#: src/copy.c:939
#, c-format
msgid "failed to set default file creation context for %s"
msgstr ""
"неуспешно задаване на стандартния контекст за създаването на файла „%s“"

#: src/copy.c:965
#, c-format
msgid "failed to set the security context of %s"
msgstr "неуспешно задаване на контекста за сигурност на „%s“"

#: src/copy.c:1038 src/csplit.c:655 src/du.c:1025 src/fmt.c:439 src/head.c:889
#: src/split.c:1570 src/tail.c:2011 src/wc.c:770
#, c-format
msgid "cannot open %s for reading"
msgstr "„%s“ не може да се отвори за четене"

#: src/copy.c:1044 src/copy.c:1197 src/dd.c:1784 src/dd.c:2332 src/dd.c:2469
#: src/head.c:848 src/tail.c:1851 src/tail.c:1914 src/truncate.c:114
#, c-format
msgid "cannot fstat %s"
msgstr "не може да се получи информация с „fstat“ за „%s“"

#: src/copy.c:1054
#, c-format
msgid "skipping file %s, as it was replaced while being copied"
msgstr "файлът „%s“ се пропуска, тъй като бе заместен по време на копирането"

#: src/copy.c:1094 src/copy.c:2185 src/remove.c:263 src/remove.c:280
#: src/remove.c:406 src/remove.c:432
#, c-format
msgid "cannot remove %s"
msgstr "„%s“ не може да се изтрие"

#: src/copy.c:1099 src/copy.c:1796 src/copy.c:2190 src/remove.c:376
#, c-format
msgid "removed %s\n"
msgstr "„%s“ е изтрит\n"

#: src/copy.c:1151
#, c-format
msgid "not writing through dangling symlink %s"
msgstr "без опит за запис през символната връзка „%s“, защото не сочи наникъде"

#: src/copy.c:1189
#, c-format
msgid "cannot create regular file %s"
msgstr "не може да се създаде обикновен файл „%s“"

#: src/copy.c:1210
#, c-format
msgid "failed to clone %s from %s"
msgstr "„%s“ не може да се клонира от „%s“"

#: src/copy.c:1323 src/copy.c:2830
#, c-format
msgid "preserving times for %s"
msgstr "времената за „%s“ се запазват"

#: src/copy.c:1403 src/copy.c:1409 src/head.c:897 src/sync.c:164
#: src/touch.c:173 src/truncate.c:392
#, c-format
msgid "failed to close %s"
msgstr "неуспешно затваряне на „%s“"

#: src/copy.c:1685
#, c-format
msgid "%s: replace %s, overriding mode %04lo (%s)? "
msgstr ""
"%s: да се замести ли „%s“ (пренебрегване на правата за достъп: %04lo, „%s“)?"

#: src/copy.c:1686
#, c-format
msgid "%s: unwritable %s (mode %04lo, %s); try anyway? "
msgstr ""
"%s: не може да се пише в „%s“ (правата за достъп са: %04lo, „%s“).  Да се "
"направи ли опит? "

#: src/copy.c:1693
#, c-format
msgid "%s: overwrite %s? "
msgstr "%s: да се замести ли „%s“? "

#: src/copy.c:1763
#, c-format
msgid " (backup: %s)"
msgstr " (резервно копие: „%s“)"

#: src/copy.c:1773
msgid "failed to restore the default file creation context"
msgstr "неуспешно възстановяване на стандартния контекст при създаване"

#: src/copy.c:1791
#, c-format
msgid "cannot create hard link %s to %s"
msgstr "не може да се направи твърда връзка „%s“ към „%s“"

#: src/copy.c:1900
#, c-format
msgid "-r not specified; omitting directory %s"
msgstr "опцията „-r“ липсва, директорията „%s“ се прескача"

#: src/copy.c:1901
#, c-format
msgid "omitting directory %s"
msgstr "директорията „%s“ се прескача"

#: src/copy.c:1924
#, c-format
msgid "warning: source file %s specified more than once"
msgstr "внимание: изходния файл „%s“ е посочен повече от един път"

#: src/copy.c:1979 src/ln.c:275
#, c-format
msgid "%s and %s are the same file"
msgstr "„%s“ и „%s“ са един и същ файл"

#: src/copy.c:2069
#, c-format
msgid "cannot overwrite non-directory %s with directory %s"
msgstr "„%s“ не е директория и не може да се замести с директорията „%s“"

#: src/copy.c:2087 src/ln.c:246
#, c-format
msgid "will not overwrite just-created %s with %s"
msgstr "току що създаденият „%s“ няма да бъде заместен с „%s“"

#: src/copy.c:2105
#, c-format
msgid "cannot overwrite directory %s with non-directory"
msgstr "директорията „%s“ не може да се замести с файл, който не е директория"

#: src/copy.c:2119
#, c-format
msgid "cannot move directory onto non-directory: %s -> %s"
msgstr ""
"директория не може да се премести върху файл, който не е директория: „%s“ → "
"„%s“"

#: src/copy.c:2146
#, c-format
msgid "backing up %s might destroy source;  %s not moved"
msgstr "резервното копиране на „%s“ може да унищожи — „%s“ не бе преместен"

#: src/copy.c:2147
#, c-format
msgid "backing up %s might destroy source;  %s not copied"
msgstr "резервното копиране на „%s“ може да унищожи — „%s“ не бе копиран"

#: src/copy.c:2169 src/ln.c:305
#, c-format
msgid "cannot backup %s"
msgstr "не може да се направи резервно копие на „%s“"

#: src/copy.c:2224
#, c-format
msgid "will not copy %s through just-created symlink %s"
msgstr "„%s“ няма да се копира през току що създадената символна връзка „%s“"

#: src/copy.c:2304
#, c-format
msgid "cannot copy a directory, %s, into itself, %s"
msgstr "директорията „%s“ не може да се копира в себе си „%s“"

#: src/copy.c:2312
#, c-format
msgid "warning: source directory %s specified more than once"
msgstr "ПРЕДУПРЕЖДЕНИЕ: изходната директория „%s“ е указана повече от веднъж"

#: src/copy.c:2338
#, c-format
msgid "will not create hard link %s to directory %s"
msgstr "няма да се направи твърда връзка „%s“ към директорията „%s“"

#: src/copy.c:2362
#, c-format
msgid "renamed "
msgstr "преименуван"

#: src/copy.c:2400
#, c-format
msgid "cannot move %s to a subdirectory of itself, %s"
msgstr "„%s“ не може да се премести в поддиректорията си „%s“"

#: src/copy.c:2443
#, c-format
msgid "cannot move %s to %s"
msgstr "„%s“ не може да се премести в „%s“"

#: src/copy.c:2459
#, c-format
msgid "inter-device move failed: %s to %s; unable to remove target"
msgstr ""
"преместването между устройства не успя (от „%s“ в „%s“).  Целевият файл не "
"можа да се изтрие"

#: src/copy.c:2467
#, c-format
msgid "copied "
msgstr "копиран "

#: src/copy.c:2504
#, c-format
msgid "cannot copy cyclic symbolic link %s"
msgstr "цикличната символна връзка „%s“ не може да се копира"

#: src/copy.c:2566
#, c-format
msgid "created directory %s\n"
msgstr "създадена е директория „%s“\n"

#: src/copy.c:2629
#, c-format
msgid "%s: can make relative symbolic links only in current directory"
msgstr ""
"%s: относителни символни връзки може да се правят само в текущата директория"

#: src/copy.c:2639
#, c-format
msgid "cannot create symbolic link %s to %s"
msgstr "символната връзка „%s“ към „%s“ не може да се създаде"

#: src/copy.c:2693 src/mkfifo.c:170
#, c-format
msgid "cannot create fifo %s"
msgstr "именуваният канал „%s“ не може да се създаде"

#: src/copy.c:2702
#, c-format
msgid "cannot create special file %s"
msgstr "специалният файл „%s“ не може да се създаде"

#: src/copy.c:2713 src/ls.c:3457 src/stat.c:1092
#, c-format
msgid "cannot read symbolic link %s"
msgstr "символната връзка „%s“ не може да се чете"

#: src/copy.c:2739
#, c-format
msgid "cannot create symbolic link %s"
msgstr "символната връзка „%s“ не може да се създаде"

#: src/copy.c:2771
#, c-format
msgid "%s has unknown file type"
msgstr "„%s“ е непознат вид файл"

#: src/copy.c:2936 src/ln.c:393
#, c-format
msgid "cannot un-backup %s"
msgstr "не може да се възстанови от резервно копие „%s“"

#: src/copy.c:2940
#, c-format
msgid "%s -> %s (unbackup)\n"
msgstr "„%s“ →  „%s“ (от резервно копие)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/coreutils.c:48
msgid "Alex Deymo"
msgstr "Alex Deymo"

#: src/coreutils.c:65
#, c-format
msgid "Usage: %s --coreutils-prog=PROGRAM_NAME [PARAMETERS]... \n"
msgstr "Употреба: %s --coreutils-prog=ПРОГРАМА [ПАРАМЕТЪР]… \n"

#: src/coreutils.c:68
msgid ""
"Execute the PROGRAM_NAME built-in program with the given PARAMETERS.\n"
"\n"
msgstr ""
"Изпълнение на вградената ПРОГРАМА със зададените ПАРАМЕТри.\n"
"\n"

#: src/coreutils.c:86
#, c-format
msgid ""
"\n"
"Use: '%s --coreutils-prog=PROGRAM_NAME --help' for individual program help.\n"
msgstr ""
"\n"
"Употреба: „%s --coreutils-prog=ПРОГРАМА --help“ за помощта към ПРОГРАМАта.\n"

#: src/coreutils.c:178 src/coreutils.c:203
#, c-format
msgid "unknown program %s"
msgstr "непозната програма „%s“"

#: src/cp.c:148 src/mv.c:292
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [-T] ИЗТОЧНИК ЦЕЛ\n"
"     или: %s [ОПЦИЯ]… ИЗТОЧНИК… ДИРЕКТОРИЯ\n"
"     или: %s [ОПЦИЯ]… -t ДИРЕКТОРИЯ ИЗТОЧНИК…\n"

#: src/cp.c:154
msgid "Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n"
msgstr "Копиране на ИЗТОЧНИКа в ЦЕЛта или много ИЗТОЧНИ(ци) в ДИРЕКТОРИЯта.\n"

#: src/cp.c:160
msgid ""
"  -a, --archive                same as -dR --preserve=all\n"
"      --attributes-only        don't copy the file data, just the "
"attributes\n"
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"      --copy-contents          copy contents of special files when "
"recursive\n"
"  -d                           same as --no-dereference --preserve=links\n"
msgstr ""
"  -a, --archive                същото като „-dR --preserve=all“\n"
"      --attributes-only        без копиране на данните, а само на "
"атрибутите\n"
"      --backup[=МЕТОД]         резервно копие на съществуващите целеви "
"файлове\n"
"  -b                           като „--backup“, но не приема аргументи\n"
"      --copy-contents          копиране на съдържанието на специалните "
"файлове\n"
"                               при рекурсивна работа\n"
"  -d                           същото като „--no-dereference --"
"preserve=link“\n"

#: src/cp.c:169
msgid ""
"  -f, --force                  if an existing destination file cannot be\n"
"                                 opened, remove it and try again (this "
"option\n"
"                                 is ignored when the -n option is also "
"used)\n"
"  -i, --interactive            prompt before overwrite (overrides a previous "
"-n\n"
"                                  option)\n"
"  -H                           follow command-line symbolic links in SOURCE\n"
msgstr ""
"  -f, --force                  съществуващите целеви файлове, които не може "
"да\n"
"                               се отворят, се изтриват и се опитва наново.\n"
"                               Тази опция се прескача, ако е ползвана  „-n“\n"
"  -i, --interactive            питане преди заместване\n"
"  -H                           следване на символните връзка от ИЗТОЧНИКа "
"на\n"
"                               командния ред\n"

#: src/cp.c:178
msgid ""
"  -l, --link                   hard link files instead of copying\n"
"  -L, --dereference            always follow symbolic links in SOURCE\n"
msgstr ""
"  -l, --link                   създаване на твърди връзки вместо копиране\n"
"  -L, --dereference            символните връзки в ИЗТОЧНИКа да се "
"проследяват\n"

#: src/cp.c:182
msgid ""
"  -n, --no-clobber             do not overwrite an existing file (overrides\n"
"                                 a previous -i option)\n"
"  -P, --no-dereference         never follow symbolic links in SOURCE\n"
msgstr ""
"  -n, --no-clobber             без презаписване на съществуващ файл (отменя\n"
"                               предшестваща опция „-i“)\n"
"  -P, --no-dereference         без следване на символните връзки в "
"ИЗТОЧНИКа\n"

#: src/cp.c:187
msgid ""
"  -p                           same as --preserve=mode,ownership,timestamps\n"
"      --preserve[=ATTR_LIST]   preserve the specified attributes (default:\n"
"                                 mode,ownership,timestamps), if possible\n"
"                                 additional attributes: context, links, "
"xattr,\n"
"                                 all\n"
msgstr ""
"  -p                           като „--preserve=mode,ownership,timestamps“\n"
"      --preserve[=СПИС_АТРИБ]  запазване на посочените атрибути "
"(стандартно:\n"
"                               „mode,ownership,timestamps“), а при "
"възможност и\n"
"                               следните допълнителни атрибути: „context“,\n"
"                               „links“, „xattr“, „all“\n"

#: src/cp.c:195
msgid ""
"      --no-preserve=ATTR_LIST  don't preserve the specified attributes\n"
"      --parents                use full source file name under DIRECTORY\n"
msgstr ""
"      --no-preserve=АТРИБУТИ   без запазване на посочените АТРИБУТИ\n"
"      --parents                използване на пълното име на файла под\n"
"                               ДИРЕКТОРИЯта\n"

#: src/cp.c:199
msgid ""
"  -R, -r, --recursive          copy directories recursively\n"
"      --reflink[=WHEN]         control clone/CoW copies. See below\n"
"      --remove-destination     remove each existing destination file before\n"
"                                 attempting to open it (contrast with --"
"force)\n"
msgstr ""
"  -R, -r, --recursive          рекурсивно копиране на директориите\n"
"      --reflink[=КОГА]         управление на клонирането/копирането при "
"запис.\n"
"                               Вижте по-долу\n"
"      --remove-destination     изтриване на всеки съществуващ целеви файл, "
"преди\n"
"                               да се опитва отваряне (сравнете с „--force“)\n"

#: src/cp.c:205
msgid ""
"      --sparse=WHEN            control creation of sparse files. See below\n"
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
msgstr ""
"      --sparse=КОГА            управление на създаването на рехави файлове\n"
"      --strip-trailing-slashes изчистване на крайните „/“ от всеки ИЗТОЧНИК\n"

#: src/cp.c:210
msgid ""
"  -s, --symbolic-link          make symbolic links instead of copying\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
msgstr ""
"  -s, --symbolic-link         символни връзки вместо копиране\n"
"  -S, --suffix=СУФИКС         ползване на този СУФИКС за резервни копия\n"
"  -t, --target-directory=ДИР  в коя ДИРектория да се копира\n"
"  -T, --no-target-directory   работа с ЦЕЛта като с нормален файл\n"

#: src/cp.c:216
msgid ""
"  -u, --update                 copy only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -x, --one-file-system        stay on this file system\n"
msgstr ""
"  -u, --update                 копиране само, ако ИЗТОЧНИК е по-нов от "
"целевия\n"
"                               файл или ако целевият файл липсва\n"
"  -v, --verbose                съобщаване какво се прави\n"
"  -x, --one-file-system        оставане в текущата файлова система\n"

#: src/cp.c:223
msgid ""
"  -Z                           set SELinux security context of destination\n"
"                                 file to default type\n"
"      --context[=CTX]          like -Z, or if CTX is specified then set the\n"
"                                 SELinux or SMACK security context to CTX\n"
msgstr ""
"  -Z                           задаване на стандартен контекст за сигурност "
"на\n"
"                               SELinux на целевия файл\n"
"      --context[=КОНТЕКСТ]     като „-Z“, а ако е присъства КОНТЕКСТ, той "
"се\n"
"                               задава вместо стандартния за SELinux или "
"SMACK\n"

#: src/cp.c:231
msgid ""
"\n"
"By default, sparse SOURCE files are detected by a crude heuristic and the\n"
"corresponding DEST file is made sparse as well.  That is the behavior\n"
"selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n"
"file whenever the SOURCE file contains a long enough sequence of zero "
"bytes.\n"
"Use --sparse=never to inhibit creation of sparse files.\n"
msgstr ""
"\n"
"Стандартно с груба евристика се разпознават кои файлове-ИЗТОЧНИци са "
"рехави.\n"
"Тогава и целевите файлове също се правят такива — все едно е дадена опцията\n"
"„-sparse=auto“.  При „--sparse=always“ целевите файлове се създават рехави,\n"
"винаги когато файловете-ИЗТОЧНИци съдържат достатъчно дълга "
"последователност\n"
"от нулеви байтове.  Ползвайте „--sparse=never“, за да избегнете създаването\n"
"на рехави файлове.\n"
"\n"

#: src/cp.c:239
msgid ""
"\n"
"When --reflink[=always] is specified, perform a lightweight copy, where the\n"
"data blocks are copied only when modified.  If this is not possible the "
"copy\n"
"fails, or if --reflink=auto is specified, fall back to a standard copy.\n"
"Use --reflink=never to ensure a standard copy is performed.\n"
msgstr ""
"\n"
"Опцията „--reflink[=always]“ указва евтино копиране — блоковете се копират,\n"
"само ако са променени.  Ако това не е възможно, копирането е неуспешно.\n"
"При „--reflink=auto“ първо се опитва евтино копиране, а след това — "
"нормално.\n"
"При „--reflink=never“ винаги се извършва нормално копиране.\n"

#: src/cp.c:247
msgid ""
"\n"
"As a special case, cp makes a backup of SOURCE when the force and backup\n"
"options are given and SOURCE and DEST are the same name for an existing,\n"
"regular file.\n"
msgstr ""
"\n"
"По изключение ако са зададени опции --force и --backup, а ИЗТОЧНИК и ЦЕЛ са "
"едно\n"
"и също име на съществуващ обикновен файл, ce прави резервно копие на "
"ИЗТОЧНИК.\n"

#: src/cp.c:306
#, c-format
msgid "failed to preserve times for %s"
msgstr "времената на „%s“ не можаха да се запазят"

#: src/cp.c:337
#, c-format
msgid "failed to preserve permissions for %s"
msgstr "правата за достъп до „%s“ не можаха да се запазят"

#: src/cp.c:473
#, c-format
msgid "cannot make directory %s"
msgstr "директорията „%s“ не може да се създаде"

#: src/cp.c:522 src/cp.c:553
#, c-format
msgid "%s exists but is not a directory"
msgstr "„%s“ съществува, но не е директория"

#: src/cp.c:585 src/cp.c:1087 src/install.c:407 src/install.c:942 src/ln.c:204
#: src/ln.c:231 src/ln.c:536 src/mv.c:160 src/mv.c:393
#, c-format
msgid "failed to access %s"
msgstr "неуспешен достъп до „%s“"

#: src/cp.c:606 src/install.c:970 src/ln.c:567 src/mv.c:436 src/shred.c:1285
#: src/touch.c:430 src/truncate.c:329
#, c-format
msgid "missing file operand"
msgstr "липсващ файлов операнд"

#: src/cp.c:608 src/install.c:972 src/ln.c:590 src/mv.c:438
#, c-format
msgid "missing destination file operand after %s"
msgstr "липсващ операнд за целеви файл след „%s“"

#: src/cp.c:617 src/install.c:981 src/mv.c:447
msgid "cannot combine --target-directory (-t) and --no-target-directory (-T)"
msgstr ""
"Опциите „--target-directory“/„-t“ и „--no-target-directory“/„-T“ са "
"несъвместими"

#: src/cp.c:635 src/cp.c:1090 src/install.c:409 src/install.c:945
#: src/install.c:994 src/ln.c:539 src/mv.c:396 src/mv.c:468
#, c-format
msgid "target %s is not a directory"
msgstr "целта „%s“ не е директория"

#: src/cp.c:745
#, c-format
msgid "with --parents, the destination must be a directory"
msgstr "опцията „--parents“ изисква целта да е директория"

#: src/cp.c:1082 src/install.c:882 src/ln.c:531 src/mv.c:388
msgid "multiple target directories specified"
msgstr "посочени са много целеви директории"

#: src/cp.c:1124 src/install.c:918
#, c-format
msgid "warning: ignoring --context; it requires an SELinux-enabled kernel"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: опцията „--context“ се прескача, защото изисква ядро с "
"поддръжка на SELinux"

#: src/cp.c:1145
#, c-format
msgid "cannot make both hard and symbolic links"
msgstr "не може едновременно да се правят твърди и символни връзки"

#: src/cp.c:1155 src/mv.c:478
#, c-format
msgid "options --backup and --no-clobber are mutually exclusive"
msgstr "опциите „--backup“ и „--no-clobber“ са несъвместими"

#: src/cp.c:1161
#, c-format
msgid "--reflink can be used only with --sparse=auto"
msgstr "опцията „--reflink“ изисква опцията „--sparse=auto“"

#: src/cp.c:1166 src/install.c:950 src/ln.c:624 src/mv.c:483
msgid "backup type"
msgstr "вид на резервните копия"

#: src/cp.c:1190 src/install.c:957
msgid "cannot set target context and preserve it"
msgstr "целевият контекст не може да бъде зададен и запазен"

#: src/cp.c:1194
msgid "cannot preserve security context without an SELinux-enabled kernel"
msgstr ""
"контекстът за сигурност не може да бъде запазен, защото изисква ядро с "
"поддръжка на SELinux"

#: src/cp.c:1210
msgid "cannot preserve extended attributes, cp is built without xattr support"
msgstr ""
"разширените атрибути не могат да бъдат запазени, защото командата „cp“ е "
"компилирана без поддръжката им"

#. This is a proper name. See the gettext manual, section Names.
#: src/csplit.c:44 src/dd.c:46
msgid "Stuart Kemp"
msgstr "Stuart Kemp"

#: src/csplit.c:545
msgid "input disappeared"
msgstr "входът изчезна"

#: src/csplit.c:676 src/csplit.c:688
#, c-format
msgid "%s: line number out of range"
msgstr "%s: номерът на ред е извън диапазона"

#: src/csplit.c:718
#, c-format
msgid "%s: %s: line number out of range"
msgstr "%s: %s: номерът на ред е извън диапазона"

# Не е ясно за какво служи това.
#: src/csplit.c:721 src/csplit.c:777
#, c-format
msgid " on repetition %s\n"
msgstr " при повтаряне %s\n"

#: src/csplit.c:771
#, c-format
msgid "%s: %s: match not found"
msgstr "%s: %s: не е открито съответствие"

#: src/csplit.c:838 src/csplit.c:878 src/nl.c:361 src/tac.c:286
#, c-format
msgid "error in regular expression search"
msgstr "грешка при търсене на регулярен израз"

#: src/csplit.c:1007 src/csplit.c:1054
#, c-format
msgid "write error for %s"
msgstr "грешка при запис за %s"

#: src/csplit.c:1089
#, c-format
msgid "%s: integer expected after delimiter"
msgstr "%s: след разделител се очаква цяло число"

#: src/csplit.c:1106
#, fuzzy, c-format
msgid "%s: '}' is required in repeat count"
msgstr "%s: опцията изисква аргумент"

#: src/csplit.c:1117
#, fuzzy, c-format
msgid "%s}: integer required between '{' and '}'"
msgstr "%s}: между „{“ и „}“ е необходимо цяло число"

#: src/csplit.c:1144
#, fuzzy, c-format
msgid "%s: closing delimiter '%c' missing"
msgstr "%s: липсва затварящ ограничител „%c“"

#: src/csplit.c:1161
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s: неправилен регулярен израз: %s"

#: src/csplit.c:1193
#, c-format
msgid "%s: invalid pattern"
msgstr "%s: неправилен образец"

#: src/csplit.c:1196
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s: номерът на ред трябва да бъде положителен"

#: src/csplit.c:1201
#, c-format
msgid "line number %s is smaller than preceding line number, %s"
msgstr "номерът на ред %s е по-малък от предходния номер - %s"

#: src/csplit.c:1207
#, c-format
msgid "warning: line number %s is the same as preceding line number"
msgstr "внимание: номерът на ред %s съвпада с предходния номер на ред"

#: src/csplit.c:1285
msgid "missing conversion specifier in suffix"
msgstr "в суфикса липсва означител за преобразуване"

#: src/csplit.c:1290
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "неправилен означител за преобразуване в суфикса: %c"

#: src/csplit.c:1293
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "неправилен означител за преобразуване в суфикса: \\%.3o"

#: src/csplit.c:1298
#, fuzzy, c-format
msgid "invalid flags in conversion specification: %%%c%c"
msgstr "%s: грешно указване на файловия дескриптор"

#: src/csplit.c:1315
#, fuzzy, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "твърде много означители за преобразуване %% в суфикса"

#: src/csplit.c:1329
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "липсва означител %% за преобразуване в суфикса"

#: src/csplit.c:1375 src/dd.c:1494 src/nproc.c:105 src/tail.c:2164
msgid "invalid number"
msgstr "грешно число"

#: src/csplit.c:1482
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "Употреба: %s [ОПЦИЯ]… ФАЙЛ ОБРАЗЕЦ…\n"

#: src/csplit.c:1486
#, fuzzy
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files 'xx00', 'xx01', ...,\n"
"and output byte counts of each piece to standard output.\n"
msgstr ""
"Отделя частите на ФАЙЛ, разделени от ОБРАЗЕЦ(и) и ги записва във файлове\n"
"“xx01“, „xx02“,...  Дължината им в байтове се извежда на стандартния изход.\n"
"\n"

#: src/csplit.c:1490
#, fuzzy
msgid ""
"\n"
"Read standard input if FILE is -\n"
msgstr ""
"\n"
"Ако ФАЙЛ е -, се чете от стандартния вход.  Всеки ОБРАЗЕЦ може да бъде:\n"

#: src/csplit.c:1497
#, fuzzy, c-format
msgid ""
"  -b, --suffix-format=FORMAT  use sprintf FORMAT instead of %02d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of 'xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""
"  -b, --suffix-format=ФОРМАТ да се ползва sprintf-ФОРМАТ вместо %02d\n"
"  -f, --prefix=ПРЕФИКС       да се ползва ПРЕФИКС вместо „xx“\n"
"  -k, --keep-files           да не се изтриват създадените файлове при "
"грешка\n"

#: src/csplit.c:1502
msgid "      --suppress-matched     suppress the lines matching PATTERN\n"
msgstr ""

#: src/csplit.c:1505
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=ЦИФРИ         да се използва посоченият брой цифри вместо 2\n"
"  -s, --quiet, --silent      да не се извеждат размерите на генерираните "
"файлове\n"
"  -z, --elide-empty-files    да се изтриват генерираните празни файлове\n"

#: src/csplit.c:1512
#, fuzzy
msgid ""
"\n"
"Each PATTERN may be:\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required '+' or '-' followed by a positive integer.\n"
msgstr ""
"\n"
"  ЦЯЛО_ЧИСЛО         копира до посочения номер на ред, без да го включва\n"
"  /РЕГИЗРАЗ/[ОТМЕСТ] копира до отговарящ ред, но без да го включва\n"
"  %РЕГИЗРАЗ%[ОТМЕСТ] пропуска до отговарящ ред, но без да го включва\n"
"  {ЦЯЛО_ЧИСЛО}       повтаря предходния образец посочения брой пъти\n"
"  {*}                повтаря предходния образец колкото пъти е възможно\n"
"\n"
"ОТМЕСТ мери брой редове и е положително число, предхождано от „+“ или „-“.\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/cut.c:45 src/paste.c:52
msgid "David M. Ihnat"
msgstr "David M. Ihnat"

#: src/cut.c:147
#, c-format
msgid "Usage: %s OPTION... [FILE]...\n"
msgstr "Употреба: %s ОПЦИЯ… ФАЙЛ…\n"

#: src/cut.c:151
msgid "Print selected parts of lines from each FILE to standard output.\n"
msgstr ""
"Извеждане на избраните части от редовете на всеки ФАЙЛ на стандартния "
"изход.\n"
"\n"

#: src/cut.c:158
msgid ""
"  -b, --bytes=LIST        select only these bytes\n"
"  -c, --characters=LIST   select only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=СПИСЪК      извежда само тези байтове\n"
"  -c, --characters=СПИСЪК извежда само тези знаци\n"
"  -d, --delimiter=РАЗДЕЛ  РАЗДЕЛ вместо табулация като разделител между "
"полетата\n"

#: src/cut.c:163
msgid ""
"  -f, --fields=LIST       select only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=СПИСЪК     извеждане само на полетата от СПИСЪКа.  Отпечатват "
"се\n"
"                          и редовете, които не съдържат разделители, освен  "
"ако\n"
"                          е зададена и опцията „-s“.\n"
"  -n                      (пренебрегва се)\n"

#: src/cut.c:169
msgid ""
"      --complement        complement the set of selected bytes, characters\n"
"                            or fields\n"
msgstr ""
"      --complement        извежда всичко освен указаните байтове,\n"
"                          знаци или полета.\n"

#: src/cut.c:173
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited    без извеждане на редове биз разделители\n"
"      --output-delimiter=НИЗ\n"
"                          използване на посочения НИЗ като разделител на "
"изхода,\n"
"                          стандартно си ползва входният разделител\n"

#: src/cut.c:183
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Selected input is written\n"
"in the same order that it is read, and is written exactly once.\n"
msgstr ""
"\n"
"Опциите „-b“, „-c“ и „-f“ са взаимно несъвместими.  Всеки СПИСЪК се състои\n"
"от един или повече диапазони, разделени със „,“.  Указаната част от входа\n"
"се извежда в реда на изчитането точно веднъж.\n"

#: src/cut.c:189
msgid ""
"Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
msgstr ""
"Диапазоните могат да са:\n"
"\n"
"  N     N-тият байт, знак или поле, броейки от 1\n"
"  N-    от N-тия байт, знак или поле (включително) до края на реда\n"
"  N-M   от N-тия до M-тия байт, знак или поле (включително)\n"
"  -N    от началото на реда до N-тия байт, знак или поле (включително)\n"

#: src/cut.c:511 src/cut.c:519
msgid "only one type of list may be specified"
msgstr "трябва да се посочи само един вид списък"

#: src/cut.c:528 src/numfmt.c:1521
msgid "the delimiter must be a single character"
msgstr "разделителят трябва да се състои от един знак"

#: src/cut.c:567
msgid "you must specify a list of bytes, characters, or fields"
msgstr "трябва да посочите списък байтове, знаци или полета"

#: src/cut.c:570
msgid "an input delimiter may be specified only when operating on fields"
msgstr "входен разделител може да се посочва само ако се работи с полета"

#: src/cut.c:574
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"неизвеждането на редове, несъдържащи разделител, има смисъл\n"
"само ако се работи с полета"

#: src/date.c:130
#, c-format
msgid ""
"Usage: %s [OPTION]... [+FORMAT]\n"
"  or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [+ФОРМАТ]\n"
"     или: %s [-u|--utc|--universal] [ММДДччмм[[ГГ]ГГ][.сс]]\n"

#: src/date.c:135
msgid "Display the current time in the given FORMAT, or set the system date.\n"
msgstr ""

#: src/date.c:141
msgid ""
"  -d, --date=STRING          display time described by STRING, not 'now'\n"
msgstr ""

#: src/date.c:144
#, fuzzy
msgid ""
"      --debug                annotate the parsed date,\n"
"                              and warn about questionable usage to stderr\n"
msgstr ""
"-m, --merge                 извеждане на самия слят файл както би изглеждал "
"при\n"
"                              опцията „-A“ (ако не са зададени други опции)"

#: src/date.c:148
msgid ""
"  -f, --file=DATEFILE        like --date; once for each line of DATEFILE\n"
msgstr ""

#: src/date.c:151
msgid ""
"  -I[FMT], --iso-8601[=FMT]  output date/time in ISO 8601 format.\n"
"                               FMT='date' for date only (the default),\n"
"                               'hours', 'minutes', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14T02:34:56-06:00\n"
msgstr ""

#: src/date.c:158
msgid ""
"  -R, --rfc-email            output date and time in RFC 5322 format.\n"
"                               Example: Mon, 14 Aug 2006 02:34:56 -0600\n"
msgstr ""

#: src/date.c:162
msgid ""
"      --rfc-3339=FMT         output date/time in RFC 3339 format.\n"
"                               FMT='date', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14 02:34:56-06:00\n"
msgstr ""

#: src/date.c:168
msgid ""
"  -r, --reference=FILE       display the last modification time of FILE\n"
msgstr ""

#: src/date.c:171
msgid ""
"  -s, --set=STRING           set time described by STRING\n"
"  -u, --utc, --universal     print or set Coordinated Universal Time (UTC)\n"
msgstr ""

#: src/date.c:177
#, fuzzy
msgid ""
"\n"
"FORMAT controls the output.  Interpreted sequences are:\n"
"\n"
"  %%   a literal %\n"
"  %a   locale's abbreviated weekday name (e.g., Sun)\n"
msgstr ""
"\n"
"ФОРМАТ управлява изхода. Единствената допустима опция за втората форма е да "
"се\n"
"посочи използването на гринуичко време. Разпознавани редици във ФОРМАТ са:\n"
"\n"
"  %%   знакът %\n"
"  %a   съкратено наименование на деня от седмицата според локала (пн,вт,"
"ср,...)\n"

#: src/date.c:184
msgid ""
"  %A   locale's full weekday name (e.g., Sunday)\n"
"  %b   locale's abbreviated month name (e.g., Jan)\n"
"  %B   locale's full month name (e.g., January)\n"
"  %c   locale's date and time (e.g., Thu Mar  3 23:05:25 2005)\n"
msgstr ""
"  %A   деня от седмицата според локала, променлива дължина (напр. "
"понеделник)\n"
"  %b   съкратено име на месеца според локала (яну, фев, мар)\n"
"  %B   име на месеца според локала, променлива дължина (напр. януари)\n"
"  %c   датата и часът според локала (например сб ное  4 12:02:33 EЕТ 1989)\n"

#: src/date.c:190
#, fuzzy
msgid ""
"  %C   century; like %Y, except omit last two digits (e.g., 20)\n"
"  %d   day of month (e.g., 01)\n"
"  %D   date; same as %m/%d/%y\n"
"  %e   day of month, space padded; same as %_d\n"
msgstr ""
"  %C   векът, т.е. като %Y, но без последните две цифри (напр. 21)\n"
"  %d   денят от месеца (01, 02, ..., 31)\n"
"  %D   датата; същото като %m/%d/%y\n"
"  %e   денят от месеца с пълнеж от интервал; същото като %_d (напр. „ 1“)\n"

#: src/date.c:196
#, fuzzy
msgid ""
"  %F   full date; like %+4Y-%m-%d\n"
"  %g   last two digits of year of ISO week number (see %G)\n"
"  %G   year of ISO week number (see %V); normally useful only with %V\n"
msgstr ""
"  %F   пълната дата; същото като %Y-%m-%d\n"
"  %g   последните две цифри на годината, съдържаща седмицата с номер %V\n"
"  %G   годината, съдържаща седмицата с номер %V\n"

#: src/date.c:201
msgid ""
"  %h   same as %b\n"
"  %H   hour (00..23)\n"
"  %I   hour (01..12)\n"
"  %j   day of year (001..366)\n"
msgstr ""
"  %h   също като %b\n"
"  %H   часът (00-23)\n"
"  %I   часът (01-12)\n"
"  %j   поредният ден в годината (001-366)\n"

#: src/date.c:207
#, fuzzy
msgid ""
"  %k   hour, space padded ( 0..23); same as %_H\n"
"  %l   hour, space padded ( 1..12); same as %_I\n"
"  %m   month (01..12)\n"
"  %M   minute (00..59)\n"
msgstr ""
"  %k   часът ( 0-23)\n"
"  %l   часът ( 1-12)\n"
"  %m   месецът (01-12)\n"
"  %M   минутата (00-59)\n"

#: src/date.c:213
#, fuzzy
msgid ""
"  %n   a newline\n"
"  %N   nanoseconds (000000000..999999999)\n"
"  %p   locale's equivalent of either AM or PM; blank if not known\n"
"  %P   like %p, but lower case\n"
"  %q   quarter of year (1..4)\n"
"  %r   locale's 12-hour clock time (e.g., 11:11:04 PM)\n"
"  %R   24-hour hour and minute; same as %H:%M\n"
"  %s   seconds since 1970-01-01 00:00:00 UTC\n"
msgstr ""
"  %n   нов ред\n"
"  %N   наносекунди (000000000-999999999)\n"
"  %p   указателят AM или PM с главни букви (празен в българския локал)\n"
"  %P   като %p, но с малки букви\n"
"  %r   12 часово време според локала (напр. 11,11,04)\n"
"  %R   24 часово време, същото като %H:%M\n"
"  %s   секундите изминали от 1 януари 1970, 00:00:00 по гринуич\n"

#: src/date.c:223
msgid ""
"  %S   second (00..60)\n"
"  %t   a tab\n"
"  %T   time; same as %H:%M:%S\n"
"  %u   day of week (1..7); 1 is Monday\n"
msgstr ""
"  %S   секундите (00-60); 60 вместо 59, за да се обхване и коригираща "
"секунда\n"
"  %t   хоризонтална табулация\n"
"  %T   24 часово време, същото като %H:%M:%S\n"
"  %u   денят от седмицата (1-7);  1 означава понеделник\n"

#: src/date.c:229
msgid ""
"  %U   week number of year, with Sunday as first day of week (00..53)\n"
"  %V   ISO week number, with Monday as first day of week (01..53)\n"
"  %w   day of week (0..6); 0 is Sunday\n"
"  %W   week number of year, with Monday as first day of week (00..53)\n"
msgstr ""
"  %U   номерът на седмицата в годината, неделя е пръв седмичен ден (00-53)\n"
"  %V   номерът на седмицата в годината, понеделник е пръв седмичен ден "
"(01-53)\n"
"  %w   деня от седмицата (0-6);  0 означава неделя\n"
"  %W   номерът на седмицата в годината, понеделник е пръв седмичен ден "
"(00-53)\n"

#: src/date.c:235
msgid ""
"  %x   locale's date representation (e.g., 12/31/99)\n"
"  %X   locale's time representation (e.g., 23:13:48)\n"
"  %y   last two digits of year (00..99)\n"
"  %Y   year\n"
msgstr ""
"  %x   датата, представена според локала (напр. 31.12.99)\n"
"  %X   времето, представено според локала (напр. 23,13,48)\n"
"  %y   последните две цифри от годината (00-99)\n"
"  %Y   годината\n"

#: src/date.c:241
#, fuzzy
msgid ""
"  %z   +hhmm numeric time zone (e.g., -0400)\n"
"  %:z  +hh:mm numeric time zone (e.g., -04:00)\n"
"  %::z  +hh:mm:ss numeric time zone (e.g., -04:00:00)\n"
"  %:::z  numeric time zone with : to necessary precision (e.g., -04, "
"+05:30)\n"
"  %Z   alphabetic time zone abbreviation (e.g., EDT)\n"
"\n"
"By default, date pads numeric fields with zeroes.\n"
msgstr ""
"  %z   +hhmm часови пояс като число (напр. -0400)\n"
"  %:z  +hh:mm часовия пояс като час:минути (напр. -04:00)\n"
"  %::z +hh:mm:ss часовия пояс като час:минути:секунди (напр. -04:00:00)\n"
"  %:::z едно от горните само до необходимата точност (напр. -04, +05:30)\n"
"  %Z   съкращение за използвания часови пояс (напр. EEST за времето в "
"България)\n"
"\n"
"По подразбиране date допълва числовите полета с нули.\n"
"Следните флагове могат да следват „%“:\n"
"\n"
"  - (минус) да не се допълва с нули\n"
"  _ (знак за подчертаване) да се допълва с интервали\n"
"  0 (нула) да се допълва с нули\n"
"  ^ да се използват главни букви, където може\n"
"  # да се използват малки букви, където може\n"

#: src/date.c:250
msgid ""
"The following optional flags may follow '%':\n"
"\n"
"  -  (hyphen) do not pad the field\n"
"  _  (underscore) pad with spaces\n"
"  0  (zero) pad with zeros\n"
"  +  pad with zeros, and put '+' before future years with >4 digits\n"
"  ^  use upper case if possible\n"
"  #  use opposite case if possible\n"
msgstr ""

#: src/date.c:260
msgid ""
"\n"
"After any flags comes an optional field width, as a decimal number;\n"
"then an optional modifier, which is either\n"
"E to use the locale's alternate representations if available, or\n"
"O to use the locale's alternate numeric symbols if available.\n"
msgstr ""
"\n"
"След кой да е от флаговете може да бъде посочена ширина на полето във вид "
"на\n"
"десетично число, след което може да е зададен още един от следните "
"модификатори:\n"
"\n"
"E за да се използва алтернативното представяне според локала, или\n"
"O за да се използват алтернативните числови знаци, ако ги има.\n"

#: src/date.c:267
msgid ""
"\n"
"Examples:\n"
"Convert seconds since the epoch (1970-01-01 UTC) to a date\n"
"  $ date --date='@2147483647'\n"
"\n"
"Show the time on the west coast of the US (use tzselect(1) to find TZ)\n"
"  $ TZ='America/Los_Angeles' date\n"
"\n"
"Show the local time for 9AM next Friday on the west coast of the US\n"
"  $ date --date='TZ=\"America/Los_Angeles\" 09:00 next Fri'\n"
msgstr ""

#: src/date.c:301 src/dd.c:2408 src/head.c:881 src/md5sum.c:672
#: src/md5sum.c:1107 src/od.c:914 src/od.c:1979 src/pr.c:1148 src/pr.c:1347
#: src/pr.c:1470 src/stty.c:1368 src/tac.c:574 src/tail.c:387 src/tee.c:174
#: src/tr.c:1911 src/tsort.c:535 src/wc.c:223
msgid "standard input"
msgstr "стандартен вход"

#: src/date.c:330 src/date.c:558
#, c-format
msgid "invalid date %s"
msgstr "неправилна дата %s"

#: src/date.c:444 src/date.c:478
msgid "multiple output formats specified"
msgstr "посочени са много формати за изхода"

#: src/date.c:456
#, c-format
msgid "the options to specify dates for printing are mutually exclusive"
msgstr "посочените опции за дати за отпечатване са взаимно изключващи се"

#: src/date.c:463
#, c-format
msgid "the options to print and set the time may not be used together"
msgstr ""
"не може едновременно да се използват опции за отпечатване и настройка на "
"времето"

#: src/date.c:484
#, fuzzy, c-format
msgid ""
"the argument %s lacks a leading '+';\n"
"when using an option to specify date(s), any non-option\n"
"argument must be a format string beginning with '+'"
msgstr ""
"липсва начален знак „+“ за аргумента %s.\n"
"При използване на опция за посочване на дата/дати, всеки задължителен "
"аргумент\n"
"трябва да бъде форматен низ, започващ с „+“."

#: src/date.c:566
#, c-format
msgid "cannot set date"
msgstr "не може да се настрои датата"

#: src/date.c:600 src/du.c:388
#, c-format
msgid "time %s is out of range"
msgstr "времето %s е извън допустимия диапазон"

#. This is a proper name. See the gettext manual, section Names.
#: src/dd.c:44 src/factor.c:128 src/rm.c:40 src/tail.c:76 src/touch.c:42
#: src/wc.c:50
msgid "Paul Rubin"
msgstr "Paul Rubin"

#: src/dd.c:558
#, c-format
msgid ""
"Usage: %s [OPERAND]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба:  %s [ОПЕРАНД]…\n"
"     или:  %s ОПЦИЯ\n"

#: src/dd.c:563
msgid ""
"Copy a file, converting and formatting according to the operands.\n"
"\n"
"  bs=BYTES        read and write up to BYTES bytes at a time (default: "
"512);\n"
"                  overrides ibs and obs\n"
"  cbs=BYTES       convert BYTES bytes at a time\n"
"  conv=CONVS      convert the file as per the comma separated symbol list\n"
"  count=N         copy only N input blocks\n"
"  ibs=BYTES       read up to BYTES bytes at a time (default: 512)\n"
msgstr ""
"Копиране, преобразуване и форматиране на файл според посочените операнди.\n"
"\n"
"  bs=БАЙТОВЕ      четене и запис на парчета от по максимум толкова БАЙТОВЕ\n"
"                  (стандартно: 512)\n"
"  cbs=БАЙТОВЕ     преобразуване на парчета от по толкова БАЙТОВЕ\n"
"  conv=КЛЮЧ_ДУМИ  преобразуване на файла съгласно КЛЮЧовите_ДУМИ\n"
"  count=БРОЙ      копиране на този БРОЙ входни блока\n"
"  ibs=БАЙТОВЕ     четене на парчета от по максимум толкова БАЙТОВЕ\n"
"                  (стандартно: 512)\n"

#: src/dd.c:573
msgid ""
"  if=FILE         read from FILE instead of stdin\n"
"  iflag=FLAGS     read as per the comma separated symbol list\n"
"  obs=BYTES       write BYTES bytes at a time (default: 512)\n"
"  of=FILE         write to FILE instead of stdout\n"
"  oflag=FLAGS     write as per the comma separated symbol list\n"
"  seek=N          skip N obs-sized blocks at start of output\n"
"  skip=N          skip N ibs-sized blocks at start of input\n"
"  status=LEVEL    The LEVEL of information to print to stderr;\n"
"                  'none' suppresses everything but error messages,\n"
"                  'noxfer' suppresses the final transfer statistics,\n"
"                  'progress' shows periodic transfer statistics\n"
msgstr ""
"  if=ФАЙЛ         четене от този ФАЙЛ вместо от стандартния вход\n"
"  iflag=ФЛАГ,…    четене според посочените ФЛАГове\n"
"  obs=БАЙТОВЕ     запис на парчета от по толкова БАЙТОВЕ\n"
"  of=ФАЙЛ         запис в този ФАЙЛ, вместо на стандартния изход\n"
"  oflag=ФЛАГ,…    запис според посочените ФЛАГове\n"
"  seek=БРОЙ       пропускане на този БРОЙ изходни блока, всеки с размер obs\n"
"  skip=БРОЙ       пропускане на този БРОЙ входни блока, всеки с размер ibs\n"
"  status=НИВО     НИВОто информативност на изведената информация на "
"стандартната\n"
"                  грешка:\n"
"                    ⁃ „none“: само грешки\n"
"                    ⁃ „noxfer“: без крайната статистика\n"
"                    ⁃ „progress“: периодична статистика на трансфера\n"

#: src/dd.c:586
msgid ""
"\n"
"N and BYTES may be followed by the following multiplicative suffixes:\n"
"c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, xM=M,\n"
"GB=1000*1000*1000, G=1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"\n"
"Each CONV symbol may be:\n"
"\n"
msgstr ""
"\n"
"Стойностите приемат следните суфикси-множители:\n"
"c≡1, w≡2, b≡512, kB≡1000, K≡1024, MB≡1000*1000, M≡1024*1024, xM≡M\n"
"GB≡1000*1000*1000, G≡1024*1024*1024 и т.н. за „T“, „P“, „E“, „Z“ и „Y“.\n"
"Приемат се и двоични префикси: KiB≡K, MiB≡M и т.н.\n"
"\n"
"КЛЮЧовите_ДУМИ са някои от:\n"

#: src/dd.c:596
msgid ""
"  ascii     from EBCDIC to ASCII\n"
"  ebcdic    from ASCII to EBCDIC\n"
"  ibm       from ASCII to alternate EBCDIC\n"
"  block     pad newline-terminated records with spaces to cbs-size\n"
"  unblock   replace trailing spaces in cbs-size records with newline\n"
"  lcase     change upper case to lower case\n"
"  ucase     change lower case to upper case\n"
"  sparse    try to seek rather than write the output for NUL input blocks\n"
"  swab      swap every pair of input bytes\n"
"  sync      pad every input block with NULs to ibs-size; when used\n"
"            with block or unblock, pad with spaces rather than NULs\n"
msgstr ""
"  ascii     от EBCDIC към ASCII\n"
"  ebcdic    от ASCII към EBCDIC\n"
"  ibm       от ASCII към алтернативен EBCDIC\n"
"  block     запълване на блоковете, завършващи с нов ред, с интервали\n"
"            до размер cbs\n"
"  unblock   замяна на крайните интервали във всеки блок с размер cbs\n"
"            с нови редове\n"
"  lcase     смяна на главните букви с малки\n"
"  ucase     смяна на малките букви с главни\n"
"  sparse    опит за препозициониране вместо запазване на входни блокове\n"
"            от нулеви байтове\n"
"  swab      размяна на всяка двойка входни байтове\n"
"  sync      запълване на всеки входен блок с нулеви байтове до размера\n"
"            на входния блок.  В комбинация с „block“ или „unblock“ се\n"
"            запълва с интервали\n"

#: src/dd.c:609
msgid ""
"  excl      fail if the output file already exists\n"
"  nocreat   do not create the output file\n"
"  notrunc   do not truncate the output file\n"
"  noerror   continue after read errors\n"
"  fdatasync  physically write output file data before finishing\n"
"  fsync     likewise, but also write metadata\n"
msgstr ""
"  excl      да не действа, ако изходният файл вече съществува\n"
"  nocreat   да не се създава изходния файл\n"
"  notrunc   да не съкращава изходния файл\n"
"  noerror   продължаване дори при възникване на грешка\n"
"  fdatasync физически запис на изходните данни още преди пълното "
"приключване\n"
"  fsync     подобно, но освен това записва и метаданните\n"

#: src/dd.c:617
msgid ""
"\n"
"Each FLAG symbol may be:\n"
"\n"
"  append    append mode (makes sense only for output; conv=notrunc "
"suggested)\n"
msgstr ""
"\n"
"ФЛАГовете могат да са:\n"
"\n"
"  append    режим на добавяне (флаг само за изхода, препоръчва се заедно с\n"
"            „conv=notrunc“)\n"

#: src/dd.c:624
msgid "  cio       use concurrent I/O for data\n"
msgstr "  cio      паралелни вх./изх. операции за данните\n"

#: src/dd.c:626
msgid "  direct    use direct I/O for data\n"
msgstr "  direct    директни вх./изх. операции за данните\n"

#: src/dd.c:628
msgid "  directory  fail unless a directory\n"
msgstr "  directory  изискване на работа с директории\n"

#: src/dd.c:630
msgid "  dsync     use synchronized I/O for data\n"
msgstr "  dsync     синхронизирани вх./изх. операции за данните\n"

#: src/dd.c:632
msgid "  sync      likewise, but also for metadata\n"
msgstr ""
"  sync      синхронизирани вх./изх. операции и за данните, и за метаданните\n"

#: src/dd.c:633
msgid "  fullblock  accumulate full blocks of input (iflag only)\n"
msgstr ""
"  fullblock  натрупване на цели блокове на входа (флаг само за входа)\n"

#: src/dd.c:636
msgid "  nonblock  use non-blocking I/O\n"
msgstr "  nonblock  вх./изх. операции без блокиране\n"

#: src/dd.c:638
msgid "  noatime   do not update access time\n"
msgstr "  noatime   без промяна на времето за достъп\n"

#: src/dd.c:641
msgid "  nocache   Request to drop cache.  See also oflag=sync\n"
msgstr "  nocache   опит за пропускане на кеша.  Вижте и „oflag=sync“\n"

#: src/dd.c:645
msgid "  noctty    do not assign controlling terminal from file\n"
msgstr "  noctty    без задаване на управляващ терминал от файл\n"

#: src/dd.c:648
msgid "  nofollow  do not follow symlinks\n"
msgstr "  nofollow  без следване на символните връзки\n"

#: src/dd.c:650
msgid "  nolinks   fail if multiply-linked\n"
msgstr "  nolinks   отказ за работа при множество твърди връзки\n"

#: src/dd.c:652
msgid "  binary    use binary I/O for data\n"
msgstr "  binary    двоични вх./изх. операции за данните\n"

#: src/dd.c:654
msgid "  text      use text I/O for data\n"
msgstr "  text      текстови вх./изх. операции за данните\n"

#: src/dd.c:656
msgid "  count_bytes  treat 'count=N' as a byte count (iflag only)\n"
msgstr ""
"  count_bytes  „count=N“ се третира като брой на байтовете (флаг само за "
"входа)\n"

#: src/dd.c:659
msgid "  skip_bytes  treat 'skip=N' as a byte count (iflag only)\n"
msgstr ""
"  skip_bytes  „skip=N“ се третира като брой на байтовете (флаг само за "
"входа)\n"

#: src/dd.c:662
msgid "  seek_bytes  treat 'seek=N' as a byte count (oflag only)\n"
msgstr ""
"  seek_bytes  „seek=N“ се третира като брой на байтовете (флаг само за "
"входа)\n"

#: src/dd.c:666
#, c-format
msgid ""
"\n"
"Sending a %s signal to a running 'dd' process makes it\n"
"print I/O statistics to standard error and then resume copying.\n"
"\n"
"Options are:\n"
"\n"
msgstr ""
"\n"
"Изпращането на сигнал „%s“ към процес на „dd“ води до\n"
"извеждане на вх./изх. статистика на стандартната грешка,\n"
"след което копирането продължава.\n"
"\n"
"Възможните опции са::\n"
"\n"

#: src/dd.c:702
#, c-format
msgid "memory exhausted by input buffer of size %<PRIuMAX> bytes (%s)"
msgstr "паметта е изчерпана от входен буфер с размер %<PRIuMAX> байта (%s)"

#: src/dd.c:730
#, c-format
msgid "memory exhausted by output buffer of size %<PRIuMAX> bytes (%s)"
msgstr "паметта е изчерпана от изходен буфер с размер %<PRIuMAX> байта (%s)<"

#: src/dd.c:798 src/du.c:400
msgid "Infinity"
msgstr "Безброй"

#: src/dd.c:817
#, c-format
msgid "%<PRIuMAX> byte copied, %s, %s"
msgid_plural "%<PRIuMAX> bytes copied, %s, %s"
msgstr[0] "изкопиран е %<PRIuMAX> байт, %s, %s"
msgstr[1] "изкопирани са %<PRIuMAX> байта %s, %s"

#: src/dd.c:823
#, c-format
msgid "%<PRIuMAX> bytes (%s) copied, %s, %s"
msgstr "изкопирани са %<PRIuMAX> байта (%s), %s, %s"

#: src/dd.c:826
#, c-format
msgid "%<PRIuMAX> bytes (%s, %s) copied, %s, %s"
msgstr "изкопирани са %<PRIuMAX> байта (%s, %s), %s, %s"

#: src/dd.c:858
#, c-format
msgid ""
"%<PRIuMAX>+%<PRIuMAX> records in\n"
"%<PRIuMAX>+%<PRIuMAX> records out\n"
msgstr ""
"%<PRIuMAX>+%<PRIuMAX> прочетени блока\n"
"%<PRIuMAX>+%<PRIuMAX> записани блока\n"

#: src/dd.c:864
#, c-format
msgid "%<PRIuMAX> truncated record\n"
msgid_plural "%<PRIuMAX> truncated records\n"
msgstr[0] "%<PRIuMAX> съкратен запис\n"
msgstr[1] "%<PRIuMAX> съкратени записа\n"

#: src/dd.c:949
#, c-format
msgid "closing input file %s"
msgstr "затваряне на входния файл „%s“"

#: src/dd.c:956
#, c-format
msgid "closing output file %s"
msgstr "затваряне на изходния файл „%s“"

#: src/dd.c:1189
#, c-format
msgid "failed to turn off O_DIRECT: %s"
msgstr "неуспешно изключване на „O_DIRECT“: %s"

#: src/dd.c:1264 src/dd.c:2133
#, c-format
msgid "writing to %s"
msgstr "запис в „%s“"

#: src/dd.c:1383
#, c-format
msgid "warning: %s is a zero multiplier; use %s if that is intended"
msgstr "ПРЕДУПРЕЖДЕНИЕ: „%s“ е нулев суфикс-множител.  Изрично ползвайте „%s“"

#: src/dd.c:1421 src/dd.c:1482
#, c-format
msgid "unrecognized operand %s"
msgstr "непознат операнд: %s"

#: src/dd.c:1433
msgid "invalid conversion"
msgstr "неправилно преобразуване"

#: src/dd.c:1436 src/dd.c:1525
msgid "invalid input flag"
msgstr "неправилен флаг за входа"

#: src/dd.c:1439 src/dd.c:1519 src/dd.c:1531
msgid "invalid output flag"
msgstr "неправилен флаг за изхода"

#: src/dd.c:1442
msgid "invalid status level"
msgstr "неправилно ниво за състояние"

#: src/dd.c:1577
msgid "cannot combine any two of {ascii,ebcdic,ibm}"
msgstr "опциите „ascii“, „ebcdic“, „ibm“ са несъвместими една с друга"

#: src/dd.c:1579
msgid "cannot combine block and unblock"
msgstr "опциите „block“ и „unblock“ са несъвместими една с друга"

#: src/dd.c:1581
msgid "cannot combine lcase and ucase"
msgstr "опциите „lcase“ и „ucase“ са несъвместими една с друга"

#: src/dd.c:1583
msgid "cannot combine excl and nocreat"
msgstr "опциите „excl“ и „nocreat“ са несъвместими една с друга"

#: src/dd.c:1586
msgid "cannot combine direct and nocache"
msgstr "опциите „direct“ и „nocache“ са несъвместими една с друга"

#: src/dd.c:1743
#, c-format
msgid ""
"warning: working around lseek kernel bug for file (%s)\n"
"  of mt_type=0x%0lx -- see <sys/mtio.h> for the list of types"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: заобикаляне на проблема в ядрото с позициониране за файла "
"„%s“,\n"
"който е от вид „mt_type=0x%0lx“.  За списък с възможните видове прегледайте\n"
"„<sys/mtio.h>“"

#: src/dd.c:1831
#, c-format
msgid "%s: cannot skip"
msgstr "%s: неуспешно прескачане"

#: src/dd.c:1833 src/dd.c:1864 src/dd.c:1925
#, c-format
msgid "%s: cannot seek"
msgstr "%s: неуспешно позициониране"

#: src/dd.c:1905
#, c-format
msgid "offset overflow while reading file %s"
msgstr "препълване на отместването при четене на файла %s"

#: src/dd.c:1917
#, c-format
msgid "warning: invalid file offset after failed read"
msgstr "ПРЕДУПРЕЖДЕНИЕ: неправилно отместване във файла след неуспешно четене"

#: src/dd.c:1921
#, c-format
msgid "cannot work around kernel bug after all"
msgstr "грешката в ядрото, в крайна сметка, не може да се компенсира"

#: src/dd.c:2060
#, c-format
msgid "setting flags for %s"
msgstr "задаване на флагове за „%s“"

#: src/dd.c:2114
#, c-format
msgid "%s: cannot skip to specified offset"
msgstr "%s: неуспешно пропускане до зададеното отместване"

#: src/dd.c:2343
#, c-format
msgid "failed to truncate to %<PRIdMAX> bytes in output file %s"
msgstr "неуспешно съкращаване до %<PRIdMAX> байта в изходния файл „%s“"

#: src/dd.c:2356
#, c-format
msgid "fdatasync failed for %s"
msgstr "неуспешно извикване на „fdatasync“ за %s"

#: src/dd.c:2366
#, c-format
msgid "fsync failed for %s"
msgstr "неуспешно изпълнение на „fsync“ върху „%s“"

#: src/dd.c:2414 src/dd.c:2444 src/nohup.c:157 src/nohup.c:159
#, c-format
msgid "failed to open %s"
msgstr "„%s“ не може да се отвори"

#: src/dd.c:2454
#, c-format
msgid ""
"offset too large: cannot truncate to a length of seek=%<PRIuMAX> (%lu-byte) "
"blocks"
msgstr ""
"твърде голямо отместване: не може да се отреже до дължината на seek="
"%<PRIuMAX> (%lu-byte) блокове"

#: src/dd.c:2475
#, c-format
msgid "failed to truncate to %<PRIuMAX> bytes in output file %s"
msgstr "неуспешно съкращаване до %<PRIuMAX> байта в изходния файл %s"

#: src/dd.c:2492 src/dd.c:2498
#, c-format
msgid "failed to discard cache for: %s"
msgstr "неуспешно отхвърляне на кеша „%s“"

#. This is a proper name. See the gettext manual, section Names.
#: src/df.c:49 src/du.c:55 src/expr.c:153 src/kill.c:34 src/pathchk.c:31
#: src/shuf.c:41 src/sleep.c:35 src/sort.c:67
msgid "Paul Eggert"
msgstr "Paul Eggert"

#: src/df.c:181
msgid "Filesystem"
msgstr "Файлова с-ма"

#: src/df.c:184
msgid "Type"
msgstr "Тип"

#: src/df.c:187 src/df.c:601
msgid "blocks"
msgstr "блокове"

#: src/df.c:190
msgid "Used"
msgstr "Заети"

#: src/df.c:193
msgid "Available"
msgstr "Свободни"

#: src/df.c:196
msgid "Use%"
msgstr "Изп%"

#: src/df.c:199
msgid "Inodes"
msgstr "I-възли"

#: src/df.c:202
msgid "IUsed"
msgstr "Заети"

#: src/df.c:205
msgid "IFree"
msgstr "Свобод"

#: src/df.c:208
msgid "IUse%"
msgstr "Изп%"

#: src/df.c:211
msgid "Mounted on"
msgstr "Монтирана на"

#: src/df.c:214
msgid "File"
msgstr ""

#: src/df.c:441
#, fuzzy, c-format
msgid "option --output: field %s unknown"
msgstr "затваряне на изходния файл %s"

#: src/df.c:448
#, fuzzy, c-format
msgid "option --output: field %s used more than once"
msgstr "внимание: изходния файл %s е посочен повече от веднъж"

#: src/df.c:469 src/df.c:508
msgid "Size"
msgstr "Размер"

#: src/df.c:473 src/df.c:510
msgid "Avail"
msgstr "Свобод"

#: src/df.c:533
msgid "Capacity"
msgstr "Обем"

#. TRANSLATORS: this is the "1K-blocks" header in "df" output.
#. TRANSLATORS: this is the "1024-blocks" header in "df -P".
#: src/df.c:604 src/df.c:613
#, c-format
msgid "%s-%s"
msgstr ""

#: src/df.c:1342
#, c-format
msgid "cannot access %s: over-mounted by another device"
msgstr ""

#: src/df.c:1511
#, fuzzy
msgid ""
"Show information about the file system on which each FILE resides,\n"
"or all file systems by default.\n"
msgstr ""
"Дава информация за файловата система, съдържаща всеки от ФАЙЛ-овете\n"
"или за всички файлови системи по подразбиране.\n"
"\n"

#. TRANSLATORS: The thousands and decimal separators are best
#. adjusted to an appropriate default for your locale.
#: src/df.c:1520
msgid ""
"  -a, --all             include pseudo, duplicate, inaccessible file "
"systems\n"
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -h, --human-readable  print sizes in powers of 1024 (e.g., 1023M)\n"
"  -H, --si              print sizes in powers of 1000 (e.g., 1.1G)\n"
msgstr ""

#: src/df.c:1528
msgid ""
"  -i, --inodes          list inode information instead of block usage\n"
"  -k                    like --block-size=1K\n"
"  -l, --local           limit listing to local file systems\n"
"      --no-sync         do not invoke sync before getting usage info "
"(default)\n"
msgstr ""
"  -i, --inodes          извежда информация за използваните i-възли, а не "
"блокове\n"
"  -k                    като --block-size=1K\n"
"  -l, --local           извежда информация само за локалните файлови "
"системи\n"
"      --no-sync         без sync преди получаване на използването (по "
"подразб.)\n"

#: src/df.c:1535
msgid ""
"      --output[=FIELD_LIST]  use the output format defined by FIELD_LIST,\n"
"                               or print all fields if FIELD_LIST is "
"omitted.\n"
"  -P, --portability     use the POSIX output format\n"
"      --sync            invoke sync before getting usage info\n"
msgstr ""

#: src/df.c:1541
msgid ""
"      --total           elide all entries insignificant to available space,\n"
"                          and produce a grand total\n"
msgstr ""

#: src/df.c:1545
#, fuzzy
msgid ""
"  -t, --type=TYPE       limit listing to file systems of type TYPE\n"
"  -T, --print-type      print file system type\n"
"  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\n"
"  -v                    (ignored)\n"
msgstr ""
"  -P, --portability     да се използва изходен формат POSIX\n"
"      --sync            изпълнява sync преди получаване на информация\n"
"  -t, --type=ТИП        извежда информация само за файлови системи от тип "
"ТИП\n"
"  -T, --print-type      извежда типа на файловата система\n"
"  -x, --exclude-type=ТИП  не извежда информация за файлови системи от тип "
"ТИП\n"
"  -v                    (пренебрегва се)\n"

#: src/df.c:1555
msgid ""
"\n"
"FIELD_LIST is a comma-separated list of columns to be included.  Valid\n"
"field names are: 'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent',\n"
"'size', 'used', 'avail', 'pcent', 'file' and 'target' (see info page).\n"
msgstr ""

#: src/df.c:1592
#, fuzzy, c-format
msgid "options %s and %s are mutually exclusive"
msgstr "опциите „-l“ и „-s“ са несъвместими"

#: src/df.c:1742
#, c-format
msgid "file system type %s both selected and excluded"
msgstr "файловите системи от тип %s са едновременно избрани и изключени"

#: src/df.c:1801
msgid "Warning: "
msgstr "Внимание: "

#: src/df.c:1803 src/stat.c:906
#, fuzzy
msgid "cannot read table of mounted file systems"
msgstr "Списъкът с монтирани файлови системи не може да бъде прочетен"

#: src/df.c:1840
msgid "no file systems processed"
msgstr "нито една файлова система не бе обработена"

#. This is a proper name. See the gettext manual, section Names.
#: src/dircolors.c:37
msgid "H. Peter Anvin"
msgstr "H. Peter Anvin"

#: src/dircolors.c:100
msgid ""
"Output commands to set the LS_COLORS environment variable.\n"
"\n"
"Determine format of output:\n"
"  -b, --sh, --bourne-shell    output Bourne shell code to set LS_COLORS\n"
"  -c, --csh, --c-shell        output C shell code to set LS_COLORS\n"
"  -p, --print-database        output defaults\n"
msgstr ""
"Извеждане на команди за присвояване стойност на променливата LS_COLORS.\n"
"\n"
"Опции за форма̀та на изхода:\n"
"  -b, --sh, --bourne-shell    код за обвивка на Бурн\n"
"  -c, --csh, --c-shell        код за обвивка C\n"
"  -p, --print-database        стойности по подразбиране\n"

#: src/dircolors.c:110
msgid ""
"\n"
"If FILE is specified, read it to determine which colors to use for which\n"
"file types and extensions.  Otherwise, a precompiled database is used.\n"
"For details on the format of these files, run 'dircolors --print-database'.\n"
msgstr ""
"\n"
"Ако е указан ФАЙЛ, той определя цветовете за различните файлове разширения.\n"
"В противен случай се използва вградена база от данни.\n"
"За подробности относно форма̀та на ФАЙЛа, изпълнете „dircolors --print-"
"database“.\n"

#: src/dircolors.c:288
#, c-format
msgid "%s:%lu: invalid line;  missing second token"
msgstr "%s:%lu: неправилен ред — липсва втора лексема"

#: src/dircolors.c:360
#, c-format
msgid "%s:%lu: unrecognized keyword %s"
msgstr "%s:%lu: непозната ключова дума %s"

#: src/dircolors.c:361
msgid "<internal>"
msgstr "<интервал>"

#: src/dircolors.c:442
#, c-format
msgid ""
"the options to output dircolors' internal database and\n"
"to select a shell syntax are mutually exclusive"
msgstr ""
"опциите за извеждане на вътрешната база от данни на\n"
"„dircolors“ и за избор на обвивка са несъвместими"

#: src/dircolors.c:452
msgid "file operands cannot be combined with --print-database (-p)"
msgstr "файлови операнди са несъвместими с „--print-database“ („-p“)."

#: src/dircolors.c:475
msgid "no SHELL environment variable, and no shell type option given"
msgstr "променливата „SHELL“ е без стойност, а и липсва опция за обвивката"

#: src/dirname.c:50
#, c-format
msgid "Usage: %s [OPTION] NAME...\n"
msgstr "Употреба: %s [ОПЦИЯ] ИМЕ…\n"

#: src/dirname.c:54
msgid ""
"Output each NAME with its last non-slash component and trailing slashes\n"
"removed; if NAME contains no /'s, output '.' (meaning the current "
"directory).\n"
"\n"
msgstr ""
"Извеждане на всяко ИМЕ без последната му част, която не е „/“,\n"
"както и без последните знаци „/“.  Ако ИМЕто не съдържа /, се\n"
"извежда „.“, което означава текущата директория.\n"
"\n"

#: src/dirname.c:59
msgid "  -z, --zero     end each output line with NUL, not newline\n"
msgstr ""
"  -z, --zero     завършване на редовете с нулев байт, а не със знак за нов "
"ред\n"

#: src/dirname.c:64
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/          -> \"/usr\"\n"
"  %s dir1/str dir2/str  -> \"dir1\" followed by \"dir2\"\n"
"  %s stdio.h            -> \".\"\n"
msgstr ""
"\n"
"Примери:\n"
"  %s /usr/bin/          → „/usr“\n"
"  %s dir1/str dir2/str  → „dir1“, следвано от „dir2“\n"
"  %s stdio.h            → „.“\n"

#: src/du.c:284 src/sort.c:419 src/wc.c:118
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [OPTION]... --files0-from=F\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [ФАЙЛ]…\n"
"     или: %s [ОПЦИЯ]… --files0-from==ФАЙЛ\n"

#: src/du.c:288
#, fuzzy
msgid ""
"Summarize disk usage of the set of FILEs, recursively for directories.\n"
msgstr ""
"Резюмира използването на диска от всеки ФАЙЛ, рекурсивно за каталозите.\n"
"\n"

#: src/du.c:294
#, fuzzy
msgid ""
"  -0, --null            end each output line with NUL, not newline\n"
"  -a, --all             write counts for all files, not just directories\n"
"      --apparent-size   print apparent sizes, rather than disk usage; "
"although\n"
"                          the apparent size is usually smaller, it may be\n"
"                          larger due to holes in ('sparse') files, internal\n"
"                          fragmentation, indirect blocks, and the like\n"
msgstr ""
"  -a, --all             извежда сума за всички файлове, не само за "
"каталозите\n"
"      --apparent-size   извежда действителни размери, а не използваното "
"дисково\n"
"                          пространство. Обикновено действителният размер е\n"
"                          по-малък, но може да бъде и по-голям в следствие "
"на\n"
"                          дупки в „разредени“ (sparse) файлове, вътрешна\n"
"                          фрагментация, недиректни блокове и други подобни.\n"
"  -B, --block-size=РАЗМ да се ползват блокове с размер РАЗМ байта\n"
"  -b, --bytes           отпечатва размера в байтове\n"
"  -c, --total           пресмята и обща сума на използването\n"
"  -D, --dereference-args  работи върху файловете, сочени от ФАЙЛ-символна "
"връзка\n"

#: src/du.c:303
#, fuzzy
msgid ""
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -b, --bytes           equivalent to '--apparent-size --block-size=1'\n"
"  -c, --total           produce a grand total\n"
"  -D, --dereference-args  dereference only symlinks that are listed on the\n"
"                          command line\n"
"  -d, --max-depth=N     print the total for a directory (or file, with --"
"all)\n"
"                          only if it is N or fewer levels below the command\n"
"                          line argument;  --max-depth=0 is the same as\n"
"                          --summarize\n"
msgstr ""
"  -x, --one-file-system  пропуска каталозите, които са в друга файлова "
"система\n"
"  -X ФАЙЛ, --exclude-from=ФАЙЛ  изключва файлове, пасващи на образец от "
"ФАЙЛ\n"
"      --exclude=ОБРАЗЕЦ изключва файлове, чието име пасва на ОБРАЗЕЦ\n"
"      --max-depth=N     отпечатва общ размер на каталози (или файлове с --"
"all)\n"
"                          само ако те са с N или по-малко нива под "
"аргумента\n"
"                          на командния ред;  --max-depth=0 е еквивалентно "
"на\n"
"                          --summarize\n"

#: src/du.c:316
#, fuzzy
msgid ""
"      --files0-from=F   summarize disk usage of the\n"
"                          NUL-terminated file names specified in file F;\n"
"                          if F is -, then read names from standard input\n"
"  -H                    equivalent to --dereference-args (-D)\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"      --inodes          list inode usage information instead of block usage\n"
msgstr ""
"      --files0-from=Ф   резюмира използваното дисково пространство от "
"файловите\n"
"                          имена със завършител NUL, посочени във файла Ф\n"
"  -H                    като --si, но генерира предупреждение; скоро ще "
"бъде\n"
"                        променено да бъде същото като --dereference-args (-"
"D)\n"
"  -h, --human-readable  отпечатва размерите като за хора (напр. 1K, 234M, "
"2G)\n"
"      --si              подобно, но с множители 1000 вместо 1024\n"
"  -k                    също като --block-size=1K\n"
"  -l, --count-links     брои размерите многократно при твърди връзки\n"
"  -m                    също като --block-size=1M\n"

#: src/du.c:325
msgid ""
"  -k                    like --block-size=1K\n"
"  -L, --dereference     dereference all symbolic links\n"
"  -l, --count-links     count sizes many times if hard linked\n"
"  -m                    like --block-size=1M\n"
msgstr ""

#: src/du.c:331
#, fuzzy
msgid ""
"  -P, --no-dereference  don't follow any symbolic links (this is the "
"default)\n"
"  -S, --separate-dirs   for directories do not include size of "
"subdirectories\n"
"      --si              like -h, but use powers of 1000 not 1024\n"
"  -s, --summarize       display only a total for each argument\n"
msgstr ""
"  -L, --dereference     работи върху файловете, сочени от символни връзки\n"
"  -P, --no-dereference  да не се следват символни връзки (по подразбиране)\n"
"  -0, --null            завършва всеки изведен ред с байт 0 вместо с нов "
"ред\n"
"  -S, --separate-dirs   да не се включва размерът на поддиректориите\n"
"  -s, --summarize       резюмира -- извежда само общата сума за всеки "
"аргумент\n"

#: src/du.c:337
#, fuzzy
msgid ""
"  -t, --threshold=SIZE  exclude entries smaller than SIZE if positive,\n"
"                          or entries greater than SIZE if negative\n"
"      --time            show time of the last modification of any file in "
"the\n"
"                          directory, or any of its subdirectories\n"
"      --time=WORD       show time as WORD instead of modification time:\n"
"                          atime, access, use, ctime or status\n"
"      --time-style=STYLE  show times using STYLE, which can be:\n"
"                            full-iso, long-iso, iso, or +FORMAT;\n"
"                            FORMAT is interpreted like in 'date'\n"
msgstr ""
"      --time            показва времето на последна промяна на всеки файл "
"от\n"
"                          директорията или всяка от поддиректориите ѝ\n"
"      --time=ДУМА       показва времето от ДУМА вместо последната промяна.\n"
"                          ДУМА може да бъде atime, access, use, ctime или "
"status\n"
"      --time-style=СТИЛ показва времената използвайки стил СТИЛ, т.е.\n"
"                          full-iso, long-iso, iso или +ФОРМАТ\n"
"                          ФОРМАТ се интерпретира както от „date“\n"

#: src/du.c:348
msgid ""
"  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
"      --exclude=PATTERN    exclude files that match PATTERN\n"
"  -x, --one-file-system    skip directories on different file systems\n"
msgstr ""

#: src/du.c:695
#, fuzzy, c-format
msgid "fts_read failed: %s"
msgstr "неуспешно прочитане"

#: src/du.c:819
#, c-format
msgid "invalid maximum depth %s"
msgstr "неправилна максимална дълбочина %s"

#: src/du.c:848
#, fuzzy
msgid "invalid --threshold argument '-0'"
msgstr "неправилен аргумент „%3$s“ за опцията „%1$s%2$s“"

#: src/du.c:931
#, c-format
msgid "cannot both summarize and show all entries"
msgstr "не може едновременно да се резюмира и да се показват всички елементи"

#: src/du.c:938
#, c-format
msgid "warning: summarizing is the same as using --max-depth=0"
msgstr "внимание: резюмирането е еквивалентно на --max-depth=0"

#: src/du.c:944
#, c-format
msgid "warning: summarizing conflicts with --max-depth=%lu"
msgstr "внимание: резюмирането влиза в конфликт с --max-depth=%lu"

#: src/du.c:955
#, c-format
msgid "warning: options --apparent-size and -b are ineffective with --inodes"
msgstr ""

#: src/du.c:1020 src/sort.c:4602 src/wc.c:760
msgid "file operands cannot be combined with --files0-from"
msgstr "файловите операнди са несъвместими с „--files0-from“"

#: src/du.c:1087 src/sort.c:4623 src/wc.c:838
#, c-format
msgid "when reading file names from stdin, no file name of %s allowed"
msgstr ""
"при четене на файлови имена от стандартния вход, никое файлово име не може "
"да бъде „%s“"

#: src/du.c:1104 src/du.c:1112 src/wc.c:851 src/wc.c:859
msgid "invalid zero-length file name"
msgstr "неправилно файлово име с дължина нула"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:27
msgid "Brian Fox"
msgstr "Brian Fox"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:28
msgid "Chet Ramey"
msgstr "Chet Ramey"

#: src/echo.c:42
#, c-format
msgid ""
"Usage: %s [SHORT-OPTION]... [STRING]...\n"
"  or:  %s LONG-OPTION\n"
msgstr ""
"Употреба: %s [КЪСА_ОПЦИЯ]… [НИЗ]…\n"
"     или: %s ДЪЛГА_ОПЦИЯ\n"

#: src/echo.c:46
msgid ""
"Echo the STRING(s) to standard output.\n"
"\n"
"  -n             do not output the trailing newline\n"
msgstr ""
"Извежда НИЗовете на стандартния изход.\n"
"\n"
"  -n             не извежда знаци за нов ред след всеки от НИЗовете\n"

#: src/echo.c:52
msgid ""
"  -e             enable interpretation of backslash escapes (default)\n"
"  -E             disable interpretation of backslash escapes\n"
msgstr ""
"  -e             позволява обработката знаци, защитени с \\ (по "
"подразбиране)\n"
"  -E             забранява специалната обработка на \\\n"

#: src/echo.c:55
msgid ""
"  -e             enable interpretation of backslash escapes\n"
"  -E             disable interpretation of backslash escapes (default)\n"
msgstr ""
"  -e             позволява обработката знаци, защитени с \\\n"
"  -E             забранява специалната обработка на \\ (по подразбиране)\n"

#: src/echo.c:61
msgid ""
"\n"
"If -e is in effect, the following sequences are recognized:\n"
"\n"
msgstr ""
"\n"
"Ако опцията „-e“ е включена, се разпознават следните последователности:\n"
"\n"

#: src/echo.c:66 src/printf.c:110
msgid ""
"  \\\\      backslash\n"
"  \\a      alert (BEL)\n"
"  \\b      backspace\n"
"  \\c      produce no further output\n"
"  \\e      escape\n"
"  \\f      form feed\n"
"  \\n      new line\n"
"  \\r      carriage return\n"
"  \\t      horizontal tab\n"
"  \\v      vertical tab\n"
msgstr ""
"  \\\\      обратно наклонена черта\n"
"  \\a      звънец\n"
"  \\b      обратно изтриване\n"
"  \\c      без повече изход\n"
"  \\e      екраниране\n"
"  \\f      нова страница\n"
"  \\n      нов ред\n"
"  \\r      връщане на каретката\n"
"  \\t      хоризонтална табулация\n"
"  \\v      вертикална табулация\n"

#: src/echo.c:78
msgid ""
"  \\0NNN   byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
msgstr ""
"  \\0NNN   байт с осмичен код NNN (от 1 до 3 цифри)\n"
"  \\xHH    байт с шестнадесетичен код HH (от 1 до 2 цифри)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/env.c:38 src/printenv.c:45 src/whoami.c:35
msgid "Richard Mlynarik"
msgstr "Richard Mlynarik"

#: src/env.c:112
#, c-format
msgid "Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [-] [ПРОМЕНЛИВА=СТОЙНОСТ]… [КОМАНДА [АРГУМЕНТ]…]\n"

#: src/env.c:115
msgid "Set each NAME to VALUE in the environment and run COMMAND.\n"
msgstr ""

#: src/env.c:121
#, fuzzy
msgid ""
"  -i, --ignore-environment  start with an empty environment\n"
"  -0, --null           end each output line with NUL, not newline\n"
"  -u, --unset=NAME     remove variable from the environment\n"
msgstr ""
"Присвоява СТОЙНОСТ на всяка ПРОМЕНЛИВА и изпълнява КОМАНДА в новото "
"обкръжение.\n"
"\n"
"  -i, --ignore-environment   започва с празно обкръжение\n"
"  -u, --unset=ПРОМЕНЛИВА     отстранява променливата от обкръжението\n"

#: src/env.c:126
msgid "  -C, --chdir=DIR      change working directory to DIR\n"
msgstr ""

#: src/env.c:129
msgid ""
"  -S, --split-string=S  process and split S into separate arguments;\n"
"                        used to pass multiple arguments on shebang lines\n"
msgstr ""

#: src/env.c:133
msgid ""
"      --block-signal[=SIG]    block delivery of SIG signal(s) to COMMAND\n"
msgstr ""

#: src/env.c:136
msgid ""
"      --default-signal[=SIG]  reset handling of SIG signal(s) to the "
"default\n"
msgstr ""

#: src/env.c:139
msgid ""
"      --ignore-signal[=SIG]   set handling of SIG signals(s) to do nothing\n"
msgstr ""

#: src/env.c:142
msgid ""
"      --list-signal-handling  list non default signal handling to stderr\n"
msgstr ""

#: src/env.c:145
#, fuzzy
msgid ""
"  -v, --debug          print verbose information for each processing step\n"
msgstr "  -l, --login       извеждане на процесите за влизане в системата\n"

#: src/env.c:150
msgid ""
"\n"
"A mere - implies -i.  If no COMMAND, print the resulting environment.\n"
msgstr ""
"\n"
"Просто - означава -i. Ако не е дадена КОМАНДА, отпечатва полученото "
"обкръжение.\n"

#: src/env.c:154
#, fuzzy
msgid ""
"\n"
"SIG may be a signal name like 'PIPE', or a signal number like '13'.\n"
"Without SIG, all known signals are included.  Multiple signals can be\n"
"comma-separated.\n"
msgstr ""
"\n"
"СИГНАЛът може да бъде име на сигнал (напр. „HUP“), номер (напр. „1“)\n"
"или код-състояние на изход на процес, прекратен чрез сигнал.\n"
"ИДентификаторът_на_ПРоцес е цяло число, ако е отрицателно — указва\n"
"група от процеси.\n"

#: src/env.c:181
#, fuzzy, c-format
msgid "cannot unset %s"
msgstr "%s: не може да се премахне"

#: src/env.c:315
msgid "'\\c' must not appear in double-quoted -S string"
msgstr ""

#: src/env.c:319
#, fuzzy
msgid "invalid backslash at end of string in -S"
msgstr "внимание: обратна наклонена черта в края на форматен низ"

#: src/env.c:322
#, fuzzy, c-format
msgid "invalid sequence '\\%c' in -S"
msgstr "неправилен указател „\\%d“ в дясната страна на командата „s“"

#: src/env.c:336
#, c-format
msgid "only ${VARNAME} expansion is supported, error at: %s"
msgstr ""

#: src/env.c:347
msgid "no terminating quote in -S string"
msgstr ""

#: src/env.c:613 src/env.c:702 src/operand2sig.c:88
#, c-format
msgid "%s: invalid signal"
msgstr "%s: неправилен сигнал"

#: src/env.c:645
#, fuzzy, c-format
msgid "failed to get signal action for signal %d"
msgstr "групите на потребителя „%s“ не могат да се получат"

#: src/env.c:653
#, fuzzy, c-format
msgid "failed to set signal action for signal %d"
msgstr ""
"%s: ПРЕДУПРЕЖДЕНИЕ: на „%s“ не може да се зададе стандартният контекст при "
"създаване на файлове: %s"

#: src/env.c:725 src/env.c:765
#, fuzzy
msgid "failed to get signal process mask"
msgstr "променливата на средата „%s“ не може да се зададе"

#: src/env.c:754
#, fuzzy
msgid "failed to set signal process mask"
msgstr "променливата на средата „%s“ не може да се зададе"

#: src/env.c:857
#, fuzzy, c-format
msgid "invalid option -- '%c'"
msgstr "%s: неправилна опция — „%c“\n"

#: src/env.c:858 src/env.c:949
#, c-format
msgid "use -[v]S to pass options in shebang lines"
msgstr ""

#: src/env.c:891
#, fuzzy, c-format
msgid "cannot set %s"
msgstr "в „%s“ не може да се търси"

#: src/env.c:901
#, c-format
msgid "cannot specify --null (-0) with command"
msgstr ""

#: src/env.c:907
#, c-format
msgid "must specify command with --chdir (-C)"
msgstr ""

#: src/env.c:932
#, fuzzy, c-format
msgid "cannot change directory to %s"
msgstr "Неуспешна смяна на текущата директория: %s"

#: src/expand-common.c:90
msgid "tabs are too far apart"
msgstr "табулациите са твърде отдалечени"

#: src/expand-common.c:103
#, c-format
msgid "'/' specifier only allowed with the last value"
msgstr ""

#: src/expand-common.c:120
#, c-format
msgid "'+' specifier only allowed with the last value"
msgstr ""

#: src/expand-common.c:172
#, c-format
msgid "'/' specifier not at start of number: %s"
msgstr ""

#: src/expand-common.c:183
#, c-format
msgid "'+' specifier not at start of number: %s"
msgstr ""

#: src/expand-common.c:204
#, c-format
msgid "tab stop is too large %s"
msgstr "табулацията е твърде дълга %s"

#: src/expand-common.c:212
#, c-format
msgid "tab size contains invalid character(s): %s"
msgstr "размерът на табулациите включва непозволен знак: %s"

#: src/expand-common.c:244
msgid "tab size cannot be 0"
msgstr "размерът на табулациите не може да бъде 0"

#: src/expand-common.c:246
msgid "tab sizes must be ascending"
msgstr "позициите на табулациите трябва да са в нарастващ ред"

#: src/expand-common.c:251
msgid "'/' specifier is mutually exclusive with '+'"
msgstr ""

#: src/expand-common.c:390
#, fuzzy
msgid "  -t, --tabs=LIST  use comma separated list of tab positions\n"
msgstr ""
"  -t, --tabs=СПИС     да се ползва списък от явно зададени табулационни "
"позиции\n"

#: src/expand-common.c:393
msgid ""
"                     The last specified position can be prefixed with '/'\n"
"                     to specify a tab size to use after the last\n"
"                     explicitly specified tab stop.  Also a prefix of '+'\n"
"                     can be used to align remaining tab stops relative to\n"
"                     the last specified tab stop instead of the first "
"column\n"
msgstr ""

#: src/expand.c:73
msgid "Convert tabs in each FILE to spaces, writing to standard output.\n"
msgstr ""
"Замяна на табулациите във всеки ФАЙЛ с интервали и извеждане на стандартния "
"изход\n"

#: src/expand.c:80
msgid ""
"  -i, --initial    do not convert tabs after non blanks\n"
"  -t, --tabs=N     have tabs N characters apart, not 8\n"
msgstr ""
"  -i, --initial       без замяна на табулациите след знак, който не е "
"интервал\n"
"  -t, --tabs=БРОЙ     табулациите да са равни на този БРОЙ интервали вместо "
"8\n"

#: src/expand.c:146 src/expand.c:165 src/unexpand.c:181 src/unexpand.c:226
msgid "input line is too long"
msgstr "входният ред е твърде дълъг"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:151 src/ln.c:51 src/mv.c:42 src/tee.c:36
msgid "Mike Parker"
msgstr "Mike Parker"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:152 src/groups.c:37
msgid "James Youngman"
msgstr "James Youngman"

#: src/expr.c:345
#, c-format
msgid ""
"Usage: %s EXPRESSION\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s ИЗРАЗ\n"
"     или: %s ОПЦИЯ\n"

#: src/expr.c:353
msgid ""
"\n"
"Print the value of EXPRESSION to standard output.  A blank line below\n"
"separates increasing precedence groups.  EXPRESSION may be:\n"
"\n"
"  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n"
"\n"
"  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\n"
msgstr ""
"\n"
"Отпечатва стойността на ИЗРАЗ на стандартния изход. По-долу празни редове\n"
"отделят групите операции с нарастващ приоритет. ИЗРАЗ може да бъде:\n"
"\n"
"  ARG1 | ARG2       ARG1, ако той не е нито празен, нито 0, а иначе ARG2\n"
"\n"
"  ARG1 & ARG2       ARG1, ако никой от аргументите не е празен или 0, иначе "
"0\n"

#: src/expr.c:362
msgid ""
"\n"
"  ARG1 < ARG2       ARG1 is less than ARG2\n"
"  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\n"
"  ARG1 = ARG2       ARG1 is equal to ARG2\n"
"  ARG1 != ARG2      ARG1 is unequal to ARG2\n"
"  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\n"
"  ARG1 > ARG2       ARG1 is greater than ARG2\n"
msgstr ""
"\n"
"  ARG1 < ARG2       ARG1 е по-малък от ARG2\n"
"  ARG1 <= ARG2      ARG1 е по-малък или равен на ARG2\n"
"  ARG1 = ARG2       ARG1 е равен на ARG2\n"
"  ARG1 != ARG2      ARG1 е различен от ARG2\n"
"  ARG1 >= ARG2      ARG1 е по-голям или равен на ARG2\n"
"  ARG1 > ARG2       ARG1 е по-голям от ARG2\n"

#: src/expr.c:371
msgid ""
"\n"
"  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\n"
"  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\n"
msgstr ""
"\n"
"  ARG1 + ARG2       аритметична сума на ARG1 и ARG2\n"
"  ARG1 - ARG2       аритметична разлика на ARG1 и ARG2\n"

#: src/expr.c:378
#, no-c-format
msgid ""
"\n"
"  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\n"
"  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\n"
"  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\n"
msgstr ""
"\n"
"  ARG1 * ARG2       аритметично произведение на ARG1 и ARG2\n"
"  ARG1 / ARG2       аритметично частно на ARG1 разделен на ARG2\n"
"  ARG1 % ARG2       аритметичен остатък на ARG1 разделен на ARG2\n"

#: src/expr.c:384
msgid ""
"\n"
"  STRING : REGEXP   anchored pattern match of REGEXP in STRING\n"
"\n"
"  match STRING REGEXP        same as STRING : REGEXP\n"
"  substr STRING POS LENGTH   substring of STRING, POS counted from 1\n"
"  index STRING CHARS         index in STRING where any CHARS is found, or 0\n"
"  length STRING              length of STRING\n"
msgstr ""
"\n"
"  НИЗ : РЕГИЗР      стриктно (anchored) съпоставяне на образеца РЕГИЗР в "
"НИЗ\n"
"\n"
"  match НИЗ РЕГИЗР           същото като НИЗ : РЕГИЗР\n"
"  substr НИЗ ПОЗИЦ ДЪЛЖ      подниз на НИЗ, ПОЗИЦ се брои от 1\n"
"  index НИЗ ЗНАЦИ            място в НИЗ, където се намира някой от ЗНАЦИ, "
"или 0\n"
"  length НИЗ                 дължината на НИЗ\n"

#: src/expr.c:393
#, fuzzy
msgid ""
"  + TOKEN                    interpret TOKEN as a string, even if it is a\n"
"                               keyword like 'match' or an operator like '/'\n"
"\n"
"  ( EXPRESSION )             value of EXPRESSION\n"
msgstr ""
"  + ЛЕКСЕМА                  разглежда ЛЕКСЕМА като низ дори и ако е\n"
"                               ключова дума като „match“ или оператор като "
"„/“\n"
"\n"
"  ( ИЗРАЗ )                  стойността на ИЗРАЗ\n"

#: src/expr.c:399
msgid ""
"\n"
"Beware that many operators need to be escaped or quoted for shells.\n"
"Comparisons are arithmetic if both ARGs are numbers, else lexicographical.\n"
"Pattern matches return the string matched between \\( and \\) or null; if\n"
"\\( and \\) are not used, they return the number of characters matched or "
"0.\n"
msgstr ""
"\n"
"В командните обвивки трябва да защитавате много от операторите с кавички или "
"\\.\n"
"Сравненията са аритметични, ако и двата ARG са числа, а иначе "
"лексикографски.\n"
"Съпоставянията с образец връщат низа, паснал между първите \\( и \\) или "
"празен,\n"
"а ако не са използвани \\( и \\) връща броя паснали знаци или 0.\n"

#: src/expr.c:406
msgid ""
"\n"
"Exit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRESSION is "
"null\n"
"or 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error occurred.\n"
msgstr ""
"\n"
"Кодът на завършване е 0, ако ИЗРАЗ не е нито празен, нито 0; 1, ако ИЗРАЗ е\n"
"празен или 0; 2, ако ИЗРАЗ е синтактично неправилен и 3, ако е станала "
"грешка.\n"

#: src/expr.c:462
#, fuzzy, c-format
msgid "syntax error: unexpected argument %s"
msgstr "синтактична грешка: неочакван край на файл"

#: src/expr.c:665
#, fuzzy, c-format
msgid "syntax error: missing argument after %s"
msgstr "липсващ аргумент за „%s“"

#: src/expr.c:748 src/ptx.c:289
msgid "error in regular expression matcher"
msgstr "грешка при пасването на регулярния израз"

#: src/expr.c:776
#, fuzzy, c-format
msgid "syntax error: expecting ')' after %s"
msgstr "синтактична грешка: неочакван край на файл"

#: src/expr.c:779
#, fuzzy, c-format
msgid "syntax error: expecting ')' instead of %s"
msgstr "синтактична грешка: неочакван край на файл"

#: src/expr.c:785
#, fuzzy
msgid "syntax error: unexpected ')'"
msgstr "синтактична грешка: неочакван знак „;“"

#: src/expr.c:931 src/expr.c:968
#, fuzzy
msgid "non-integer argument"
msgstr "аргументи, които не са опции, в „%s“"

#: src/expr.c:933 src/truncate.c:289
msgid "division by zero"
msgstr "делене на нула"

#: src/expr.c:1027 src/sort.c:2123
#, c-format
msgid "set LC_ALL='C' to work around the problem"
msgstr "за да заобиколите този проблем, задайте „LC_ALL='C'“"

#: src/expr.c:1029
#, fuzzy, c-format
msgid "the strings compared were %s and %s"
msgstr "Сравняваните низове бяха %s и %s."

#. This is a proper name. See the gettext manual, section Names.
#: src/factor.c:130
msgid "Niels Moller"
msgstr "Niels Moller"

#: src/factor.c:1276 src/factor.c:1376 src/factor.c:1452
#, c-format
msgid "Lucas prime test failure.  This should not happen"
msgstr ""

#: src/factor.c:2103
#, fuzzy
msgid "squfof queue overflow"
msgstr "Препълване на номера на том"

#: src/factor.c:2525
#, c-format
msgid "%s is not a valid positive integer"
msgstr "%s не е правилно положително цяло число"

#: src/factor.c:2549 src/od.c:1692 src/od.c:1773
#, c-format
msgid "%s is too large"
msgstr "%s е твърде дълго"

#: src/factor.c:2561
#, c-format
msgid ""
"Usage: %s [NUMBER]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s [ЧИСЛО]…\n"
"     или: %s ОПЦИЯ\n"

#: src/factor.c:2566
#, fuzzy
msgid ""
"Print the prime factors of each specified integer NUMBER.  If none\n"
"are specified on the command line, read them from standard input.\n"
"\n"
msgstr ""
"\n"
"  Отпечатва простите множители на всички посочени целочислени ЧИСЛА. При "
"липса\n"
"  на аргументи на командния ред, числата се четат от стандартния вход.\n"

#: src/find-mount-point.c:40
#, c-format
msgid "cannot get current directory"
msgstr "не може да се определи кой е текущият каталог"

#: src/find-mount-point.c:50 src/find-mount-point.c:64
#: src/find-mount-point.c:92
#, c-format
msgid "cannot change to directory %s"
msgstr "не може да се влезе в каталога %s"

#: src/find-mount-point.c:70
#, c-format
msgid "cannot stat current directory (now %s)"
msgstr "не може да се намери текущият каталог (сега %s)"

#. This is a proper name. See the gettext manual, section Names.
#: src/fmt.c:37
msgid "Ross Paterson"
msgstr "Ross Paterson"

#: src/fmt.c:269
#, c-format
msgid "Usage: %s [-WIDTH] [OPTION]... [FILE]...\n"
msgstr "Употреба: %s [-РАЗМЕР] [ОПЦИЯ]… ФАЙЛ…\n"

#: src/fmt.c:270
#, fuzzy
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"The option -WIDTH is an abbreviated form of --width=DIGITS.\n"
msgstr ""
"Преформатира всеки абзац във ФАЙЛовете, извеждайки на стандартния изход.\n"
"Ако няма посочен ФАЙЛ или ако ФАЙЛ е „-“, чете от стандартния вход.\n"
"\n"

#: src/fmt.c:278
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       reformat only lines beginning with STRING,\n"
"                              reattaching the prefix to reformatted lines\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c, --crown-margin        запазва отстъпа на първите два реда\n"
"  -p, --prefix=НИЗ          преформатира само редовете, започващи с НИЗ.  "
"Маха\n"
"                              НИЗ, форматира, след което добавя пак НИЗ\n"
"  -s, --split-only          цепи дългите редове, но не попълва късите\n"

#: src/fmt.c:287
#, fuzzy, no-c-format
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=WIDTH         maximum line width (default of 75 columns)\n"
"  -g, --goal=WIDTH          goal width (default of 93% of width)\n"
msgstr ""
"  -t, --tagged-paragraph    отстъпа на първия ред да се отличава от втория\n"
"  -u, --uniform-spacing     един интервал между думите, два между изречения\n"
"  -w, --width=ШИРИНА        максимална ширина на реда (по подразбиране 75 "
"знака)\n"

#: src/fmt.c:355
#, c-format
msgid ""
"invalid option -- %c; -WIDTH is recognized only when it is the first\n"
"option; use -w N instead"
msgstr ""
"неправилна опция -- %c; -ШИРИНА се разпознава само ако е първа опция;\n"
"в противен случай ползвайте -w ШИРИНА"

#: src/fmt.c:399 src/fmt.c:406
#, fuzzy
msgid "invalid width"
msgstr "неправилна широчина „%s“"

#: src/fold.c:70
msgid "Wrap input lines in each FILE, writing to standard output.\n"
msgstr ""
"Пренасяне на входните редове от всеки ФАЙЛ наново при извеждането на "
"стандартния изход\n"

#: src/fold.c:77
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes         броене на байтовете, вместо стълбовете\n"
"  -s, --spaces        прекъсване на работа при интервали\n"
"  -w, --width=БРОЙ    да се ползва този БРОЙ стълбове, вместо 80\n"

#: src/fold.c:284 src/pr.c:840
msgid "invalid number of columns"
msgstr "неправилен брой знаци"

#. This is a proper name. See the gettext manual, section Names.
#: src/getlimits.c:30 src/md5sum.c:107 src/realpath.c:33 src/stdbuf.c:38
#: src/timeout.c:78 src/truncate.c:38
msgid "Padraig Brady"
msgstr "Padraig Brady"

#: src/getlimits.c:66
#, c-format
msgid "Usage: %s\n"
msgstr "Употреба: %s\n"

#: src/getlimits.c:70
msgid ""
"Output platform dependent limits in a format useful for shell scripts.\n"
"\n"
msgstr ""
"Извеждане на ограниченията на платформата във формат подходящ за скриптове "
"на обвивката.\n"
"\n"

#: src/group-list.c:68 src/id.c:401
#, c-format
msgid "failed to get groups for user %s"
msgstr "групите на потребителя „%s“ не могат да се получат"

#: src/group-list.c:73 src/id.c:404
#, c-format
msgid "failed to get groups for the current process"
msgstr "групите на текущия процес не могат да се получат"

#: src/group-list.c:113
#, c-format
msgid "cannot find name for group ID %lu"
msgstr "не може да се намери името на група с номер %lu"

#: src/groups.c:54
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]...\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ПОТРЕБИТЕЛСКО_ИМЕ]…\n"

#: src/groups.c:55
msgid ""
"Print group memberships for each USERNAME or, if no USERNAME is specified, "
"for\n"
"the current process (which may differ if the groups database has changed).\n"
msgstr ""

#: src/groups.c:106 src/id.c:289
#, fuzzy
msgid "cannot get real UID"
msgstr "„%s“ не може да се изтрие"

#: src/groups.c:111 src/id.c:297
#, fuzzy
msgid "cannot get effective GID"
msgstr ""
"идентификаторът на потребител на процеса не може да се зададе да е %d,\n"
"ефективният идентификатор на потребител на процеса е %d"

#: src/groups.c:116 src/id.c:302
#, fuzzy
msgid "cannot get real GID"
msgstr "„%s“ не може да се изтрие"

#: src/groups.c:130 src/id.c:255
#, fuzzy, c-format
msgid "%s: no such user"
msgstr "%s: няма такава задача"

#: src/head.c:114
#, c-format
msgid ""
"Print the first %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""
"Извеждане на първите %d реда от всеки ФАЙЛ на стандартния изход.\n"
"При повече от един ФАЙЛ се поставят заглавия с имената на файловете.\n"

#: src/head.c:122
#, c-format
msgid ""
"  -c, --bytes=[-]NUM       print the first NUM bytes of each file;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM bytes of each file\n"
"  -n, --lines=[-]NUM       print the first NUM lines instead of the first "
"%d;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM lines of each file\n"
msgstr ""
"  -c, --bytes=[-]N         извеждане на първите N байта от всеки файл,\n"
"                           с отрицателно число се извеждат всички, освен\n"
"                           последните N байта от всеки файл\n"
"  -n, --lines=[-]N         извеждане на първите N реда от всеки файл "
"(вместо\n"
"                           първите %d), с отрицателно число се извеждат "
"всички,\n"
"                           освен последните N реда от всеки файл\n"

#: src/head.c:130
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent    да не се извеждат заглавия с имената на "
"файловете\n"
"  -v, --verbose            винаги да извежда заглавия с имената на "
"файловете\n"

#: src/head.c:139
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""
"\n"
"БРОят може да бъде следван от следните суфикси-множители:\n"
"b≡512, kB≡1000, K≡1024, MB≡1000×1000, M≡1024×1024,\n"
"GB≡1000×1000×1000, G≡1024×1024×1024 и т.н. за „T“, „P“, „E“, „Z“ и „Y“.\n"
"Приемат се и двоични префикси: KiB≡K, MiB≡M и т.н.\n"

#: src/head.c:160
#, c-format
msgid "%s: file has shrunk too much"
msgstr "%s: файлът се е свил твърде много"

#: src/head.c:232 src/tail.c:507
#, c-format
msgid "%s: cannot seek to offset %s"
msgstr "%s: не може да се отиде към отместване %s във файла"

#: src/head.c:233 src/tail.c:511
#, c-format
msgid "%s: cannot seek to relative offset %s"
msgstr "%s: не може да се отиде към относително отместване %s във файла"

#: src/head.c:275
#, c-format
msgid "%s: number of bytes is too large"
msgstr "%s: твърде голям брой байтове"

#: src/head.c:913 src/split.c:1368 src/split.c:1535 src/tail.c:2205
msgid "invalid number of lines"
msgstr "недопустим брой редове"

#: src/head.c:914 src/head.c:1078 src/split.c:1360 src/split.c:1376
#: src/tail.c:2206
msgid "invalid number of bytes"
msgstr "недопустимо количество байтове"

#: src/head.c:1004 src/head.c:1066
#, c-format
msgid "invalid trailing option -- %c"
msgstr "неправилна опция -- %c"

#: src/hostid.c:41
#, c-format
msgid ""
"Usage: %s [OPTION]\n"
"Print the numeric identifier (in hexadecimal) for the current host.\n"
"\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]\n"
"Извеждане на шестнадесетичен числов идентификатор на хоста.\n"
"\n"

#: src/hostname.c:56
#, c-format
msgid ""
"Usage: %s [NAME]\n"
"  or:  %s OPTION\n"
"Print or set the hostname of the current system.\n"
"\n"
msgstr ""
"Употреба: %s [ИМЕ]\n"
"     или: %s ОПЦИЯ\n"
"Извеждане или задаване на името на хоста на текущата система.\n"
"\n"

#: src/hostname.c:93
#, c-format
msgid "cannot set name to %s"
msgstr "името не може да се зададе да е „%s“"

#: src/hostname.c:97
msgid "cannot set hostname; this system lacks the functionality"
msgstr ""
"не може да се задава хост-име, тази система не притежава такава възможност"

#: src/hostname.c:105
msgid "cannot determine hostname"
msgstr "името на хоста не може да бъде определено"

#. This is a proper name. See the gettext manual, section Names.
#: src/id.c:41 src/touch.c:43
msgid "Arnold Robbins"
msgstr "Arnold Robbins"

#: src/id.c:96 src/pinky.c:489
#, c-format
msgid "Usage: %s [OPTION]... [USER]...\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ПОТРЕБИТЕЛ]…\n"

#: src/id.c:97
msgid ""
"Print user and group information for each specified USER,\n"
"or (when USER omitted) for the current user.\n"
"\n"
msgstr ""

#: src/id.c:102
#, fuzzy
msgid ""
"  -a             ignore, for compatibility with other versions\n"
"  -Z, --context  print only the security context of the process\n"
"  -g, --group    print only the effective group ID\n"
"  -G, --groups   print all group IDs\n"
"  -n, --name     print a name instead of a number, for -ugG\n"
"  -r, --real     print the real ID instead of the effective ID, with -ugG\n"
"  -u, --user     print only the effective user ID\n"
"  -z, --zero     delimit entries with NUL characters, not whitespace;\n"
"                   not permitted in default format\n"
msgstr ""
"Извежда информация за ПОТРЕБИТЕЛ или текущия потребител.\n"
"\n"
"  -a              пренебрегва се; за съвместимост с предишни версии\n"
"  -g, --group     извежда само номера на действащата (effective) група\n"
"  -G, --groups    извежда номерата на всички групи\n"
"  -n, --name      извежда име вместо номер; -ugG\n"
"  -r, --real      извежда реалните (real) вместо действащите номера, с -ugG\n"
"  -u, --user      извежда само номера на действащия (effective) потребител\n"

#: src/id.c:115
msgid ""
"\n"
"Without any OPTION, print some useful set of identified information.\n"
msgstr ""
"\n"
"Без никаква ОПЦИЯ просто отпечатва полезна идентификационна информация.\n"

#: src/id.c:153
msgid "--context (-Z) works only on an SELinux/SMACK-enabled kernel"
msgstr ""

#: src/id.c:158
msgid "--context (-Z) works only on an SELinux-enabled kernel"
msgstr ""

#: src/id.c:192
msgid "cannot print security context when user specified"
msgstr ""

#: src/id.c:195
#, fuzzy
msgid "cannot print \"only\" of more than one choice"
msgstr "не може да се ползва едновременно повече от една от опциите „-anrw“"

#: src/id.c:204
msgid "cannot print only names or real IDs in default format"
msgstr ""
"не може да се извеждат само имена или номера във формата по подразбиране"

#: src/id.c:208
#, fuzzy
msgid "option --zero not permitted in default format"
msgstr ""
"не може да се извеждат само имена или номера във формата по подразбиране"

#: src/id.c:224
#, fuzzy
msgid "can't get process context"
msgstr "междупроцесен канал"

#: src/id.c:280
#, fuzzy
msgid "cannot get effective UID"
msgstr ""
"идентификаторът на потребител на процеса не може да се зададе да е %d,\n"
"ефективният идентификатор на потребител на процеса е %d"

#: src/id.c:344
#, fuzzy, c-format
msgid "cannot find name for user ID %s"
msgstr "етикетът „%s“, към който трябва да се премине, липсва"

#: src/id.c:362
#, c-format
msgid "uid=%s"
msgstr ""

#: src/id.c:367
#, c-format
msgid " gid=%s"
msgstr ""

#: src/id.c:374
#, c-format
msgid " euid=%s"
msgstr ""

#: src/id.c:382
#, c-format
msgid " egid=%s"
msgstr ""

#: src/id.c:410
msgid " groups="
msgstr " групи="

#: src/id.c:426
#, c-format
msgid " context=%s"
msgstr ""

#: src/install.c:378
#, fuzzy, c-format
msgid "warning: %s: failed to change context to %s"
msgstr ""
"%s: ПРЕДУПРЕЖДЕНИЕ: контекстът за сигурност на „%s“ не може да се получи: %s"

#: src/install.c:420
#, c-format
msgid "creating directory %s"
msgstr "създава се каталог %s"

#: src/install.c:432 src/mkdir.c:128 src/mkdir.c:161
#, c-format
msgid "failed to set default creation context for %s"
msgstr ""
"стандартният контекст при създаване на файлове не може да се зададе на „%s“"

#: src/install.c:462 src/mkdir.c:181
#, c-format
msgid "failed to restore context for %s"
msgstr "контекстът на „%s“ не може да се възстанови"

#: src/install.c:510
#, c-format
msgid "cannot change ownership of %s"
msgstr "не може да се смени собствеността на %s"

#: src/install.c:534
#, fuzzy, c-format
msgid "cannot set timestamps for %s"
msgstr "времето не може да се смени на „%s“"

#: src/install.c:556 src/split.c:523 src/timeout.c:506
#, c-format
msgid "fork system call failed"
msgstr "системната функция за нов процес (fork) не успя"

#: src/install.c:560
#, fuzzy, c-format
msgid "cannot run %s"
msgstr "„%s“ не може да се отвори"

# QUOTE
#: src/install.c:563
#, fuzzy, c-format
msgid "waiting for strip"
msgstr "грешка при изчакване на „%s“"

#: src/install.c:565
#, c-format
msgid "strip process terminated abnormally"
msgstr ""

#: src/install.c:589
#, c-format
msgid "invalid user %s"
msgstr "неправилен потребител %s"

#: src/install.c:627
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
"  or:  %s [OPTION]... -d DIRECTORY...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [-T] ИЗТОЧНИК ЦЕЛ\n"
"     или: %s [ОПЦИЯ]… ИЗТОЧНИК… ДИРЕКТОРИЯ\n"
"     или: %s [ОПЦИЯ]… -t ДИРЕКТОРИЯ ЦЕЛ…\n"
"     или: %s [ОПЦИЯ]… -d ДИРЕКТОРИЯ…\n"

#: src/install.c:634
#, fuzzy
msgid ""
"\n"
"This install program copies files (often just compiled) into destination\n"
"locations you choose.  If you want to download and install a ready-to-use\n"
"package on a GNU/Linux system, you should instead be using a package "
"manager\n"
"like yum(1) or apt-get(1).\n"
"\n"
"In the first three forms, copy SOURCE to DEST or multiple SOURCE(s) to\n"
"the existing DIRECTORY, while setting permission modes and owner/group.\n"
"In the 4th form, create all components of the given DIRECTORY(ies).\n"
msgstr ""
"При първите три формата ИЗТОЧНИК се копира в ЦЕЛ или няколкото ИЗТОЧНИКа\n"
"в съществуващ КАТАЛОГ, като се установяват режим на достъп и собственик/"
"група.\n"
"При четвъртия формат се създават всички компоненти на дадения(ните) "
"КАТАЛОГ(зи).\n"
"\n"

#: src/install.c:648
#, fuzzy
msgid ""
"      --backup[=CONTROL]  make a backup of each existing destination file\n"
"  -b                  like --backup but does not accept an argument\n"
"  -c                  (ignored)\n"
"  -C, --compare       compare each pair of source and destination files, "
"and\n"
"                        in some cases, do not modify the destination at all\n"
"  -d, --directory     treat all arguments as directory names; create all\n"
"                        components of the specified directories\n"
msgstr ""
"      --backup[=МЕТОД] прави резервно копие на съществуващите целеви "
"файлове\n"
"  -b                  като --backup, но не допуска използването на аргумент\n"
"  -c                  (пренебрегва се)\n"
"  -d, --directory     приема всички аргументи като имена на каталози; "
"създава\n"
"                        всички компоненти на посочените каталози\n"

#: src/install.c:657
#, fuzzy
msgid ""
"  -D                  create all leading components of DEST except the "
"last,\n"
"                        or all components of --target-directory,\n"
"                        then copy SOURCE to DEST\n"
"  -g, --group=GROUP   set group ownership, instead of process' current "
"group\n"
"  -m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-"
"x\n"
"  -o, --owner=OWNER   set ownership (super-user only)\n"
msgstr ""
"  -D                  създава всички начални компоненти на ЦЕЛ освен "
"последния,\n"
"                         а след това копира ИЗТОЧНИК в ЦЕЛ\n"
"  -g, --group=ГРУПА   посочва група вместо текущата група на процеса\n"
"  -m, --mode=РЕЖИМ    посочва режим за достъп (като при chmod), вместо rwxr-"
"xr-x\n"
"  -o, --owner=СОБСТВ  посочва собственик (само от привилегирован "
"потребител)\n"

#: src/install.c:665
#, fuzzy
msgid ""
"  -p, --preserve-timestamps   apply access/modification times of SOURCE "
"files\n"
"                        to corresponding destination files\n"
"  -s, --strip         strip symbol tables\n"
"      --strip-program=PROGRAM  program used to strip binaries\n"
"  -S, --suffix=SUFFIX  override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory  treat DEST as a normal file\n"
"  -v, --verbose       print the name of each directory as it is created\n"
msgstr ""
"  -p, --preserve-timestamps   прилага времената за достъп/промяна на\n"
"                        файловете-ИЗТОЧНИК за съответните целеви файлове\n"
"  -s, --strip         маха символните таблици\n"
"  -S, --suffix=СУФИКС вместо обичайния суфикс за резервни копия\n"
"  -t, --target-directory=КАТАЛОГ  копира всички аргументи ИЗТОЧНИК в "
"КАТАЛОГ\n"
"  -T, --no-target-directory  работи с ЦЕЛ като с обикновен файл\n"
"  -v, --verbose       извежда името на всеки каталог при създаването му\n"

#: src/install.c:675
msgid ""
"      --preserve-context  preserve SELinux security context\n"
"  -Z                      set SELinux security context of destination\n"
"                            file and each created directory to default type\n"
"      --context[=CTX]     like -Z, or if CTX is specified then set the\n"
"                            SELinux or SMACK security context to CTX\n"
msgstr ""

#: src/install.c:711 src/unlink.c:85
#, c-format
msgid "cannot unlink %s"
msgstr "неуспешно изпълнение на „unlink“ върху „%s“"

#: src/install.c:892
#, c-format
msgid ""
"WARNING: ignoring --preserve-context; this kernel is not SELinux-enabled"
msgstr ""

#: src/install.c:932
msgid "the strip option may not be used when installing a directory"
msgstr ""
"опцията махане на символните таблици не може да се използва при инсталиране "
"на каталог"

#: src/install.c:935
msgid "target directory not allowed when installing a directory"
msgstr ""
"при инсталиране на каталог не се позволява посочването на целеви каталог"

#: src/install.c:1002 src/mkdir.c:284 src/stdbuf.c:352
#, c-format
msgid "invalid mode %s"
msgstr "неправилен режим „%s“"

#: src/install.c:1009
#, c-format
msgid "WARNING: ignoring --strip-program option as -s option was not specified"
msgstr ""

#: src/install.c:1014
#, fuzzy, c-format
msgid "options --compare (-C) and --preserve-timestamps are mutually exclusive"
msgstr "опциите --string и --check не може да се използват едновременно"

#: src/install.c:1021
#, fuzzy, c-format
msgid "options --compare (-C) and --strip are mutually exclusive"
msgstr "посочените опции за дати за отпечатване са взаимно изключващи се"

#: src/install.c:1027
#, c-format
msgid ""
"the --compare (-C) option is ignored when you specify a mode with non-"
"permission bits"
msgstr ""

#. This is a proper name. See the gettext manual, section Names.
#: src/join.c:41 src/sort.c:66
msgid "Mike Haertel"
msgstr "Mike Haertel"

#: src/join.c:196
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited by blanks.\n"
msgstr ""

#: src/join.c:205
#, fuzzy
msgid ""
"\n"
"  -a FILENUM        also print unpairable lines from file FILENUM, where\n"
"                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""
"Извежда ред за всяка двойка входни редове с идентични свързващи полета.\n"
"По подразбиране свързващо поле е първото, ограничава се интервали и "
"табулации.\n"
"Когато ФАЙЛ1 или ФАЙЛ2 (не едновременно) е -, се чете от стандартния вход.\n"
"\n"
"  -a ФАЙЛНОМ        извежда несъответстващите редове от файла ФАЙЛНОМ, "
"където\n"
"                      ФАЙЛНОМ е 1 или 2 съответно за ФАЙЛ1 и ФАЙЛ2\n"
"  -e ПРАЗНО         заменя липсващите входни полета с ПРАЗНО\n"

#: src/join.c:211
#, fuzzy
msgid ""
"  -i, --ignore-case  ignore differences in case when comparing fields\n"
"  -j FIELD          equivalent to '-1 FIELD -2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""
"  -i, --ignore-case не различава големи/малки букви при сравняване на "
"полетата\n"
"  -j ПОЛЕ           също като „-1 ПОЛЕ -2 ПОЛЕ“\n"
"  -o ФОРМАТ         следва ФОРМАТ при съставяне на изходните редове\n"
"  -t ЗНАК           ползва ЗНАК като разделител на входните и изходни "
"полета\n"

#: src/join.c:217
msgid ""
"  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
"  --header          treat the first line in each file as field headers,\n"
"                      print them without trying to pair them\n"
msgstr ""

#: src/join.c:227 src/shuf.c:83 src/sort.c:504 src/uniq.c:206
msgid "  -z, --zero-terminated     line delimiter is NUL, not newline\n"
msgstr ""
"  -z, --zero-terminated     завършване на редовете с нулев байт вместо с нов "
"ред\n"

#: src/join.c:232
#, fuzzy
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
"line of each file determines the number of fields output for each line.\n"
"\n"
"Important: FILE1 and FILE2 must be sorted on the join fields.\n"
"E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
"or use \"join -t ''\" if 'sort' has no options.\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
"If the input is not sorted and some lines cannot be joined, a\n"
"warning message will be given.\n"
msgstr ""
"\n"
"Ако не е зададен -t ЗНАК, бялото поле пред полетата е разделител и се "
"игнорира.\n"
"Иначе полетата са разделени със ЗНАК.  Всяко ПОЛЕ е номер, който се брои от "
"1.\n"
"ФОРМАТ е една или повече спецификации, разделени със запетая или интервал,\n"
"всяка от които е „ФАЙЛНОМ.ПОЛЕ“ или „0“.  По подразбиране ФОРМАТ извежда\n"
"свързващото поле, останалите полета от ФАЙЛ1 и останалите полета от ФАЙЛ2, "
"като\n"
"ги разделя със ЗНАК.\n"
"\n"
"Важно: ФАЙЛ1 и ФАЙЛ2 трябва да бъдат сортирани по свързващите полета. "
"Например\n"
"ако на join не са подадени опции, ползвайте „sort -k 1b,1“.\n"

#: src/join.c:417
#, c-format
msgid "%s:%<PRIuMAX>: is not sorted: %.*s"
msgstr ""

#: src/join.c:849 src/join.c:1047
#, c-format
msgid "invalid field number: %s"
msgstr "неправилен номер на поле: %s"

#: src/join.c:870 src/join.c:879
#, c-format
msgid "invalid field specifier: %s"
msgstr "неправилен означител за поле: %s"

#: src/join.c:886
#, c-format
msgid "invalid file number in field spec: %s"
msgstr "неправилен номер на файл при означител на поле: %s"

#: src/join.c:930
#, c-format
msgid "incompatible join fields %lu, %lu"
msgstr "неправилни свързващи полета %lu, %lu"

#: src/join.c:1058
msgid "conflicting empty-field replacement strings"
msgstr "несъвместими заменящи низове за празно поле"

#: src/join.c:1110 src/sort.c:4539
#, c-format
msgid "multi-character tab %s"
msgstr "табулатор от множество знаци „%s“"

#: src/join.c:1114 src/sort.c:4544
msgid "incompatible tabs"
msgstr "несъвместими табулатори"

#: src/join.c:1187
msgid "both files cannot be standard input"
msgstr "не може и двата файла да са стандартният вход"

#: src/kill.c:77
#, c-format
msgid ""
"Usage: %s [-s SIGNAL | -SIGNAL] PID...\n"
"  or:  %s -l [SIGNAL]...\n"
"  or:  %s -t [SIGNAL]...\n"
msgstr ""
"Употреба: %s [-s СИГНАЛ | -СИГНАЛ] ИД_ПР…\n"
"     или: %s -l [СИГНАЛ]…\n"
"     или: %s -t [СИГНАЛ]…\n"

#: src/kill.c:83
msgid "Send signals to processes, or list signals.\n"
msgstr "Изпращане на сигнали към процеси или извеждане на самите сигнали.\n"

#: src/kill.c:89
msgid ""
"  -s, --signal=SIGNAL, -SIGNAL\n"
"                   specify the name or number of the signal to be sent\n"
"  -l, --list       list signal names, or convert signal names to/from "
"numbers\n"
"  -t, --table      print a table of signal information\n"
msgstr ""
"  -s, --signal=СИГНАЛ, -СИГНАЛ\n"
"                   указване на името или номера на сигнала за изпращане\n"
"  -l, --list       извеждане на имената на сигналите, преобразуване в/от "
"номера\n"
"  -t, --table      извеждане на таблица с информация за сигналите\n"

#: src/kill.c:97
msgid ""
"\n"
"SIGNAL may be a signal name like 'HUP', or a signal number like '1',\n"
"or the exit status of a process terminated by a signal.\n"
"PID is an integer; if negative it identifies a process group.\n"
msgstr ""
"\n"
"СИГНАЛът може да бъде име на сигнал (напр. „HUP“), номер (напр. „1“)\n"
"или код-състояние на изход на процес, прекратен чрез сигнал.\n"
"ИДентификаторът_на_ПРоцес е цяло число, ако е отрицателно — указва\n"
"група от процеси.\n"

#: src/kill.c:206
#, c-format
msgid "%s: invalid process id"
msgstr "%s: неправилен номер на процес"

#: src/kill.c:260
#, c-format
msgid "invalid option -- %c"
msgstr "неправилна опция — „%c“"

#: src/kill.c:269
#, c-format
msgid "%s: multiple signals specified"
msgstr "%s: посочени са много сигнали"

#: src/kill.c:284
#, c-format
msgid "multiple -l or -t options specified"
msgstr "посочени са много опции „-l“ или „-t“"

#: src/kill.c:301
#, c-format
msgid "cannot combine signal with -l or -t"
msgstr "не може да се задават сигнали заедно с „-l“ или „-t“"

#: src/kill.c:307
#, c-format
msgid "no process ID specified"
msgstr "не е посочен идентификатор на процес"

#: src/libstdbuf.c:112
#, c-format
msgid "failed to allocate a %<PRIuMAX> byte stdio buffer\n"
msgstr "неуспешно заделяне на буфер за стандартния изход от %<PRIuMAX> байта\n"

#: src/libstdbuf.c:119
#, c-format
msgid "invalid buffering mode %s for %s\n"
msgstr "неправилен режим на буфериране „%s“ за „%s“\n"

#: src/libstdbuf.c:127
#, c-format
msgid "could not set buffering of %s to mode %s\n"
msgstr "режимът на буферирането на „%s“ не може да се зададе да е „%s“\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/link.c:36 src/unlink.c:36 src/who.c:52
msgid "Michael Stone"
msgstr "Michael Stone"

#: src/link.c:45
#, c-format
msgid ""
"Usage: %s FILE1 FILE2\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s ФАЙЛ_1 ФАЙЛ_2\n"
"     или: %s ОПЦИЯ\n"

#: src/link.c:48
msgid ""
"Call the link function to create a link named FILE2 to an existing FILE1.\n"
"\n"
msgstr ""
"Създаване на твърда връзка ФАЙЛ_2 към съществуващ ФАЙЛ_1.\n"
"\n"

#: src/link.c:89
#, c-format
msgid "cannot create link %s to %s"
msgstr "неуспешно създаване на връзка „%s“ към „%s“"

#: src/ln.c:213
#, c-format
msgid "%s: hard link not allowed for directory"
msgstr "%s: твърди връзки към директории не са позволени"

#: src/ln.c:238
#, c-format
msgid "%s: cannot overwrite directory"
msgstr "%s: директорията не може да се презапише"

#: src/ln.c:285
#, c-format
msgid "%s: replace %s? "
msgstr "%s: да се замени ли „%s“? "

#: src/ln.c:380
#, c-format
msgid "failed to create symbolic link %s"
msgstr "неуспешно създаване на символна връзка „%s“"

#: src/ln.c:381
#, c-format
msgid "failed to create symbolic link %s -> %s"
msgstr "неуспешно създаване на символна връзка „%s“ към „%s“"

#: src/ln.c:383
#, c-format
msgid "failed to create hard link to %.0s%s"
msgstr "неуспешно създаване на твърда връзка към „%.0s%s“"

#: src/ln.c:386
#, c-format
msgid "failed to create hard link %s"
msgstr "неуспешно създаване на твърдата връзка „%s“"

#: src/ln.c:387
#, c-format
msgid "failed to create hard link %s => %s"
msgstr "не може да се създаде твърда връзка „%s“ към „%s“"

#: src/ln.c:409
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] TARGET LINK_NAME\n"
"  or:  %s [OPTION]... TARGET\n"
"  or:  %s [OPTION]... TARGET... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY TARGET...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [-T] ЦЕЛ ИМЕ_НА_ВРЪЗКА\n"
"     или: %s [ОПЦИЯ]… ЦЕЛ\n"
"     или: %s [ОПЦИЯ]… ЦЕЛ… ДИРЕКТОРИЯ\n"
"     или: %s [ОПЦИЯ]… --target-directory=ДИРЕКТОРИЯ ЦЕЛ…\n"

#: src/ln.c:416
msgid ""
"In the 1st form, create a link to TARGET with the name LINK_NAME.\n"
"In the 2nd form, create a link to TARGET in the current directory.\n"
"In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.\n"
"Create hard links by default, symbolic links with --symbolic.\n"
"By default, each destination (name of new link) should not already exist.\n"
"When creating hard links, each TARGET must exist.  Symbolic links\n"
"can hold arbitrary text; if later resolved, a relative link is\n"
"interpreted in relation to its parent directory.\n"
msgstr ""
"В първия вариант се създава връзка към посочената ЦЕЛ с такова "
"ИМЕ_НА_ВРЪЗКА.\n"
"Във втория вариант се създава връзка към посочената ЦЕЛ в текущата "
"директория.\n"
"В третия и четвъртия варианти в ДИРекторията се създават връзки към ЦЕЛите.\n"
"Стандартно не трябва да има обекти с имена като на новосъздадените връзки.\n"
"При правенето на твърди връзки всички ЦЕЛи трябва да съществуват.  "
"Символните\n"
"връзки нямат такова ограничение и може да сочат към несъществуваща ЦЕЛ.\n"
"Относителна ЦЕЛ на символна връзка се определя спрямо родителската ѝ "
"директория.\n"

#: src/ln.c:429
msgid ""
"      --backup[=CONTROL]      make a backup of each existing destination "
"file\n"
"  -b                          like --backup but does not accept an argument\n"
"  -d, -F, --directory         allow the superuser to attempt to hard link\n"
"                                directories (note: will probably fail due "
"to\n"
"                                system restrictions, even for the "
"superuser)\n"
"  -f, --force                 remove existing destination files\n"
msgstr ""
"      --backup[=МЕТОД]        резервно копие на всеки съществуващ целеви "
"файл\n"
"  -b                          като „--backup“, но не приема аргумент\n"
"  -d, -F, --directory         позволяване на системните потребители да се "
"опитат\n"
"                              да правят твърди връзки към директории.  "
"Вероятно\n"
"                              ще получите грешка поради ограничения в "
"системата\n"
"  -f, --force                 изтриване на съществуващите целеви файлове\n"

#: src/ln.c:437
msgid ""
"  -i, --interactive           prompt whether to remove destinations\n"
"  -L, --logical               dereference TARGETs that are symbolic links\n"
"  -n, --no-dereference        treat LINK_NAME as a normal file if\n"
"                                it is a symbolic link to a directory\n"
"  -P, --physical              make hard links directly to symbolic links\n"
"  -r, --relative              create symbolic links relative to link "
"location\n"
"  -s, --symbolic              make symbolic links instead of hard links\n"
msgstr ""
"  -i, --interactive           питане дали целите да се трият\n"
"  -L, --logical               следване на ЦЕЛи, които са символни връзки\n"
"  -n, --no-dereference        обработване на ИМЕто_НА_ВРЪЗКА като нормален "
"файл,\n"
"                              ако сочи към директория\n"
"  -P, --physical              създаване на твърди връзки към символни "
"връзки\n"
"  -r, --relative              създаване на относителни символни връзки "
"спрямо\n"
"                              местоположението на връзката\n"
"  -s, --symbolic              създаване на символни, а не на твърди връзки\n"

#: src/ln.c:446
msgid ""
"  -S, --suffix=SUFFIX         override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  specify the DIRECTORY in which to "
"create\n"
"                                the links\n"
"  -T, --no-target-directory   treat LINK_NAME as a normal file always\n"
"  -v, --verbose               print name of each linked file\n"
msgstr ""
"  -S, --suffix=СУФИКС         ползване на този СУФИКС за резервни копия\n"
"  -t, --target-directory=ДИР  в коя ДИРектория да се правят връзките\n"
"  -T, --no-target-directory   работа с ИМЕ_НА_ВРЪЗКА като нормален файл\n"
"  -v, --verbose               извеждане на името на всеки файл при "
"създаване\n"
"                              на връзка\n"

#: src/ln.c:456
#, c-format
msgid ""
"\n"
"Using -s ignores -L and -P.  Otherwise, the last option specified controls\n"
"behavior when a TARGET is a symbolic link, defaulting to %s.\n"
msgstr ""
"\n"
"При ползването на „-s“ — опциите „-L“ и „-P“ се прескачат.  Иначе "
"последната\n"
"опция определя поведението, когато ЦЕЛта е символна връзка — стандартно то "
"е\n"
"същото като „%s“.\n"

#: src/ln.c:572
msgid "cannot do --relative without --symbolic"
msgstr "опцията „--relative“ изисква „--symbolic“"

#: src/ln.c:584
msgid "cannot combine --target-directory and --no-target-directory"
msgstr "опциите „--target-directory“ и „--no-target-directory“ са несъвместими"

#: src/ln.c:619
#, c-format
msgid "target %s"
msgstr "цел „%s“"

#. This is a proper name. See the gettext manual, section Names.
#: src/logname.c:30
msgid "FIXME: unknown"
msgstr "FIXME: името на автора не се знае"

#: src/logname.c:39
#, c-format
msgid "Usage: %s [OPTION]\n"
msgstr "Употреба: %s [ОПЦИЯ]\n"

#: src/logname.c:40
msgid ""
"Print the name of the current user.\n"
"\n"
msgstr ""
"Извеждане на името на текущия потребител.\n"
"\n"

#: src/logname.c:78
msgid "no login name"
msgstr "няма входящо име"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:770
msgid "%b %e  %Y"
msgstr "%e %b %Y"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:783
msgid "%b %e %H:%M"
msgstr "%e %b %H:%M"

#: src/ls.c:1755
#, c-format
msgid "ignoring invalid width in environment variable COLUMNS: %s"
msgstr ""
"пренебрегване на неправилната широчина на реда от променливата на средата "
"„COLUMNS“: %s"

#: src/ls.c:1783
#, c-format
msgid "ignoring invalid tab size in environment variable TABSIZE: %s"
msgstr ""
"пренебрегване на неправилния размер на табулацията от променливата на "
"средата „TABSIZE“: %s"

#: src/ls.c:1902
msgid "invalid line width"
msgstr "неправилна широчина на реда"

#: src/ls.c:1970
msgid "invalid tab size"
msgstr "неправилен размер на табулатора"

#: src/ls.c:2203
#, c-format
msgid "invalid time style format %s"
msgstr "неправилен формат на време: %s"

#: src/ls.c:2227
msgid "Valid arguments are:\n"
msgstr "Възможните аргументи са:\n"

#: src/ls.c:2231
msgid "  - +FORMAT (e.g., +%H:%M) for a 'date'-style format\n"
msgstr "  — +ФОРМАТ (напр. „+%H:%M“) за форматиране като дата\n"

#: src/ls.c:2605
#, c-format
msgid "unrecognized prefix: %s"
msgstr "непознат префикс: %s"

#: src/ls.c:2635
#, c-format
msgid "unparsable value for LS_COLORS environment variable"
msgstr "неразбираема стойност на променливата на средата „LS_COLORS“"

#: src/ls.c:2665 src/stat.c:1059
#, c-format
msgid "ignoring invalid value of environment variable QUOTING_STYLE: %s"
msgstr ""
"пренебрегване на неправилния начин на цитиране от променливата на средата "
"„QUOTING_STYLE“: %s"

#: src/ls.c:2731 src/pwd.c:164
#, c-format
msgid "cannot open directory %s"
msgstr "директорията „%s“ не може да се отвори"

#: src/ls.c:2746
#, c-format
msgid "cannot determine device and inode of %s"
msgstr "устройството и i-възелът на „%s“ не могат да се определят"

#: src/ls.c:2755
#, c-format
msgid "%s: not listing already-listed directory"
msgstr "%s: без извеждане на вече изведена директория"

#: src/ls.c:2780 src/ls.c:3199 src/selinux.c:127 src/selinux.c:300
#, c-format
msgid "error canonicalizing %s"
msgstr "грешка при определянето на каноничния вариант на „%s“"

#: src/ls.c:2842 src/pwd.c:232
#, c-format
msgid "reading directory %s"
msgstr "четене на директория „%s“"

#: src/ls.c:2857
#, c-format
msgid "closing directory %s"
msgstr "затваряне на директория „%s“"

#: src/ls.c:3574
#, c-format
msgid "cannot compare file names %s and %s"
msgstr "имената на файловете „%s“ и „%s“ не може да се сравнят"

#: src/ls.c:5134
msgid ""
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
msgstr ""
"Извеждане на информация за ФАЙЛовете (по подразбиране за текущата "
"директория).\n"
"Спазване на азбучна подредба, освен ако има опция „-cftuvSUX“ или „--sort“.\n"
"\n"

#: src/ls.c:5141
msgid ""
"  -a, --all                  do not ignore entries starting with .\n"
"  -A, --almost-all           do not list implied . and ..\n"
"      --author               with -l, print the author of each file\n"
"  -b, --escape               print C-style escapes for nongraphic "
"characters\n"
msgstr ""
"  -a, --all                  без обектите, които започват с „.“\n"
"  -A, --almost-all           без стандартните „.“ и „..“\n"
"      --author               с „-l“ извежда автора на всеки файл\n"
"  -b, --escape               осмично представяне на неграфичните знаци\n"

#: src/ls.c:5147
msgid ""
"      --block-size=SIZE      with -l, scale sizes by SIZE when printing "
"them;\n"
"                               e.g., '--block-size=M'; see SIZE format "
"below\n"
msgstr ""
"      --block-size=РАЗМЕР    заедно с „-l“: мащабиране на стойностите към "
"този\n"
"                             РАЗМЕР при извеждането им, напр. „--block-"
"size=M“.\n"
"                             Вижте по-долу за възможните стойности  на "
"РАЗМЕРа\n"

#: src/ls.c:5151
msgid ""
"  -B, --ignore-backups       do not list implied entries ending with ~\n"
"  -c                         with -lt: sort by, and show, ctime (time of "
"last\n"
"                               modification of file status information);\n"
"                               with -l: show ctime and sort by name;\n"
"                               otherwise: sort by ctime, newest first\n"
msgstr ""
"  -B, --ignore-backups       без обектите с имена, завършващи с „~“\n"
"  -c                         с „-lt“: показване и подредба според „ctime“\n"
"                             (времето на последна промяна на информацията "
"за\n"
"                             файла);\n"
"                             с „-l“: показване на ctime, но подредба по "
"името;\n"
"                             иначе: подредба според ctime, най-новите — "
"отпред.\n"

#: src/ls.c:5158
msgid ""
"  -C                         list entries by columns\n"
"      --color[=WHEN]         colorize the output; WHEN can be "
"'always' (default\n"
"                               if omitted), 'auto', or 'never'; more info "
"below\n"
"  -d, --directory            list directories themselves, not their "
"contents\n"
"  -D, --dired                generate output designed for Emacs' dired mode\n"
msgstr ""
"  -C                         извеждане на елементите в колони\n"
"      --color[=КОГА]         дали да се използват цветове за посочване на\n"
"                             видовете файлове.  КОГА може да бъде\n"
"                             „never“ (никога), „always“ (винаги) или\n"
"                             „auto“ (автоматично)\n"
"  -d, --directory            извеждане на директориите, вместо съдържанието "
"им\n"
"                             и символните връзки, вместо сочените файлове\n"
"  -D, --dired                изход във формат за режима „dired“ на Емакс\n"

#: src/ls.c:5167
msgid ""
"  -f                         do not sort, enable -aU, disable -ls --color\n"
"  -F, --classify             append indicator (one of */=>@|) to entries\n"
"      --file-type            likewise, except do not append '*'\n"
"      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
"                               single-column -1, verbose -l, vertical -C\n"
"      --full-time            like -l --time-style=full-iso\n"
msgstr ""
"  -f                         без подредба, включва „-aU“, изключва „-ls --"
"color“\n"
"  -F, --classify             добавяне на знак за вида на файловете (някой "
"от:\n"
"                             „*“, „/“, „=“, „>“, „@“, „|“)\n"
"      --file-type            същото без добавяне на знака „*“\n"
"      --format=ДУМА          „across“≡„horizontal“≡„-x“ (хоризонтална "
"подредба\n"
"                             по колони),\n"
"                             „vertical“≡„-C“ (вертикална подредба по "
"колони),\n"
"                             „commas“≡„-m“ (хоризонтално изброяване със "
"„,“),\n"
"                             „long“≡„verbose“≡„-l“ (подробен изход),\n"
"                             „single-column“≡„-1“ (по файл на ред).\n"
"      --full-time            същото като „-l --time-style=full-iso“\n"

#: src/ls.c:5175
msgid "  -g                         like -l, but do not list owner\n"
msgstr ""
"  -g                         като „-l“, но без извеждане на собственика\n"

#: src/ls.c:5178
msgid ""
"      --group-directories-first\n"
"                             group directories before files;\n"
"                               can be augmented with a --sort option, but "
"any\n"
"                               use of --sort=none (-U) disables grouping\n"
msgstr ""
"      --group-directories-first\n"
"                             групиране на директориите преди файловете, може "
"да\n"
"                             се комбинира с опция „--sort“, но „--sort=none“ "
"или\n"
"                             „-U“ изключват групирането\n"

#: src/ls.c:5184
msgid ""
"  -G, --no-group             in a long listing, don't print group names\n"
msgstr "  -G, --no-group             без имена на групите при подробен изход\n"

#: src/ls.c:5187
msgid ""
"  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G "
"etc.\n"
"      --si                   likewise, but use powers of 1000 not 1024\n"
msgstr ""
"  -h, --human-readable       с „-l“ и „-s“ извежда размери във формат 1K, "
"234M,\n"
"                             2G и т.н.\n"
"      --si                   същото, но се ползват степени на 10 (100), а не "
"на\n"
"                             2 (1024)\n"

#: src/ls.c:5191
msgid ""
"  -H, --dereference-command-line\n"
"                             follow symbolic links listed on the command "
"line\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             follow each command line symbolic link\n"
"                               that points to a directory\n"
"      --hide=PATTERN         do not list implied entries matching shell "
"PATTERN\n"
"                               (overridden by -a or -A)\n"
msgstr ""
"  -H, --dereference-command-line\n"
"                             следване на символните връзки на командния ред\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             следване на символните връзки на командния "
"ред, \n"
"                             които сочат към директории\n"
"      --hide=ОБРАЗЕЦ         без извеждане на елементите, пасващи на "
"ОБРАЗЕЦ\n"
"                             (пренебрегва се, ако има „-a“ или „-A“)\n"

#: src/ls.c:5201
msgid ""
"      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'\n"
"                               (default if omitted), 'auto', or 'never'\n"
msgstr ""
"      --hyperlink[=КОГАТО]   хипервръзки за имената на файлове, КОГАТО може "
"да\n"
"                             е „always“ (винаги — стандартно), „auto“\n"
"                             (автоматично) или „never“ (никога)\n"

#: src/ls.c:5205
msgid ""
"      --indicator-style=WORD  append indicator with style WORD to entry "
"names:\n"
"                               none (default), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                print the index number of each file\n"
"  -I, --ignore=PATTERN       do not list implied entries matching shell "
"PATTERN\n"
msgstr ""
"      --indicator-style=СТИЛ добавяне на знак в СТИЛа към имената на "
"файловете:\n"
"                             none (стандартно — без), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                извеждане на номера на i-възела на всеки файл\n"
"  -I, --ignore=ШАБЛОН        без извеждане на обектите с имена по ШАБЛОНа\n"

#: src/ls.c:5214
msgid ""
"  -k, --kibibytes            default to 1024-byte blocks for disk usage;\n"
"                               used only with -s and per directory totals\n"
msgstr ""
"  -k, --kibibytes            да се ползват степени на 2 (блокове по 1024 "
"байта)\n"
"                             при извеждане на заетото дисково пространство.\n"
"                             Важи само при „-s“ и обобщенията по директории\n"

#: src/ls.c:5218
msgid ""
"  -l                         use a long listing format\n"
"  -L, --dereference          when showing file information for a symbolic\n"
"                               link, show information for the file the link\n"
"                               references rather than for the link itself\n"
"  -m                         fill width with a comma separated list of "
"entries\n"
msgstr ""
"  -l                         да се ползва формат с подробно изброяване\n"
"  -L, --dereference          при показване на информация за символна връзка\n"
"                             да се показва информация за сочения файл вместо "
"за\n"
"                             самата символна връзка\n"
"  -m                         попълва в широчина с разделени със запетая "
"елементи\n"

#: src/ls.c:5226
msgid ""
"  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
"  -N, --literal              print entry names without quoting\n"
"  -o                         like -l, but do not list group information\n"
"  -p, --indicator-style=slash\n"
"                             append / indicator to directories\n"
msgstr ""
"  -n, --numeric-uid-gid      като „-l“, но с номера за потребител и група\n"
"  -N, --literal              извеждане на неекранирани, дословни имена\n"
"  -o                         като „-l“, но без извеждане на групата\n"
"  -p, --indicator-style=slash\n"
"                             добавяне на знак „/“ към имената на "
"директориите\n"

#: src/ls.c:5233
msgid ""
"  -q, --hide-control-chars   print ? instead of nongraphic characters\n"
"      --show-control-chars   show nongraphic characters as-is (the default,\n"
"                               unless program is 'ls' and output is a "
"terminal)\n"
"  -Q, --quote-name           enclose entry names in double quotes\n"
"      --quoting-style=WORD   use quoting style WORD for entry names:\n"
"                               literal, locale, shell, shell-always,\n"
"                               shell-escape, shell-escape-always, c, escape\n"
"                               (overrides QUOTING_STYLE environment "
"variable)\n"
msgstr ""
"  -q, --hide-control-chars   заместване на неграфичните знаци с „?“\n"
"      --show-control-chars   извеждане на неграфичните знаци както са си\n"
"                             (стандартно, освен ако програмата е „ls“ и\n"
"                             изходът е терминал)\n"
"  -Q, --quote-name           заграждане на имената на елементите с „\"“\n"
"      --quoting-style=СТИЛ   СТИЛ на екраниране на имената на елементите —\n"
"                             с превес пред указаното от променливата на\n"
"                             средата „QUOTING_STYLE“:\n"
"                             ⁃ „literal“ (дословно — без екраниране);\n"
"                             ⁃ „locale“ (цитиране с кавички от локала);\n"
"                             ⁃ „shell“ (цитиране при наличие на специални\n"
"                               знаци на обвивката);\n"
"                             ⁃ „shell-always“ (цитиране дори и без нужда);\n"
"                             ⁃ „c“ (цитиране като литерали на C и\n"
"                               обхващащи „\"“);\n"
"                             ⁃ „escape“ (като литерали на C без обхващащи "
"„\"“).\n"

#: src/ls.c:5244
msgid ""
"  -r, --reverse              reverse order while sorting\n"
"  -R, --recursive            list subdirectories recursively\n"
"  -s, --size                 print the allocated size of each file, in "
"blocks\n"
msgstr ""
"  -r, --reverse              подредба в обратен ред\n"
"  -R, --recursive            рекурсивно извеждане на поддиректориите\n"
"  -s, --size                 извеждане на размера на всеки файл в блокове\n"

#: src/ls.c:5249
msgid ""
"  -S                         sort by file size, largest first\n"
"      --sort=WORD            sort by WORD instead of name: none (-U), size (-"
"S),\n"
"                               time (-t), version (-v), extension (-X)\n"
"      --time=WORD            with -l, show time as WORD instead of default\n"
"                               modification time: atime or access or use (-"
"u);\n"
"                               ctime or status (-c); also use specified "
"time\n"
"                               as sort key if --sort=time (newest first)\n"
msgstr ""
"  -S                         подредба според размера, най-големите отпред\n"
"      --sort=ДУМА            подредба според ДУМАта: „size“≡„-S“, „time“≡„-"
"t“\n"
"                             „none“≡„-U“, „version“≡„-v“, „extension“≡„-X“\n"
"      --time=ВИД_ВРЕМЕ       с „-l“ показва този ВИД_ВРЕМЕ вместо времето "
"на\n"
"                             промяна.  ВИДът_ВРЕМЕ може да е „atime“/"
"„access“/\n"
"                             „use“≡„-u“ (достъп) или „ctime“/„status“≡„-c“\n"
"                             (създаване).  Ако е дадена и опцията „--"
"sort=time“,\n"
"                             се подрежда по съответното време (най-новите —\n"
"                             отпред)\n"

#: src/ls.c:5260
msgid ""
"      --time-style=TIME_STYLE  time/date format with -l; see TIME_STYLE "
"below\n"
msgstr ""
"      --time-style=ФОРМАТ_ЗА_ВРЕМЕТО\n"
"                               ФОРМАТ_ЗА_ВРЕМЕТО за опцията „-l“, вижте по-"
"долу\n"

#: src/ls.c:5263
msgid ""
"  -t                         sort by modification time, newest first\n"
"  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"
msgstr ""
"  -t                         подредба по времето на промяна от нови към "
"стари\n"
"  -T, --tabsize=РАЗМЕР       табулаторите са с този РАЗМЕР вместо 8 "
"интервала\n"

#: src/ls.c:5267
msgid ""
"  -u                         with -lt: sort by, and show, access time;\n"
"                               with -l: show access time and sort by name;\n"
"                               otherwise: sort by access time, newest first\n"
"  -U                         do not sort; list entries in directory order\n"
"  -v                         natural sort of (version) numbers within text\n"
msgstr ""
"  -u                         с „-lt“: показване и подредба според времето "
"на\n"
"                             достъп;\n"
"                             с „-l“: показване на времето, но подредба по "
"името;\n"
"                             иначе: подредба според времето, най-новите — "
"отпред.\n"
"  -U                         без подредба — както е в директорията\n"
"  -v                         подредба с тълкуване на имената като версии\n"

#: src/ls.c:5274
msgid ""
"  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
"  -x                         list entries by lines instead of by columns\n"
"  -X                         sort alphabetically by entry extension\n"
"  -Z, --context              print any security context of each file\n"
"  -1                         list one file per line.  Avoid '\\n' with -q or "
"-b\n"
msgstr ""
"  -w, --width=КОЛОНИ         извеждане на този брой КОЛОНИ.  0 — означава, "
"че\n"
"                             няма ограничения\n"
"  -x                         извеждане на елементите по редове, а не в "
"стълбове\n"
"  -X                         подредба в азбучен ред според разширението\n"
"  -Z, --context              извеждане на контекста на сигурността на "
"обектите\n"
"  -1                         извеждане по един файл на ред\n"

#: src/ls.c:5285
msgid ""
"\n"
"The TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.\n"
"FORMAT is interpreted like in date(1).  If FORMAT is "
"FORMAT1<newline>FORMAT2,\n"
"then FORMAT1 applies to non-recent files and FORMAT2 to recent files.\n"
"TIME_STYLE prefixed with 'posix-' takes effect only outside the POSIX "
"locale.\n"
"Also the TIME_STYLE environment variable sets the default style to use.\n"
msgstr ""
"\n"
"Аргументът ФОРМАТ_НА_ВРЕМЕТО може да е „full-iso“, “long-iso“, „iso“, "
"„locale“\n"
"или “+ФОРМАТ“.  ФОРМАТът е същият както за командата „date(1)“.  Ако "
"ФОРМАТът\n"
"съдържа нов ред: ФОРМАТ_1<нов ред>ФОРМАТ_2, то вторият формат се отнася за\n"
"скорошните файлове, а първият — за всички останали.  Ако "
"ФОРМАТът_НА_ВРЕМЕТО\n"
"започва с „posix-“, то той се ползва само извън локала по POSIX.  "
"Променливата\n"
"на средата „TIME_STYLE“ задава стандартния стил.\n"

#: src/ls.c:5293
msgid ""
"\n"
"Using color to distinguish file types is disabled both by default and\n"
"with --color=never.  With --color=auto, ls emits color codes only when\n"
"standard output is connected to a terminal.  The LS_COLORS environment\n"
"variable can change the settings.  Use the dircolors command to set it.\n"
msgstr ""
"\n"
"Използването на цвят за разграничаване на файловете по вид стандартно е\n"
"изключено както и при задаването на опцията „--color=never“.  При задаване\n"
"на „--color=auto“ командата „ls“ извежда кодове за цвят, само когато "
"изходът\n"
"се извежда на терминал.  Променливата на средата „LS_COLORS“ позволява\n"
"допълнителни настройки.  Може да я зададете с командата „dircolors“.\n"

#: src/ls.c:5300
msgid ""
"\n"
"Exit status:\n"
" 0  if OK,\n"
" 1  if minor problems (e.g., cannot access subdirectory),\n"
" 2  if serious trouble (e.g., cannot access command-line argument).\n"
msgstr ""
"\n"
"Изходен код:\n"
" 0  — ако всичко е наред;\n"
" 1  — при леки проблеми (напр. няма достъп до поддиректория);\n"
" 2  — при сериозни проблеми (напр. няма достъп до аргумент на командния "
"ред).\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:108
msgid "Samuel Neves"
msgstr "Samuel Neves"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:111 src/seq.c:43
msgid "Ulrich Drepper"
msgstr "Ulrich Drepper"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:112
msgid "Scott Miller"
msgstr "Scott Miller"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:113
msgid "David Madore"
msgstr "David Madore"

#: src/md5sum.c:229
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"Print or check %s (%d-bit) checksums.\n"
msgstr ""
"Употреба: %s [ОПЦИЯ] [ФАЙЛ]…\n"
"Извеждане или проверка на контролни суми %s (%d-битови).\n"

#: src/md5sum.c:239
msgid ""
"\n"
"  -b, --binary         read in binary mode (default unless reading tty "
"stdin)\n"
msgstr ""
"\n"
"-b, --binary   четене в двоичен режим (стандартно, освен при стандартен "
"вход\n"
"                 от терминал)\n"

#: src/md5sum.c:244
msgid ""
"\n"
"  -b, --binary         read in binary mode\n"
msgstr ""
"\n"
"  -b, --binary   четене в двоичен режим\n"

#: src/md5sum.c:249
#, c-format
msgid "  -c, --check          read %s sums from the FILEs and check them\n"
msgstr ""
"  -c, --check          изчитане на контролните суми „%s“ от ФАЙЛовете и\n"
"                       проверка\n"

#: src/md5sum.c:253
msgid ""
"  -l, --length         digest length in bits; must not exceed the maximum "
"for\n"
"                       the blake2 algorithm and must be a multiple of 8\n"
msgstr ""
"  -l, --length         дължина на контролната сума в битове — трябва да е "
"кратна\n"
"                       на 8 и да е по-малка от максимума за алгоритъма "
"„blake2“\n"

#: src/md5sum.c:258
msgid "      --tag            create a BSD-style checksum\n"
msgstr "      --tag            създаване на контролна сума в стила на BSD\n"

#: src/md5sum.c:262
msgid ""
"  -t, --text           read in text mode (default if reading tty stdin)\n"
msgstr ""
"  -t, --text           четене в текстов режим (при стандартен вход от "
"терминал)\n"

#: src/md5sum.c:266
msgid "  -t, --text           read in text mode (default)\n"
msgstr "  -t, --text           четене в текстов режим (стандартно)\n"

#: src/md5sum.c:269
msgid ""
"  -z, --zero           end each output line with NUL, not newline,\n"
"                       and disable file name escaping\n"
msgstr ""
"  -z, --zero           завършване на всеки ред с нулев байт, а не нов ред,\n"
"                       и без екраниране на знаците в имената\n"

#: src/md5sum.c:273
msgid ""
"\n"
"The following five options are useful only when verifying checksums:\n"
"      --ignore-missing  don't fail or report status for missing files\n"
"      --quiet          don't print OK for each successfully verified file\n"
"      --status         don't output anything, status code shows success\n"
"      --strict         exit non-zero for improperly formatted checksum "
"lines\n"
"  -w, --warn           warn about improperly formatted checksum lines\n"
"\n"
msgstr ""
"\n"
"Следните две опции са полезни само при проверяване на контролни суми:\n"
"      --ignore-missing  без съобщения за липсващи файлове\n"
"      --quiet           без съобщения за успешно проверен файл\n"
"      --status          без съобщения, успехът се определя според кода за "
"изход\n"
"      --strict          изход при неправилно форматирани редове със суми\n"
"  -w, --warn            съобщения при неправилно форматирани редове със "
"суми\n"

#: src/md5sum.c:285
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print a\n"
"line with checksum, a space, a character indicating input mode ('*' for "
"binary,\n"
"' ' for text or where binary is insignificant), and name for each FILE.\n"
msgstr ""
"\n"
"Сумите се изчисляват така, както е посочено в %s.  При проверка входът\n"
"трябва да бъде предишен изход от тази програма.  По подразбиране се извежда "
"ред\n"
"с контролна сума, знак посочващ типа („*“ за двоичен, „ “ за текстов или "
"когато\n"
"това няма значение) и името на всеки ФАЙЛ.\n"

#: src/md5sum.c:697
#, c-format
msgid "%s: too many checksum lines"
msgstr "%s: твърде много редове за контролни суми"

#: src/md5sum.c:720
#, c-format
msgid "%s: %<PRIuMAX>: improperly formatted %s checksum line"
msgstr "%s: %<PRIuMAX>: неправилно форматиран ред с контролна сума „%s“"

#: src/md5sum.c:752
msgid "FAILED open or read"
msgstr "НЕУСПЕШНО изпълнение на „open“ или „read“"

#: src/md5sum.c:790
msgid "FAILED"
msgstr "НЕУСПЕХ"

#: src/md5sum.c:792
msgid "OK"
msgstr "УСПЕХ"

#: src/md5sum.c:816
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s: не са открити правилно форматирани %s редове с контролни суми"

#: src/md5sum.c:826
#, c-format
msgid "WARNING: %<PRIuMAX> line is improperly formatted"
msgid_plural "WARNING: %<PRIuMAX> lines are improperly formatted"
msgstr[0] ""
"ПРЕДУПРЕЖДЕНИЕ: ред %<PRIuMAX> е неправилно форматиран за контролна сума"
msgstr[1] ""
"ПРЕДУПРЕЖДЕНИЕ: %<PRIuMAX> реда са неправилно форматирани за контролна сума"

#: src/md5sum.c:834
#, c-format
msgid "WARNING: %<PRIuMAX> listed file could not be read"
msgid_plural "WARNING: %<PRIuMAX> listed files could not be read"
msgstr[0] "ПРЕДУПРЕЖДЕНИЕ: %<PRIuMAX>-ят изброен файл не може да бъде прочетен"
msgstr[1] ""
"ПРЕДУПРЕЖДЕНИЕ: %<PRIuMAX> изброени файла не могат да бъде прочетени"

#: src/md5sum.c:842
#, c-format
msgid "WARNING: %<PRIuMAX> computed checksum did NOT match"
msgid_plural "WARNING: %<PRIuMAX> computed checksums did NOT match"
msgstr[0] "ВНИМАНИЕ: %<PRIuMAX> пресметната контролна сума НЕ пасва"
msgstr[1] "ВНИМАНИЕ: %<PRIuMAX> пресметнати контролни суми НЕ пасват"

#: src/md5sum.c:848
#, c-format
msgid "%s: no file was verified"
msgstr "%s: файлът не е проверен"

#: src/md5sum.c:898
msgid "invalid length"
msgstr "неправилна дължина"

#: src/md5sum.c:902 src/md5sum.c:954
#, c-format
msgid "invalid length: %s"
msgstr "неправилна дължина: %s"

#: src/md5sum.c:903
msgid "length is not a multiple of 8"
msgstr "размерът не е кратен на 8"

#: src/md5sum.c:956
#, c-format
msgid "maximum digest length for %s is %<PRIuMAX> bits"
msgstr "максималната дължина на контролната сума за „%s“ е %<PRIuMAX> бита"

#: src/md5sum.c:974
#, c-format
msgid "--tag does not support --text mode"
msgstr "опцията „--tag“ не поддържа режима на „--text“"

#: src/md5sum.c:980
#, c-format
msgid "the --zero option is not supported when verifying checksums"
msgstr "опцията „--zero“ не се поддържа при проверката на контролни суми"

#: src/md5sum.c:987
#, c-format
msgid "the --tag option is meaningless when verifying checksums"
msgstr "опцията „--tag“ е безсмислена при проверка на контролни суми"

#: src/md5sum.c:994
#, c-format
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr ""
"опциите „--binary“ и „--text“ са безсмислени при проверка на контролни суми"

#: src/md5sum.c:1002
#, c-format
msgid "the --ignore-missing option is meaningful only when verifying checksums"
msgstr ""
"опцията „--ignore-missing“ е смислена само при проверка на контролни суми"

#: src/md5sum.c:1010
#, c-format
msgid "the --status option is meaningful only when verifying checksums"
msgstr "опцията „--status“ е смислена само при проверка на контролни суми"

#: src/md5sum.c:1017
#, c-format
msgid "the --warn option is meaningful only when verifying checksums"
msgstr "опцията „--warn“ е смислена само при проверка на контролни суми"

#: src/md5sum.c:1024
#, c-format
msgid "the --quiet option is meaningful only when verifying checksums"
msgstr "опцията „--quiet“ е смислена само при проверка на контролни суми"

#: src/md5sum.c:1031
#, c-format
msgid "the --strict option is meaningful only when verifying checksums"
msgstr "опцията „--strict“ е смислена само при проверка на контролни суми"

#: src/mkdir.c:59 src/rmdir.c:163
#, c-format
msgid "Usage: %s [OPTION]... DIRECTORY...\n"
msgstr "Употреба: %s [ОПЦИЯ]… ДИРЕКТОРИЯ…\n"

#: src/mkdir.c:60
msgid "Create the DIRECTORY(ies), if they do not already exist.\n"
msgstr ""
"Създаване на ДИРЕКТОРИЯ(и), ако вече не са създадени.\n"
"\n"

#: src/mkdir.c:66
msgid ""
"  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\n"
"  -p, --parents     no error if existing, make parent directories as needed\n"
"  -v, --verbose     print a message for each created directory\n"
msgstr ""
"  -m, --mode=РЕЖИМ  задава режим за достъп (като chmod), not a=rwx - umask\n"
"  -p, --parents     създава и родителските каталози, без грешка за "
"съществуващи\n"
"  -v, --verbose     извежда съобщение за всеки създаден каталог\n"

#: src/mkdir.c:71
msgid ""
"  -Z                   set SELinux security context of each created "
"directory\n"
"                         to the default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""
"  -Z                   задаване на стандартен за вида контекст на сигурност "
"за\n"
"                       SELinux или SMACK на всяка създадена директория\n"
"      --context[=КОНТЕКСТ]\n"
"                        като „-Z“, но при задаването се прилага този "
"КОНТЕКСТ\n"
"                        за SELinux или SMACK\n"

#: src/mkdir.c:221
#, c-format
msgid "created directory %s"
msgstr "създаден е каталог %s"

#: src/mkdir.c:239 src/mkfifo.c:117 src/mknod.c:134
#, c-format
msgid ""
"warning: ignoring --context; it requires an SELinux/SMACK-enabled kernel"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: опцията „--context“ се прескача, защото изисква ядро с "
"поддръжката на SELinux или SMACK"

#: src/mkfifo.c:54 src/pathchk.c:88
#, c-format
msgid "Usage: %s [OPTION]... NAME...\n"
msgstr "Употреба: %s [ОПЦИЯ]… ИМЕ…\n"

#: src/mkfifo.c:55
msgid "Create named pipes (FIFOs) with the given NAMEs.\n"
msgstr "Създаване на именувани канали (FIFO) с посочените ИМЕна.\n"

#: src/mkfifo.c:61 src/mknod.c:63
msgid ""
"  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n"
msgstr ""
"  -m, --mode=РЕЖИМ  задаване на РЕЖИМ за достъп, в допълнение към „a=rw“\n"

#: src/mkfifo.c:64 src/mknod.c:66
msgid ""
"  -Z                   set the SELinux security context to default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""
"  -Z                   задаване на стандартен за вида контекст на сигурност "
"за\n"
"                       SELinux или SMACK\n"
"      --context[=КОНТЕКСТ]\n"
"                        като „-Z“, но при задаването се прилага този "
"КОНТЕКСТ\n"
"                        за SELinux или SMACK\n"

#: src/mkfifo.c:154 src/mknod.c:151
msgid "invalid mode"
msgstr "неправилен режим за достъп"

#: src/mkfifo.c:161 src/mknod.c:158
msgid "mode must specify only file permission bits"
msgstr "режимът трябва да определя само битовете за достъп до файла"

#: src/mkfifo.c:175 src/mknod.c:271
#, c-format
msgid "cannot set permissions of %s"
msgstr "правата за достъп до „%s“ не може да се зададат"

#: src/mknod.c:55
#, c-format
msgid "Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\n"
msgstr "Употреба: %s [ОПЦИЯ]… ИМЕ ВИД [ГОЛЯМ МАЛЪК]\n"

#: src/mknod.c:57
msgid "Create the special file NAME of the given TYPE.\n"
msgstr "Създаване на специален файл с посоченото ИМЕ и дадения ВИД.\n"

#: src/mknod.c:73
msgid ""
"\n"
"Both MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\n"
"must be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\n"
"it is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\n"
"otherwise, as decimal.  TYPE may be:\n"
msgstr ""
"\n"
"Както ГОЛЯМ, така и МАЛЪК трябва да се посочат, ако ВИДът е „b“, „c“ или "
"„u“, и\n"
"трябва да се пропуснат, ако той е „p“.  Ако ГОЛЯМ или МАЛЪК започва с 0x или "
"0X,\n"
"номерът се интерпретира като шестнадесетичен, ако започва с 0 — като "
"осмичен,\n"
"а в останалите случаи — като десетичен.  ВИДът може да е:\n"

#: src/mknod.c:80
msgid ""
"\n"
"  b      create a block (buffered) special file\n"
"  c, u   create a character (unbuffered) special file\n"
"  p      create a FIFO\n"
msgstr ""
"\n"
"  b      блоков (буфериран) специален файл\n"
"  c, u   знаков (небуфериран) специален файл\n"
"  p      именуван канал\n"

#: src/mknod.c:176
msgid "Special files require major and minor device numbers."
msgstr ""
"При създаване на специални файлове трябва да се посочат и голям, и малък "
"номер на устройство"

#: src/mknod.c:186
msgid "Fifos do not have major and minor device numbers."
msgstr "Именуваните канали нямат малък и голям номер на устройство."

#: src/mknod.c:211
msgid "block special files not supported"
msgstr "работа с блокови специални файлове не се поддържа "

#: src/mknod.c:220
msgid "character special files not supported"
msgstr "работа със знакови специални файлове не се поддържа"

#: src/mknod.c:236
#, c-format
msgid "invalid major device number %s"
msgstr "грешен голям номер на устройство „%s“"

#: src/mknod.c:241
#, c-format
msgid "invalid minor device number %s"
msgstr "грешен малък номер на устройство „%s“"

#: src/mknod.c:246
#, c-format
msgid "invalid device %s %s"
msgstr "неправилно устройство „%s %s“"

#: src/mknod.c:266
#, c-format
msgid "invalid device type %s"
msgstr "неправилен вид на устройство „%s“"

#. This is a proper name. See the gettext manual, section Names.
#: src/mktemp.c:37
msgid "Eric Blake"
msgstr "Eric Blake"

#: src/mktemp.c:67
#, c-format
msgid "Usage: %s [OPTION]... [TEMPLATE]\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ШАБЛОН]…\n"

#: src/mktemp.c:68
msgid ""
"Create a temporary file or directory, safely, and print its name.\n"
"TEMPLATE must contain at least 3 consecutive 'X's in last component.\n"
"If TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.\n"
msgstr ""

#: src/mktemp.c:73
msgid ""
"Files are created u+rw, and directories u+rwx, minus umask restrictions.\n"
msgstr ""

#: src/mktemp.c:77
msgid ""
"  -d, --directory     create a directory, not a file\n"
"  -u, --dry-run       do not create anything; merely print a name (unsafe)\n"
"  -q, --quiet         suppress diagnostics about file/dir-creation failure\n"
msgstr ""

#: src/mktemp.c:82
msgid ""
"      --suffix=SUFF   append SUFF to TEMPLATE; SUFF must not contain a "
"slash.\n"
"                        This option is implied if TEMPLATE does not end in "
"X\n"
msgstr ""

#: src/mktemp.c:86
msgid ""
"  -p DIR, --tmpdir[=DIR]  interpret TEMPLATE relative to DIR; if DIR is not\n"
"                        specified, use $TMPDIR if set, else /tmp.  With\n"
"                        this option, TEMPLATE must not be an absolute name;\n"
"                        unlike with -t, TEMPLATE may contain slashes, but\n"
"                        mktemp creates only the final component\n"
msgstr ""

#: src/mktemp.c:93
msgid ""
"  -t                  interpret TEMPLATE as a single file name component,\n"
"                        relative to a directory: $TMPDIR, if set; else the\n"
"                        directory specified via -p; else /tmp [deprecated]\n"
msgstr ""

#: src/mktemp.c:211
#, fuzzy, c-format
msgid "too many templates"
msgstr "прекалено много аргументи"

#: src/mktemp.c:231
#, c-format
msgid "with --suffix, template %s must end in X"
msgstr ""

#: src/mktemp.c:256 src/split.c:1345
#, c-format
msgid "invalid suffix %s, contains directory separator"
msgstr "неправилен суфикс — „%s“ съдържа разделител на директории"

#: src/mktemp.c:261
#, c-format
msgid "too few X's in template %s"
msgstr ""

#: src/mktemp.c:277
#, c-format
msgid "invalid template, %s, contains directory separator"
msgstr ""

#: src/mktemp.c:291
#, c-format
msgid "invalid template, %s; with --tmpdir, it may not be absolute"
msgstr ""

#: src/mktemp.c:312
#, fuzzy, c-format
msgid "failed to create directory via template %s"
msgstr "Не може да се създаде временна директория по шаблона %s"

#: src/mktemp.c:323
#, fuzzy, c-format
msgid "failed to create file via template %s"
msgstr "променливата на средата „%s“ не може да се зададе"

#: src/mv.c:298
msgid "Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n"
msgstr ""
"Преименуване на ИЗТОЧНИК като ЦЕЛ или преместване на ИЗТОЧНИците в "
"ДИРЕКТОРИЯта.\n"

#: src/mv.c:304
msgid ""
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"  -f, --force                  do not prompt before overwriting\n"
"  -i, --interactive            prompt before overwrite\n"
"  -n, --no-clobber             do not overwrite an existing file\n"
"If you specify more than one of -i, -f, -n, only the final one takes "
"effect.\n"
msgstr ""
"      --backup[=МЕТОД]       резервно копие на съществуващи целеви файлове\n"
"  -b                         като „--backup“, но без аргумент\n"
"  -f, --force                без питане преди заместване на файлове\n"
"  -i, --interactive          с питане преди заместване на файлове\n"
"  -n, --no-clobber           без презаписване на съществуващи файлове\n"
"При посочване на повече от една от опциите „-i“, „-f“, „-n“ се взема "
"предвид\n"
"последната.\n"

#: src/mv.c:313
msgid ""
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
msgstr ""
"      --strip-trailing-slashes отстраняване на крайните наклонени черти от\n"
"                               всички ЦЕЛи\n"
"  -S, --suffix=СУФИКС          суфикс за резервните копия\n"

#: src/mv.c:318
msgid ""
"  -t, --target-directory=DIRECTORY  move all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
"  -u, --update                 move only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -Z, --context                set SELinux security context of destination\n"
"                                 file to default type\n"
msgstr ""
"      --target-directory=ДИР   преместване на всички ИЗТОЧНИци в "
"ДИРекторията\n"
"  -T, --no-target-directory    обработка на ЦЕЛта като обикновен файл\n"
"  -u, --update                 преместване, само ако ИЗТОЧНИКът е по-нов от\n"
"                               целевия файл, или ако целевият файл липсва\n"
"  -v, --verbose                извеждане на действията\n"
"  -Z, --context                задаване на стандартен контекст за сигурност\n"
"                               на ЦЕЛта\n"

#: src/nice.c:73
#, c-format
msgid "Usage: %s [OPTION] [COMMAND [ARG]...]\n"
msgstr "Употреба: %s [ОПЦИЯ] [КОМАНДА [АРГУМЕНТ]…]\n"

#: src/nice.c:74
#, c-format
msgid ""
"Run COMMAND with an adjusted niceness, which affects process scheduling.\n"
"With no COMMAND, print the current niceness.  Niceness values range from\n"
"%d (most favorable to the process) to %d (least favorable to the process).\n"
msgstr ""
"Изпълняване на КОМАНДАта със зададената стойност на „nice“, което принципно "
"влияе\n"
"на диспечера на задачите на операционната система.  Без КОМАНДА извежда "
"текущата\n"
"стойност на „nice“.  Диапазонът на „nice“ е от %d (най-голямо предимство за\n"
"процеса) до %d (най-малко предимство).\n"

#: src/nice.c:83
msgid "  -n, --adjustment=N   add integer N to the niceness (default 10)\n"
msgstr ""
"  -n, --adjustment=N   добавяне на N към стойността на nice (по подразбиране "
"10)\n"

#: src/nice.c:173
#, c-format
msgid "invalid adjustment %s"
msgstr "неправилна настройка: %s"

#: src/nice.c:182
#, c-format
msgid "a command must be given with an adjustment"
msgstr "трябва да зададете команда заедно с корекцията"

#: src/nice.c:189 src/nice.c:200
msgid "cannot get niceness"
msgstr "неуспешно получаване на стойността на „nice“"

#: src/nice.c:206
#, c-format
msgid "cannot set niceness"
msgstr "неуспешно задаване на стойността на „nice“"

#. This is a proper name. See the gettext manual, section Names.
#: src/nl.c:41
msgid "Scott Bartram"
msgstr "Scott Bartram"

#: src/nl.c:180
#, fuzzy
msgid "Write each FILE to standard output, with line numbers added.\n"
msgstr ""
"Извежда всеки от ФАЙЛовете на стандартния изход с добавени номера на "
"редовете.\n"
"Без ФАЙЛ или ако ФАЙЛ е - се чете от стандартния вход.\n"
"\n"

#: src/nl.c:187
#, fuzzy
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for logical page delimiters\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"  -b, --body-numbering=СТИЛ       ползва СТИЛ при номериране редовете от "
"тялото\n"
"  -d, --section-delimiter=CC      CC да е разделител между логическите "
"страници\n"
"  -f, --footer-numbering=СТИЛ     ползва СТИЛ при номериране долния "
"колонтитул\n"

#: src/nl.c:192
#, fuzzy
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --line-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers for each "
"section\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""
"  -h, --header-numbering=СТИЛ     ползва СТИЛ при номериране горния "
"колонтитул\n"
"  -i, --page-increment=РАЗЛИКА    с колко нараства номера на всеки следващ "
"ред\n"
"  -l, --join-blank-lines=БРОЙ     номерира от БРОЙ празни реда само "
"последния\n"
"  -n, --number-format=ФОРМАТ      вмъква номерата на редовете според ФОРМАТ\n"
"  -p, --no-renumber               не брои отначало при нова логическа "
"страница\n"
"  -s, --number-separator=НИЗ      добавя НИЗ след всеки номер на ред\n"

#: src/nl.c:200
#, fuzzy
msgid ""
"  -v, --starting-line-number=NUMBER  first line number for each section\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""
"  -v, --first-page=НОМЕР          номер на първия ред от логическите "
"страници\n"
"  -w, --number-width=БРОЙ         ползва БРОЙ стълбове за номерата на "
"редовете\n"

#: src/nl.c:206
#, fuzzy
msgid ""
"\n"
"Default options are: -bt -d'\\:' -fn -hn -i1 -l1 -n'rn' -s<TAB> -v1 -w6\n"
"\n"
"CC are two delimiter characters used to construct logical page delimiters;\n"
"a missing second character implies ':'.\n"
msgstr ""
"\n"
"По подразбиране се използва -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC са\n"
"двата символа, използвани за разделяне на логическите страници.  Ако "
"липсва,\n"
"по подразбиране вторият символ е :.  Използвайте \\\\ за \\.  СТИЛ е едно "
"от:\n"

#: src/nl.c:213
#, fuzzy
msgid ""
"\n"
"STYLE is one of:\n"
"\n"
"  a      number all lines\n"
"  t      number only nonempty lines\n"
"  n      number no lines\n"
"  pBRE   number only lines that contain a match for the basic regular\n"
"         expression, BRE\n"
msgstr ""
"\n"
"  a         за да се номерират всички редове\n"
"  t         за да се номерират само непразните редове\n"
"  n         за да не се номерира никой ред\n"
"  pРЕГИЗР   за да се номерират само редове, съдържащи съответствие на "
"РЕГИЗР\n"
"\n"
"ФОРМАТ е едно от:\n"
"\n"
"  ln   за ляво подравняване, без предхождащи нули\n"
"  rn   за дясно подравняване, без предхождащи нули\n"
"  rz   за дясно подравняване, с предхождащи нули\n"
"\n"

#: src/nl.c:223
msgid ""
"\n"
"FORMAT is one of:\n"
"\n"
"  ln     left justified, no leading zeros\n"
"  rn     right justified, no leading zeros\n"
"  rz     right justified, leading zeros\n"
"\n"
msgstr ""

#: src/nl.c:284
msgid "line number overflow"
msgstr "препълване на номера на ред"

#: src/nl.c:488
#, c-format
msgid "invalid header numbering style: %s"
msgstr "неправилен формат за номериране на горен колонтитул: %s"

#: src/nl.c:496
#, c-format
msgid "invalid body numbering style: %s"
msgstr "неправилен формат за номериране: %s"

#: src/nl.c:504
#, c-format
msgid "invalid footer numbering style: %s"
msgstr "неправилен формат за номериране на долен колонтитул: %s"

#: src/nl.c:511
#, fuzzy
msgid "invalid starting line number"
msgstr "неправилен номер на сигнал"

#: src/nl.c:516
#, fuzzy
msgid "invalid line number increment"
msgstr "Неправилен номер на i-възел"

#: src/nl.c:523
#, fuzzy
msgid "invalid line number of blank lines"
msgstr "Неправилен брой елементи"

#: src/nl.c:530
#, fuzzy
msgid "invalid line number field width"
msgstr "Неправилен номер на i-възел"

#: src/nl.c:541
#, c-format
msgid "invalid line numbering format: %s"
msgstr "неправилен формат за номериране на редове: %s"

#: src/nohup.c:50
#, c-format
msgid ""
"Usage: %s COMMAND [ARG]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s КОМАНДА [АРГУМЕНТ]…\n"
"     или: %s ОПЦИЯ\n"

#: src/nohup.c:56
msgid ""
"Run COMMAND, ignoring hangup signals.\n"
"\n"
msgstr ""
"Изпълнение на КОМАНДАта със заглушаване на сигналите за край на връзката "
"(SIGHUP).\n"
"\n"

#: src/nohup.c:62
#, c-format
msgid ""
"\n"
"If standard input is a terminal, redirect it from an unreadable file.\n"
"If standard output is a terminal, append output to 'nohup.out' if possible,\n"
"'$HOME/nohup.out' otherwise.\n"
"If standard error is a terminal, redirect it to standard output.\n"
"To save output to FILE, use '%s COMMAND > FILE'.\n"
msgstr ""
"\n"
"Ако стандартният вход е на терминал, той се пренасочва от нечетим файл.\n"
"Ако стандартният изход е на терминал, той се пренасочва и добавя по "
"възможност\n"
"към файла „nohup.out“.  Ако това е невъзможно, се ползва „$HOME/nohup.out“.\n"
"Ако стандартната грешка е на терминал, той се пренасочва към стандартния "
"изход.\n"
"За запазване на изхода в определен ФАЙЛ ползвайте „%s КОМАНДА > ФАЙЛ“.\n"

#: src/nohup.c:123
#, c-format
msgid "failed to render standard input unusable"
msgstr "неуспешно задаване на стандартния изход като неизползваем"

#: src/nohup.c:125
#, c-format
msgid "ignoring input"
msgstr "входът се пренебрегва"

#: src/nohup.c:169
#, c-format
msgid "ignoring input and appending output to %s"
msgstr "входът се пренебрегва, а изходът се насочва към „%s“"

#: src/nohup.c:170
#, c-format
msgid "appending output to %s"
msgstr "добавяне на изхода към „%s“"

#: src/nohup.c:188
#, c-format
msgid "ignoring input and redirecting stderr to stdout"
msgstr ""
"входът се пренебрегва, а стандартната грешка се пренасочва към стандартния "
"изход"

#: src/nohup.c:189
#, c-format
msgid "redirecting stderr to stdout"
msgstr "пренасочване на стандартната грешка към стандартния изход"

#: src/nohup.c:193
#, c-format
msgid "failed to redirect standard error"
msgstr "неуспешно пренасочване на стандартната грешка"

#. This is a proper name. See the gettext manual, section Names.
#: src/nproc.c:33 src/sync.c:34
msgid "Giuseppe Scrivano"
msgstr "Giuseppe Scrivano"

#: src/nproc.c:57 src/pwd.c:57 src/tty.c:65 src/uname.c:121 src/whoami.c:44
#, c-format
msgid "Usage: %s [OPTION]...\n"
msgstr "Употреба: %s [ОПЦИЯ]…\n"

#: src/nproc.c:58
msgid ""
"Print the number of processing units available to the current process,\n"
"which may be less than the number of online processors\n"
"\n"
msgstr ""
"Извеждане на броя процесорни ядра достъпни за текущия процес,\n"
"той може да е по-малък от общия брой работещи ядра.\n"
"\n"

#: src/nproc.c:63
msgid ""
"      --all      print the number of installed processors\n"
"      --ignore=N  if possible, exclude N processing units\n"
msgstr ""
"      --all      извеждане на броя на наличните ядра\n"
"      --ignore=БРОЙ\n"
"                 по възможност този БРОЙ ядра се пренебрегват\n"

#: src/numfmt.c:694
#, fuzzy, c-format
msgid "value too large to be converted: %s"
msgstr "входните данни са прекалено големи, за да бъдат преброени"

#: src/numfmt.c:698
#, fuzzy, c-format
msgid "invalid number: %s"
msgstr "грешно число"

#: src/numfmt.c:702
#, c-format
msgid "rejecting suffix in input: %s (consider using --from)"
msgstr ""

#: src/numfmt.c:706
#, fuzzy, c-format
msgid "invalid suffix in input: %s"
msgstr "неправилен суфикс в аргумента „%3$s“ за опцията „%1$s%2$s“"

#: src/numfmt.c:710
#, c-format
msgid "missing 'i' suffix in input: %s (e.g Ki/Mi/Gi)"
msgstr ""

#: src/numfmt.c:757 src/numfmt.c:809
#, fuzzy, c-format
msgid "failed to prepare value '%Lf' for printing"
msgstr "%s: не може да се отвори в режим за писане"

#: src/numfmt.c:858
#, fuzzy, c-format
msgid "invalid unit size: %s"
msgstr "Неправилен размер: %s"

#: src/numfmt.c:884
#, fuzzy, c-format
msgid "Usage: %s [OPTION]... [NUMBER]...\n"
msgstr "Употреба: %s [ОПЦИЯ]… ФАЙЛ…\n"

#: src/numfmt.c:887
msgid ""
"Reformat NUMBER(s), or the numbers from standard input if none are "
"specified.\n"
msgstr ""

#: src/numfmt.c:891
#, fuzzy
msgid "      --debug          print warnings about invalid input\n"
msgstr ""
"      --debug\n"
"                 подробна информация за изпълнението\n"

#: src/numfmt.c:894
msgid ""
"  -d, --delimiter=X    use X instead of whitespace for field delimiter\n"
msgstr ""

#: src/numfmt.c:897
msgid ""
"      --field=FIELDS   replace the numbers in these input fields "
"(default=1)\n"
"                         see FIELDS below\n"
msgstr ""

#: src/numfmt.c:901
msgid ""
"      --format=FORMAT  use printf style floating-point FORMAT;\n"
"                         see FORMAT below for details\n"
msgstr ""

#: src/numfmt.c:905
msgid ""
"      --from=UNIT      auto-scale input numbers to UNITs; default is "
"'none';\n"
"                         see UNIT below\n"
msgstr ""

#: src/numfmt.c:909
msgid ""
"      --from-unit=N    specify the input unit size (instead of the default "
"1)\n"
msgstr ""

#: src/numfmt.c:912
msgid ""
"      --grouping       use locale-defined grouping of digits, e.g. "
"1,000,000\n"
"                         (which means it has no effect in the C/POSIX "
"locale)\n"
msgstr ""

#: src/numfmt.c:916
msgid ""
"      --header[=N]     print (without converting) the first N header lines;\n"
"                         N defaults to 1 if not specified\n"
msgstr ""

#: src/numfmt.c:920
msgid ""
"      --invalid=MODE   failure mode for invalid numbers: MODE can be:\n"
"                         abort (default), fail, warn, ignore\n"
msgstr ""

#: src/numfmt.c:924
msgid ""
"      --padding=N      pad the output to N characters; positive N will\n"
"                         right-align; negative N will left-align;\n"
"                         padding is ignored if the output is wider than N;\n"
"                         the default is to automatically pad if a "
"whitespace\n"
"                         is found\n"
msgstr ""

#: src/numfmt.c:931
msgid ""
"      --round=METHOD   use METHOD for rounding when scaling; METHOD can be:\n"
"                         up, down, from-zero (default), towards-zero, "
"nearest\n"
msgstr ""

#: src/numfmt.c:935
msgid ""
"      --suffix=SUFFIX  add SUFFIX to output numbers, and accept optional\n"
"                         SUFFIX in input numbers\n"
msgstr ""

#: src/numfmt.c:939
msgid ""
"      --to=UNIT        auto-scale output numbers to UNITs; see UNIT below\n"
msgstr ""

#: src/numfmt.c:942
msgid ""
"      --to-unit=N      the output unit size (instead of the default 1)\n"
msgstr ""

#: src/numfmt.c:951
#, fuzzy
msgid ""
"\n"
"UNIT options:\n"
msgstr "Дълги опции на GNU:\n"

#: src/numfmt.c:954
msgid "  none       no auto-scaling is done; suffixes will trigger an error\n"
msgstr ""

#: src/numfmt.c:957
msgid ""
"  auto       accept optional single/two letter suffix:\n"
"               1K = 1000,\n"
"               1Ki = 1024,\n"
"               1M = 1000000,\n"
"               1Mi = 1048576,\n"
msgstr ""

#: src/numfmt.c:963
msgid ""
"  si         accept optional single letter suffix:\n"
"               1K = 1000,\n"
"               1M = 1000000,\n"
"               ...\n"
msgstr ""

#: src/numfmt.c:968
msgid ""
"  iec        accept optional single letter suffix:\n"
"               1K = 1024,\n"
"               1M = 1048576,\n"
"               ...\n"
msgstr ""

#: src/numfmt.c:973
msgid ""
"  iec-i      accept optional two-letter suffix:\n"
"               1Ki = 1024,\n"
"               1Mi = 1048576,\n"
"               ...\n"
msgstr ""

#: src/numfmt.c:979
msgid ""
"\n"
"FIELDS supports cut(1) style field ranges:\n"
"  N    N'th field, counted from 1\n"
"  N-   from N'th field, to end of line\n"
"  N-M  from N'th to M'th field (inclusive)\n"
"  -M   from first to M'th field (inclusive)\n"
"  -    all fields\n"
"Multiple fields/ranges can be separated with commas\n"
msgstr ""

#: src/numfmt.c:989
#, c-format
msgid ""
"\n"
"FORMAT must be suitable for printing one floating-point argument '%f'.\n"
"Optional quote (%'f) will enable --grouping (if supported by current "
"locale).\n"
"Optional width value (%10f) will pad output. Optional zero (%010f) width\n"
"will zero pad the number. Optional negative values (%-10f) will left align.\n"
"Optional precision (%.1f) will override the input determined precision.\n"
msgstr ""

#: src/numfmt.c:997
#, c-format
msgid ""
"\n"
"Exit status is 0 if all input numbers were successfully converted.\n"
"By default, %s will stop at the first conversion error with exit status 2.\n"
"With --invalid='fail' a warning is printed for each conversion error\n"
"and the exit status is 2.  With --invalid='warn' each conversion error is\n"
"diagnosed, but the exit status is 0.  With --invalid='ignore' conversion\n"
"errors are not diagnosed and the exit status is 0.\n"
msgstr ""

#: src/numfmt.c:1006
#, c-format
msgid ""
"\n"
"Examples:\n"
"  $ %s --to=si 1000\n"
"            -> \"1.0K\"\n"
"  $ %s --to=iec 2048\n"
"           -> \"2.0K\"\n"
"  $ %s --to=iec-i 4096\n"
"           -> \"4.0Ki\"\n"
"  $ echo 1K | %s --from=si\n"
"           -> \"1000\"\n"
"  $ echo 1K | %s --from=iec\n"
"           -> \"1024\"\n"
"  $ df -B1 | %s --header --field 2-4 --to=si\n"
"  $ ls -l  | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"
msgstr ""

#: src/numfmt.c:1059 src/seq.c:243
#, fuzzy, c-format
msgid "format %s has no %% directive"
msgstr "целта %s не е каталог"

#: src/numfmt.c:1086
#, fuzzy, c-format
msgid "invalid format %s (width overflow)"
msgstr "неправилна ширина на формат"

#: src/numfmt.c:1091
#, c-format
msgid "--format padding overriding --padding"
msgstr ""

#: src/numfmt.c:1110 src/seq.c:260
#, c-format
msgid "format %s ends in %%"
msgstr ""

#: src/numfmt.c:1126
#, fuzzy, c-format
msgid "invalid precision in format %s"
msgstr "аргументът „%s“ на опцията „%s“ е неправилен"

#: src/numfmt.c:1132
#, c-format
msgid "invalid format %s, directive must be %%[0]['][-][N][.][N]f"
msgstr ""

#: src/numfmt.c:1140 src/seq.c:267
#, c-format
msgid "format %s has too many %% directives"
msgstr ""

#: src/numfmt.c:1183
#, fuzzy, c-format
msgid "invalid suffix in input %s: %s"
msgstr "неправилен суфикс в аргумента „%3$s“ за опцията „%1$s%2$s“"

#: src/numfmt.c:1212
#, c-format
msgid ""
"value/precision too large to be printed: '%Lg/%<PRIuMAX>' (consider using --"
"to)"
msgstr ""

#: src/numfmt.c:1216
#, c-format
msgid "value too large to be printed: '%Lg' (consider using --to)"
msgstr ""

#: src/numfmt.c:1225
#, c-format
msgid "value too large to be printed: '%Lg' (cannot handle values > 999Y)"
msgstr ""

#: src/numfmt.c:1311
#, c-format
msgid "large input value %s: possible precision loss"
msgstr ""

#: src/numfmt.c:1500
#, fuzzy, c-format
msgid "invalid padding value %s"
msgstr "неправилен предикат „%s“"

#: src/numfmt.c:1513
#, fuzzy
msgid "multiple field specifications"
msgstr "%s: не е указано дописване"

#: src/numfmt.c:1547
#, fuzzy, c-format
msgid "invalid header value %s"
msgstr "неправилен аргумент „%s“ за опцията „--bytes“"

#: src/numfmt.c:1574
#, fuzzy
msgid "--grouping cannot be combined with --format"
msgstr "Не може да се комбинират файлови операнди с --files0-from."

#: src/numfmt.c:1577 src/sort.c:4690
#, c-format
msgid "failed to set locale"
msgstr "неуспешно задаване на локала"

#: src/numfmt.c:1582
#, fuzzy, c-format
msgid "no conversion option specified"
msgstr "не е зададен синтаксис"

#: src/numfmt.c:1590
#, fuzzy
msgid "grouping cannot be combined with --to"
msgstr "Не може да се комбинират файлови операнди с --files0-from."

#: src/numfmt.c:1592
#, c-format
msgid "grouping has no effect in this locale"
msgstr ""

#: src/numfmt.c:1605
#, c-format
msgid "--header ignored with command-line input"
msgstr ""

#: src/numfmt.c:1632
#, fuzzy, c-format
msgid "error reading input"
msgstr "грешка при анализа на „%s“"

#: src/numfmt.c:1643
#, c-format
msgid "failed to convert some of the input numbers"
msgstr ""

#: src/od.c:322
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]\n"
"  or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.]"
"[b]]\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [ФАЙЛ]…\n"
"     или:    %s [-abcdfilosx]… [ФАЙЛ] [[+]ОТМЕСТВАНЕ[.][b]]\n"
"     или:    %s --traditional [ФАЙЛ] [[+]ОТМЕСТВАНЕ [[+]ЕТИКЕТ]]\n"

#: src/od.c:328
#, fuzzy
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
msgstr ""
"\n"
"Извежда еднозначно представяне (по подразбиране осмични байтове) на\n"
"ФАЙЛ на стандартния изход.  Ако са посочени повече от един ФАЙЛ,\n"
"последователно обработва и извежда файловете в посочения ред.  Без\n"
"ФАЙЛ или ако ФАЙЛ е - се чете от стандартния вход.\n"
"\n"

#: src/od.c:336
#, fuzzy
msgid ""
"\n"
"If first and second call formats both apply, the second format is assumed\n"
"if the last operand begins with + or (if there are 2 operands) a digit.\n"
"An OFFSET operand means -j OFFSET.  LABEL is the pseudo-address\n"
"at first byte printed, incremented when dump is progressing.\n"
"For OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;\n"
"suffixes may be . for octal and b for multiply by 512.\n"
msgstr ""
"\n"
"Ако и първият, и вторият формат са валидни, се приема вторият, ако "
"последният\n"
"операнд започва с + или (ако има два операнда) число.  \n"
"Операнд ОТМЕСТВАНЕ означава -j ОТМЕСТВАНЕ.  ЕТИКЕТ е псевдоадресът на "
"първия\n"
"изведен байт и се увеличава постепенно заедно с обработката.  При\n"
"ОТМЕСТВАНЕ и ЕТИКЕТ може да има префикси 0x или 0X, които показват\n"
"шестнадесетично число, и суфикси . за осмично число и b за множител 512.\n"
"\n"
"ТИП се състои от една или повече от следните спецификации:\n"
"\n"
"  a          именуван знак, старшият бит се пренебрегва\n"
"  c          знак от ASCII или код, защитен с \\\n"

#: src/od.c:348
msgid ""
"  -A, --address-radix=RADIX   output format for file offsets; RADIX is one\n"
"                                of [doxn], for Decimal, Octal, Hex or None\n"
"      --endian={big|little}   swap input bytes according the specified "
"order\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""

#: src/od.c:354
#, fuzzy
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -S BYTES, --strings[=BYTES]  output strings of at least BYTES graphic "
"chars;\n"
"                                3 is implied when BYTES is not specified\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w[BYTES], --width[=BYTES]  output BYTES bytes per output line;\n"
"                                32 is implied when BYTES is not specified\n"
"      --traditional           accept arguments in third form above\n"
msgstr ""
"  -N, --read-bytes=БАЙТОВЕ    обработва до БАЙТОВЕ входни байта\n"
"  -S, --strings[=ДЪЛЖИНА]     извежда низове от поне по ДЪЛЖИНА графични "
"знаци\n"
"  -t, --format=ТИП            посочва формат или формати за извеждане\n"
"  -v, --output-duplicates     да не се ползва * за отбелязване на еднакви "
"редове\n"
"  -w, --width[=БАЙТОВЕ]       извежда по БАЙТОВЕ входни байта на един ред\n"
"      --traditional           да се приемат аргументи в традиционния формат\n"

#: src/od.c:367
#, fuzzy
msgid ""
"\n"
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters, ignoring high-order bit\n"
"  -b   same as -t o1, select octal bytes\n"
"  -c   same as -t c,  select printable characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal 2-byte units\n"
msgstr ""
"\n"
"Спецификациите в традиционен формат може да се смесват и се натрупват:\n"
"  -a   е същото като -t a,  извеждат се именувани знаци, пренебрегва старшия "
"бит\n"
"  -b   е същото като -t o1, извеждат се осмични байтове\n"
"  -c   е същото като -t c,  извеждат се ASCII знаци или префикси с \\\n"
"  -d   е същото като -t u2, извеждат се беззнакови двубайтови десетични "
"числа\n"

#: src/od.c:376
msgid ""
"  -f   same as -t fF, select floats\n"
"  -i   same as -t dI, select decimal ints\n"
"  -l   same as -t dL, select decimal longs\n"
"  -o   same as -t o2, select octal 2-byte units\n"
"  -s   same as -t d2, select decimal 2-byte units\n"
"  -x   same as -t x2, select hexadecimal 2-byte units\n"
msgstr ""
"  -f   е същото като -t fF, извеждат се числа с плаваща запетая\n"
"  -i   е същото като -t dI, извеждат се десетични цели числа\n"
"  -l   е същото като -t dL, извеждат се десетични дълги числа\n"
"  -o   е същото като -t o2, извеждат се двубайтови осмични числа\n"
"  -s   е същото като -t d2, извеждат се двубайтови десетични числа\n"
"  -x   е същото като -t x2, извеждат се двубайтови шестнадесетични числа\n"

#: src/od.c:384
msgid ""
"\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"  a          named character, ignoring high-order bit\n"
"  c          printable character or backslash escape\n"
msgstr ""

#: src/od.c:391
#, fuzzy
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per float\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""
"  d[РАЗМ]    знаково десетично число от РАЗМ байта\n"
"  f[РАЗМ]    число с плаваща запетая от РАЗМ байта\n"
"  o[РАЗМ]    знаково осмично число от РАЗМ байта\n"
"  u[РАЗМ]    беззнаково десетично число от РАЗМ байта\n"
"  x[РАЗМ]    шестнадесетично число от РАЗМ байта\n"

#: src/od.c:398
#, fuzzy
msgid ""
"\n"
"SIZE is a number.  For TYPE in [doux], SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""
"\n"
"РАЗМ е число.  Ако ТИП е doux, РАЗМ може да бъде и C за sizeof(char),\n"
"S за sizeof(short), I за sizeof(int) или L за sizeof(long).  Ако ТИП е\n"
"f, РАЗМ може да бъде и F за sizeof(float), D за sizeof(double) или L\n"
"за sizeof(long double).\n"

#: src/od.c:405
msgid ""
"\n"
"Adding a z suffix to any type displays printable characters at the end of\n"
"each output line.\n"
msgstr ""

#: src/od.c:410
#, fuzzy
msgid ""
"\n"
"\n"
"BYTES is hex with 0x or 0X prefix, and may have a multiplier suffix:\n"
"  b    512\n"
"  KB   1000\n"
"  K    1024\n"
"  MB   1000*1000\n"
"  M    1024*1024\n"
"and so on for G, T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""
"\n"
"РАЗМ се състои от незадължително цяло число, следвано от едно от:\n"
"kB=1000, K=1024, MB=1000*1000, M=1024*1024 и аналогично за G, T, P, E, Z и "
"Y.\n"

#: src/od.c:684 src/od.c:804
#, c-format
msgid "invalid type string %s"
msgstr "неправилен низ за тип %s"

#: src/od.c:694
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"неправилен низ за тип %s;\n"
"тази система не поддържа %lu-байтови целочислени числа"

#: src/od.c:815
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"неправилен низ за тип %s;\n"
"тази система не поддържа %lu-байтови числа с плаваща запетая"

#: src/od.c:873
#, fuzzy, c-format
msgid "invalid character '%c' in type string %s"
msgstr "неправилен знак на позиция %d в низа за изнасяне за %s"

#: src/od.c:1105
msgid "cannot skip past end of combined input"
msgstr "не може да се пропусне след края на комбинирания вход"

#: src/od.c:1655
#, fuzzy, c-format
msgid "invalid output address radix '%c'; it must be one character from [doxn]"
msgstr ""
"неправилна база „%c“ на изходния адрес; трябва да бъде знак измежду [doxn]"

#: src/od.c:1793
msgid "no type may be specified when dumping strings"
msgstr "при извеждане на низове не може да се посочва тип"

#: src/od.c:1868
#, fuzzy
msgid "compatibility mode supports at most one file"
msgstr "При традиционния формат се поддържа най-много един файл."

#: src/od.c:1889
msgid "skip-bytes + read-bytes is too large"
msgstr "skip-bytes + read-bytes са твърде много"

#: src/od.c:1932
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "внимание: неправилна ширина %lu; вместо нея се ползва %d"

#: src/paste.c:222
msgid "standard input is closed"
msgstr "стандартният вход е затворен"

#: src/paste.c:440
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
msgstr ""
"Извеждане на стандартния изход на редове, състоящи се от поредно\n"
"съответстващи си редове от всеки ФАЙЛ, разделени с табулации.\n"

#: src/paste.c:448
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=СПИСЪК разделяне със знаците от този СПИСък, а не с "
"табулации\n"
"  -s, --serial            последователно, а не паралелно, извеждане на "
"файловете\n"

#: src/paste.c:518
#, c-format
msgid "delimiter list ends with an unescaped backslash: %s"
msgstr "списъкът с разделители завършва с неекранирана „\\“: %s"

#: src/pathchk.c:89
msgid ""
"Diagnose invalid or unportable file names.\n"
"\n"
"  -p                  check for most POSIX systems\n"
"  -P                  check for empty names and leading \"-\"\n"
"      --portability   check for all POSIX systems (equivalent to -p -P)\n"
msgstr ""
"Определяне платформенозависимите конструкции.\n"
"\n"
"  -p                  проверка за повечето POSIX-съвместими системи\n"
"  -P                  проверка за празни имена и начални „-“\n"
"      --portability   проверка за всички POSIX-съвместими системи (като „-p -"
"P“)\n"

#: src/pathchk.c:169
#, c-format
msgid "leading '-' in a component of file name %s"
msgstr "начален „-“ в компонент на името на файл „%s“"

#: src/pathchk.c:195
#, c-format
msgid "nonportable character %s in file name %s"
msgstr "платформенозависим знак „%s“ в името на файл „%s“"

#: src/pathchk.c:271
#, c-format
msgid "empty file name"
msgstr "празно файлово име"

#: src/pathchk.c:313
#, c-format
msgid "%s: unable to determine maximum file name length"
msgstr "%s: не може да се определи максималната дължина за име на файл"

#: src/pathchk.c:324
#, c-format
msgid "limit %lu exceeded by length %lu of file name %s"
msgstr "ограничението %lu е нарушено от дължината %lu на името на файл „%s“"

#: src/pathchk.c:410
#, c-format
msgid "limit %lu exceeded by length %lu of file name component %s"
msgstr ""
"ограничението %lu е нарушено от дължината %lu на компонента на името на файл "
"„%s“"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:37 src/uptime.c:45 src/users.c:35 src/who.c:50
msgid "Joseph Arceneaux"
msgstr "Joseph Arceneaux"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:39 src/uptime.c:47
msgid "Kaveh Ghazi"
msgstr "Kaveh Ghazi"

#. TRANSLATORS: Real name is unknown; at most 19 characters.
#: src/pinky.c:241
msgid "        ???"
msgstr "        ???"

#. TRANSLATORS: Idle time is unknown; at most 5 characters.
#: src/pinky.c:265
msgid "?????"
msgstr "?????"

#: src/pinky.c:313
#, c-format
msgid "Login name: "
msgstr "Входящо име: "

#: src/pinky.c:316
#, c-format
msgid "In real life: "
msgstr "В реалния живот: "

#. TRANSLATORS: Real name is unknown; no hard limit.
#: src/pinky.c:320
msgid "???\n"
msgstr "???\n"

#: src/pinky.c:340
#, c-format
msgid "Directory: "
msgstr "Директория: "

#: src/pinky.c:342
#, c-format
msgid "Shell: "
msgstr "Обвивка: "

#: src/pinky.c:361
#, c-format
msgid "Project: "
msgstr "Проект: "

#: src/pinky.c:385
#, c-format
msgid "Plan:\n"
msgstr "План:\n"

#: src/pinky.c:404
msgid "Login"
msgstr "Вход "

#: src/pinky.c:406
msgid "Name"
msgstr "Име "

#: src/pinky.c:407
msgid " TTY"
msgstr " TTY"

#: src/pinky.c:409
msgid "Idle"
msgstr "Неактивен"

#: src/pinky.c:410
msgid "When"
msgstr "Кога"

#: src/pinky.c:413
msgid "Where"
msgstr "Къде"

#: src/pinky.c:490
msgid ""
"\n"
"  -l              produce long format output for the specified USERs\n"
"  -b              omit the user's home directory and shell in long format\n"
"  -h              omit the user's project file in long format\n"
"  -p              omit the user's plan file in long format\n"
"  -s              do short format output, this is the default\n"
msgstr ""
"\n"
"  -l              извеждане на посочените ПОТРЕБИТЕЛи в подробен формат\n"
"  -b              без потребителската директория в подробния формат\n"
"  -h              без потребителския файл-проект в подробния формат\n"
"  -p              без потребителския файл-план в подробния формат\n"
"  -s              извеждане в кратък формат (стандартно)\n"

#: src/pinky.c:498
msgid ""
"  -f              omit the line of column headings in short format\n"
"  -w              omit the user's full name in short format\n"
"  -i              omit the user's full name and remote host in short format\n"
"  -q              omit the user's full name, remote host and idle time\n"
"                  in short format\n"
msgstr ""
"  -f              без заглавие в съкратен формат\n"
"  -w              без пълните имена в съкратен формат\n"
"  -i              без пълните имена и отдалечените хостове в съкратен "
"формат\n"
"  -q              без пълните имена, отдалечените хостове и\n"
"                  време на неактивност в съкратен формат\n"

#: src/pinky.c:507
#, c-format
msgid ""
"\n"
"A lightweight 'finger' program;  print user information.\n"
"The utmp file will be %s.\n"
msgstr ""
"\n"
"Олекотена програма „finger“ — извеждане на информация за потребител.\n"
"Файлът „utmp“ ще бъде „%s“.\n"

#: src/pinky.c:591
#, c-format
msgid "no username specified; at least one must be specified when using -l"
msgstr "при използване на -l трябва да се посочи поне едно потребителско име"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:331
msgid "Pete TerMaat"
msgstr ""

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:332
msgid "Roland Huebner"
msgstr "Roland Huebner"

#: src/pr.c:777
#, fuzzy
msgid "integer overflow"
msgstr "препълване на стека"

#: src/pr.c:916
#, fuzzy
msgid "'--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "на „--pages=ПЪРВА_СТР[:ПОСЛ_СТР]“ липсва аргумент"

#: src/pr.c:918
#, fuzzy, c-format
msgid "invalid page range %s"
msgstr "неправилен израз „%s“"

#: src/pr.c:978
#, fuzzy
msgid "'-l PAGE_LENGTH' invalid number of lines"
msgstr "Неправилен брой елементи"

#: src/pr.c:993
#, fuzzy
msgid "'-N NUMBER' invalid starting line number"
msgstr "неправилен номер на сигнал"

#: src/pr.c:997
#, fuzzy
msgid "'-o MARGIN' invalid line offset"
msgstr "Неправилно отместване при търсене"

#: src/pr.c:1034
#, fuzzy
msgid "'-w PAGE_WIDTH' invalid number of characters"
msgstr "“-w СТР_ШИР“ неправилен брой знаци: %s"

#: src/pr.c:1043
#, fuzzy
msgid "'-W PAGE_WIDTH' invalid number of characters"
msgstr "“-W СТР_ШИР“ неправилен брой знаци: %s"

#: src/pr.c:1072
#, fuzzy
msgid "cannot specify number of columns when printing in parallel"
msgstr "Не може да се посочва номер на стълбове при паралелен печат."

#: src/pr.c:1076
#, fuzzy
msgid "cannot specify both printing across and printing in parallel"
msgstr "Не може да се задава едновременно успореден печат и печат напреки."

#: src/pr.c:1179
#, fuzzy, c-format
msgid "'-%c' extra characters or invalid number in the argument: %s"
msgstr "“-%c“ излишни знаци или неправилен номер в аргумент: %s"

#: src/pr.c:1281
msgid "page width too narrow"
msgstr "ширината на страницата е твърде малка"

#: src/pr.c:2337
#, c-format
msgid "starting page number %<PRIuMAX> exceeds page count %<PRIuMAX>"
msgstr ""
"началният номер на страница %<PRIuMAX> надминава броя страници %<PRIuMAX>"

#: src/pr.c:2364
#, fuzzy
msgid "page number overflow"
msgstr "Препълване на номера на том"

#: src/pr.c:2369
#, c-format
msgid "Page %<PRIuMAX>"
msgstr "Стр. %<PRIuMAX>"

#: src/pr.c:2741
#, fuzzy
msgid "Paginate or columnate FILE(s) for printing.\n"
msgstr ""
"Форматира за печат ФАЙЛовете по страници и стълбове.\n"
"\n"

#: src/pr.c:2748
#, fuzzy
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    output COLUMN columns and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page\n"
msgstr ""
"  +ПЪРВА_СТР[:ПОСЛ_СТР], --pages=ПЪРВА_СТР[:ПОСЛ_СТР]\n"
"                    започва/свършва печата при ПЪРВА_СТР/ПОСЛ_СТР\n"
"  -COLUMN, --columns=СТЪЛБОВЕ\n"
"                    извежда СТЪЛБОВЕ стълба и отпечатва стълбовете надолу,\n"
"                    освен ако е използвано -a.  Подравнява броя на редове\n"
"                    в стълбовете на всяка страница.\n"

#: src/pr.c:2756
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across      печата стълбовете напреки вместо надолу, използва се\n"
"                    заедно с -COLUMN\n"
"  -c, --show-control-chars\n"
"                    използва запис със шапки (^G) и осмични числа\n"
"  -d, --double-space\n"
"                    двойни интервали в изхода\n"

#: src/pr.c:2764
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=ФОРМАТ\n"
"                    да се ползва ФОРМАТ при датата на колонтитула\n"
"  -e[ЗНАК[ШИР]], --expand-tabs[=ЗНАК[ШИР]]\n"
"                    разширява всеки входен ЗНАК като табулация със ШИРина "
"(8)\n"
"  -F, -f, --form-feed\n"
"                    разделя страниците с form feed вместо с нови редове\n"
"                    (при -F има 3-редов горен колонтитул, а без -F има 5-"
"редови\n"
"                    горен и долен колонтитули)\n"

#: src/pr.c:2774
#, fuzzy
msgid ""
"  -h, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h ГКОЛОНТ, --header=ГКОЛОНТ\n"
"                    ГКОЛОНТ в средата на горния колонтитул вместо името на "
"файла\n"
"                    -h \"\" отпечатва празен ред, не ползвайте -h\"\"\n"
"  -i[ЗНАК[ШИР]], --output-tabs[=ЗНАК[ШИР]]\n"
"                    заменя интервалите със ЗНАЦи (табулации) със ШИРина (8)\n"
"  -J, --join-lines  слива пълните редове, отменя съкращаването на редове с -"
"W,\n"
"                    без подравняване на стълбовете, --sep-string[=НИЗ] "
"посочва\n"
"                    ограничителите\n"

#: src/pr.c:2783
#, fuzzy
msgid ""
"  -l, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63).\n"
"                    implies -t if PAGE_LENGTH <= 10\n"
msgstr ""
"  -l СТР_ДЪЛЖ, --length=СТР_ДЪЛЖ\n"
"                    посочва дължина на страниците от СТР_ДЪЛЖ (66) реда\n"
"                    (по подразбиране броят редове на текст е 56, с -F -- "
"63)\n"
"  -m, --merge       извежда паралелно всички файлове, по един в стълб.\n"
"                    съкращава редовете, но с -J слива пълните редове\n"

#: src/pr.c:2789
#, fuzzy
msgid ""
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""
"  -l СТР_ДЪЛЖ, --length=СТР_ДЪЛЖ\n"
"                    посочва дължина на страниците от СТР_ДЪЛЖ (66) реда\n"
"                    (по подразбиране броят редове на текст е 56, с -F -- "
"63)\n"
"  -m, --merge       извежда паралелно всички файлове, по един в стълб.\n"
"                    съкращава редовете, но с -J слива пълните редове\n"

#: src/pr.c:2793
#, fuzzy
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n[РАЗД[ЦИФРИ]], --number-lines[=РАЗД[ЦИФРИ]]\n"
"                    номерира редовете, номерата са с ширина ЦИФРИ (5), след "
"тях \n"
"                    РАЗД (табулации); по подразб. започва да брои от 1\n"
"  -N НОМЕР, --first-line-number=НОМЕР\n"
"                    при номериране на редовете първият ред от първата "
"страница\n"
"                    е с номер НОМЕР (вж. +ПЪРВА_СТР)\n"

#: src/pr.c:2801
#, fuzzy
msgid ""
"  -o, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o ПОЛЕ, --indent=ПОЛЕ\n"
"                    всеки ред е отместен с ПОЛЕ (нула) интервала, не влияе "
"на\n"
"                    -w и -W, ПОЛЕ ще бъде добавено към СТР_ШИР\n"
"  -r, --no-file-warnings\n"
"                    не предупреждава, ако файлът не може да бъде отворен\n"

#: src/pr.c:2808
#, fuzzy
msgid ""
"  -s[CHAR], --separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -"
"w.\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""
"  -s[ЗНАК],--separator[=ЗНАК]\n"
"                    разделя стълбовете с един знак, без -w по подразбиране "
"e\n"
"                    табулация, а с -w няма разделител.  Без -s разделителят "
"е\n"
"                    интервал.  -s отменя съкращаването на редовете при "
"всички\n"
"                    опции за стълбове (-СТЪЛБОВЕ|-a -СТЪЛБОВЕ|-m), освен ако "
"е\n"
"                    зададено и -w\n"

#: src/pr.c:2816
#, fuzzy
msgid ""
"  -S[STRING], --sep-string[=STRING]\n"
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
msgstr ""
"                    разделя стълбовете с НИЗ; без -S, но с -J разделител е "
"табу-\n"
"                    лация, а без -J е интервал. Не влияе на стълбовите "
"опции.\n"
"  -t, --omit-header пропуска горните и долните колонтитули\n"

#: src/pr.c:2822
msgid ""
"  -t, --omit-header  omit page headers and trailers;\n"
"                     implied if PAGE_LENGTH <= 10\n"
msgstr ""

#: src/pr.c:2826
#, fuzzy
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"                    не слага горни и долни колонтитули, изпуска "
"управляващите\n"
"                    кодове form feed от входните файлове.\n"
"  -v, --show-nonprinting\n"
"                    използва осмични числа с наклонена черта (\\019)\n"
"  -w СТР_ШИР, --width=СТР_ШИР\n"
"                    задава ширина на страницата от СТР_ШИР (72) знака при\n"
"                    многоколонен извод, -s[знак] отменя (72)\n"

#: src/pr.c:2836
#, fuzzy
msgid ""
"  -W, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W СТР_ШИР, --page-width=СТР_ШИР\n"
"                    задава ширина на страницата от СТР_ШИР (72) знака "
"винаги,\n"
"                    съкращава редовете, освен ако е зададена опция -J, не "
"се\n"
"                    влияе от -S и -s\n"

#: src/printenv.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [VARIABLE]...\n"
"Print the values of the specified environment VARIABLE(s).\n"
"If no VARIABLE is specified, print name and value pairs for them all.\n"
"\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [ПРОМЕНЛИВА]…\n"
"Извеждане на стойностите на указаните ПРОМЕНЛИВи на средата\n"
"Ако не е посочена ПРОМЕНЛИВА от обкръжението, се извеждат имената\n"
"и стойностите на всички.\n"

#: src/printenv.c:69
msgid "  -0, --null     end each output line with NUL, not newline\n"
msgstr "  -0, --null     завършване на редовете с нулев байт, а не нов ред\n"

#: src/printf.c:84
#, c-format
msgid ""
"warning: %s: character(s) following character constant have been ignored"
msgstr "внимание: %s: знаците следващи знакова константа са пренебрегнати"

#: src/printf.c:93
#, c-format
msgid ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s ФОРМАТ [АРГУМЕНТ]…\n"
"     или: %s ОПЦИЯ\n"

#: src/printf.c:98
msgid ""
"Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:\n"
"\n"
msgstr ""
"Извеждане на АРГУМЕНТите според ФОРМАТа или според ОПЦИите:\n"
"\n"

#: src/printf.c:104
msgid ""
"\n"
"FORMAT controls the output as in C printf.  Interpreted sequences are:\n"
"\n"
"  \\\"      double quote\n"
msgstr ""
"\n"
"ФОРМАТът управлява изхода както при командата printf на C. Разпознават се:\n"
"\n"
"  \\\"      двойни прави кавички\n"

#: src/printf.c:122
msgid ""
"  \\NNN    byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
"  \\uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)\n"
"  \\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)\n"
msgstr ""
"  \\NNN    байт с осмичен код NNN (от 1 до 3 цифри)\n"
"  \\xHH    байт с шестнадесетичен код HH (от 1 до 2 цифри)\n"
"  \\uHHHH  знак от Unicode (ISO/IEC 10646) с 16-ичен код HHHH (4 цифри)\n"
"  \\UHHHHHHHH\n"
"          знак от Unicode със шестнадесетичен код HHHHHHHH (8 цифри)\n"

#: src/printf.c:128
msgid ""
"  %%      a single %\n"
"  %b      ARGUMENT as a string with '\\' escapes interpreted,\n"
"          except that octal escapes are of the form \\0 or \\0NNN\n"
"  %q      ARGUMENT is printed in a format that can be reused as shell "
"input,\n"
"          escaping non-printable characters with the proposed POSIX $'' "
"syntax.\n"
"\n"
"and all C format specifications ending with one of diouxXfeEgGcs, with\n"
"ARGUMENTs converted to proper type first.  Variable widths are handled.\n"
msgstr ""
"  %%      знак процент\n"
"  %b      АРГУМЕНТ, в който се обработват обратните наклонени черти „\\“,\n"
"          но осмичните числа имат вида \\0 или \\0NNN\n"
"  %q      АРГУМЕНТът се извежда в предложения към POSIX формат — „$''“,\n"
"          непечатимите знаци се екранират\n"
"\n"
"и всички форматни спецификации на C, завършващи с някой от знаците:\n"
"„diouxXfeEgGcs“.  АРГУМЕНТите се преобразуват в нужния тип.  Поддържат се\n"
"променливи ширини.\n"

#: src/printf.c:155
#, c-format
msgid "%s: expected a numeric value"
msgstr "%s: очаква се числова стойност"

#: src/printf.c:157
#, c-format
msgid "%s: value not completely converted"
msgstr "%s: стойността не е напълно преобразувана"

#: src/printf.c:254 src/printf.c:281
msgid "missing hexadecimal number in escape"
msgstr "липсва шестнадесетично число след „\\“"

#: src/printf.c:293
#, c-format
msgid "invalid universal character name \\%c%0*x"
msgstr "неправилно универсално име на знак: „\\%c%0*x“"

#: src/printf.c:566
#, c-format
msgid "invalid field width: %s"
msgstr "неправилна ширина на поле: %s"

#: src/printf.c:601
#, c-format
msgid "invalid precision: %s"
msgstr "неправилна точност: %s"

#: src/printf.c:628
#, c-format
msgid "%.*s: invalid conversion specification"
msgstr "%.*s: неправилна спецификация на преобразуване"

#: src/printf.c:711
#, c-format
msgid "warning: ignoring excess arguments, starting with %s"
msgstr "внимание: пренебрегват се излишните аргументи започвайки от „%s“"

#. TRANSLATORS: Please translate "F. Pinard" to "François Pinard"
#. if "ç" (c-with-cedilla) is available in the translation's character
#. set and encoding.
#. This is a proper name. See the gettext manual, section Names.
#: src/ptx.c:42
msgid "F. Pinard"
msgstr "François Pinard"

#: src/ptx.c:424
#, c-format
msgid "%s (for regexp %s)"
msgstr "%s (за рег. израз „%s“)"

#: src/ptx.c:823
#, c-format
msgid "error: regular expression has a match of length zero: %s"
msgstr "грешка: регулярният израз напасва и с празен низ: „%s“"

#: src/ptx.c:1814
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [ВХОД]…   (без -G)\n"
"     или: %s -G [ОПЦИЯ]… [ВХОД [ИЗХОД]]\n"

#: src/ptx.c:1818
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
msgstr ""
"Извеждане на азбучен показалец на думите и контекста им във входните "
"файлове\n"
"\n"

#: src/ptx.c:1825
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -G, --traditional              behave more like System V 'ptx'\n"
msgstr ""
"  -A, --auto-reference           извеждане на автоматично генерираните "
"препратки\n"
"  -G, --traditional              работа като командата „ptx“ от System V\n"

#: src/ptx.c:1829
msgid ""
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations.\n"
"                                 The default is '/'\n"
msgstr ""
"  -F, --flag-truncation=НИЗ      отбелязване на съкращаването на ред с този "
"НИЗ.\n"
"                                 Стандартно е „/“\n"

#: src/ptx.c:1833
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of 'xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""
"  -M, --macro-name=ИМЕ           име на макрос вместо „xx“\n"
"  -O, --format=roff              изход с команди за „roff“\n"
"  -R, --right-side-refs          препратките да са отдясно, не се броят при "
"„-w“\n"
"  -S, --sentence-regexp=РЕГ_ИЗР  РЕГулярен_ИЗРаз за край на редовете или "
"край\n"
"                                 на изреченията\n"
"  -T, --format=tex               изход с команди за „TeX“\n"

#: src/ptx.c:1840
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""
"  -W, --word-regexp=РЕГ_ИЗР      РЕГулярен_ИЗРаз, който определя какво е "
"дума\n"
"  -b, --break-file=ФАЙЛ          думите свършват при знак от този ФАЙЛ\n"
"  -f, --ignore-case              подредба без разлика главните и малките "
"букви\n"
"  -g, --gap-size=РАЗМЕР          РАЗМЕР на  мястото между полетата в изхода\n"
"  -i, --ignore-file=ФАЙЛ         ФАЙЛ с думи, които да се пренебрегват\n"
"  -o, --only-file=ФАЙЛ           признават се само думи от този ФАЙЛ\n"

#: src/ptx.c:1848
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""
"  -r, --references               първото поле на всеки ред е препратка\n"
"  -t, --typeset-mode               • опцията не е реализирана •\n"
"  -w, --width=БРОЙ               ширина на изхода, препратките не се броят\n"

#: src/ptx.c:1945
#, c-format
msgid "invalid gap width: %s"
msgstr "неправилна ширина на мястото между полетата: %s"

#: src/ptx.c:1972
#, c-format
msgid "invalid line width: %s"
msgstr "неправилна дължина на реда: %s"

#: src/pwd.c:58
msgid ""
"Print the full filename of the current working directory.\n"
"\n"
msgstr ""
"Извеждане на пълното файлово име на текущата работна директория.\n"
"\n"

#: src/pwd.c:62
msgid ""
"  -L, --logical   use PWD from environment, even if it contains symlinks\n"
"  -P, --physical  avoid all symlinks\n"
msgstr ""
"  -L, --logical   използване на стойността на променливата на средата "
"„PWD“,\n"
"                  дори тя да съдържа символни връзки\n"
"  -P, --physical  избягване на всички символни връзки\n"

#: src/pwd.c:68
msgid ""
"\n"
"If no option is specified, -P is assumed.\n"
msgstr ""
"\n"
"Ако не е зададена никоя опция, се подразбира „-P“.\n"

#: src/pwd.c:169
#, c-format
msgid "failed to chdir to %s"
msgstr "директорията „%s“ не може да се отвори"

#: src/pwd.c:173 src/pwd.c:280 src/split.c:469
#, c-format
msgid "failed to stat %s"
msgstr "не може да се изпълни „stat“ върху „%s“"

#: src/pwd.c:238
#, c-format
msgid "couldn't find directory entry in %s with matching i-node"
msgstr "не може да се намери какво съответства на i-възел в директорията „%s“"

#: src/pwd.c:367
#, c-format
msgid "ignoring non-option arguments"
msgstr "аргументи, които не са опции, се пренебрегват"

#. This is a proper name. See the gettext manual, section Names.
#: src/readlink.c:32
msgid "Dmitry V. Levin"
msgstr "Dmitry V. Levin"

#: src/readlink.c:62 src/realpath.c:71 src/shred.c:170 src/stat.c:1518
#: src/touch.c:213
#, c-format
msgid "Usage: %s [OPTION]... FILE...\n"
msgstr "Употреба: %s [ОПЦИЯ]… ФАЙЛ…\n"

#: src/readlink.c:63
msgid ""
"Print value of a symbolic link or canonical file name\n"
"\n"
msgstr ""
"Извеждане на стойността на символна връзка или канонично име на файл\n"
"\n"

#: src/readlink.c:65
msgid ""
"  -f, --canonicalize            canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively;\n"
"                                all but the last component must exist\n"
"  -e, --canonicalize-existing   canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                all components must exist\n"
msgstr ""
"  -f, --canonicalize            привеждане в канонична форма чрез "
"рекурсивно\n"
"                                проследяване на всяка символна връзка във "
"всеки\n"
"                                компонент на даденото име.  Всички освен\n"
"                                последният компонент трябва да съществуват\n"
"  -e, --canonicalize-existing   привеждане в канонична форма чрез "
"рекурсивно\n"
"                                проследяване на всяка символна връзка във "
"всеки\n"
"                                компонент на даденото име.  Всички "
"компоненти\n"
"                                трябва да съществуват\n"

#: src/readlink.c:75
msgid ""
"  -m, --canonicalize-missing    canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                without requirements on components "
"existence\n"
"  -n, --no-newline              do not output the trailing delimiter\n"
"  -q, --quiet\n"
"  -s, --silent                  suppress most error messages (on by "
"default)\n"
"  -v, --verbose                 report error messages\n"
"  -z, --zero                    end each output line with NUL, not newline\n"
msgstr ""
"  -e, --canonicalize-existing   привеждане в канонична форма чрез "
"рекурсивно\n"
"  -m, --canonicalize-missing    проследяване на всяка символна връзка във "
"всеки\n"
"                                компонент на даденото име.  Без изискване "
"за\n"
"                                съществуване на компонентите\n"
"  -n, --no-newline              без извеждане на крайните разделители\n"
"  -q, --quiet                   без повечето съобщения за грешка\n"
"  -s, --silent                  без повечето съобщения за грешка\n"
"  -v, --verbose                 със съобщенията за грешки\n"
"  -z, --zero                    разделяне на редовете с нулев байт, а не нов "
"ред\n"

#: src/readlink.c:152
#, c-format
msgid "ignoring --no-newline with multiple arguments"
msgstr "опцията „--no-newline“ с множество аргументи се прескача"

#: src/realpath.c:72
msgid ""
"Print the resolved absolute file name;\n"
"all but the last component must exist\n"
"\n"
msgstr ""
"Извеждане на абсолютното име на файл, което е определено,\n"
"но последният компонент трябва да съществува\n"

#: src/realpath.c:77
msgid ""
"  -e, --canonicalize-existing  all components of the path must exist\n"
"  -m, --canonicalize-missing   no path components need exist or be a "
"directory\n"
"  -L, --logical                resolve '..' components before symlinks\n"
"  -P, --physical               resolve symlinks as encountered (default)\n"
"  -q, --quiet                  suppress most error messages\n"
"      --relative-to=DIR        print the resolved path relative to DIR\n"
"      --relative-base=DIR      print absolute paths unless paths below DIR\n"
"  -s, --strip, --no-symlinks   don't expand symlinks\n"
"  -z, --zero                   end each output line with NUL, not newline\n"
"\n"
msgstr ""
"  -e, --canonicalize-existing  всички компоненти на пътя трябва да "
"съществуват\n"
"  -m, --canonicalize-missing   без проверка дали всички елементи на пътя са\n"
"                               съществуващи директории\n"
"  -L, --logical                определяне на „..“ преди символните връзки\n"
"  -P, --physical               определяне на символните връзки по ред на "
"поява\n"
"                               (стандартно)\n"
"  -q, --quiet                  без повечето съобщения за грешки\n"
"      --relative-to=ДИРЕКТОРИЯ извеждане на определения път като "
"относителен\n"
"                               спрямо тази ДИРЕКТОРИЯ\n"
"      --relative-base=ДИРЕКТОРИЯ\n"
"                               извеждане на абсолютни пътища освен, ако не "
"са\n"
"                               в тази ДИРЕКТОРИЯ\n"
"  -s, --strip, --no-symlinks   без заместване на символните връзки\n"
"  -z, --zero                   завършване на редовете с нулев байт, а не нов "
"ред\n"
"\n"

#: src/relpath.c:130
msgid "generating relative path"
msgstr "генериране на относителен път"

#: src/remove.c:273
#, c-format
msgid "%s: descend into write-protected directory %s? "
msgstr "%s: да се навлезе ли в защитения срещу запис каталог %s? "

#: src/remove.c:274
#, c-format
msgid "%s: descend into directory %s? "
msgstr "%s: да се навлезе ли в каталога %s? "

#. TRANSLATORS: In the next two strings the second %s is
#. replaced by the type of the file.  To avoid grammatical
#. problems, it may be more convenient to translate these
#. strings instead as: "%1$s: %3$s is write-protected and
#. is of type '%2$s' -- remove it? ".
#: src/remove.c:291
#, c-format
msgid "%s: remove write-protected %s %s? "
msgstr "%s: да се изтрие ли %s със защита срещу запис %s? "

#: src/remove.c:292
#, c-format
msgid "%s: remove %s %s? "
msgstr "%s: да се изтрие ли %s %s? "

#: src/remove.c:375
#, fuzzy, c-format
msgid "removed directory %s\n"
msgstr "директорията „%s“ не може да се изтрие"

#: src/remove.c:447
#, c-format
msgid "refusing to remove %s or %s directory: skipping %s"
msgstr ""

#: src/remove.c:476
#, fuzzy, c-format
msgid "failed to stat %s: skipping %s"
msgstr "неуспешно задаване на двоичен режим за „%s“"

#: src/remove.c:489 src/remove.c:539
#, c-format
msgid "skipping %s, since it's on a different device"
msgstr "пропуска се %s тъй като е на друго устройство"

#: src/remove.c:491
#, c-format
msgid "and --preserve-root=all is in effect"
msgstr ""

#: src/remove.c:559
#, fuzzy, c-format
msgid "traversal failed: %s"
msgstr "неуспешно прочитане"

#: src/remove.c:565
#, c-format
msgid ""
"unexpected failure: fts_info=%d: %s\n"
"please report to %s"
msgstr ""

#: src/rm.c:117
#, fuzzy, c-format
msgid "Try '%s ./%s' to remove the file %s.\n"
msgstr "Опитайте „%s ./%s“, за да изтриете файла %s.\n"

#: src/rm.c:134
#, fuzzy
msgid ""
"Remove (unlink) the FILE(s).\n"
"\n"
"  -f, --force           ignore nonexistent files and arguments, never "
"prompt\n"
"  -i                    prompt before every removal\n"
msgstr ""
"Изтрива (unlink) ФАЙЛовете.\n"
"\n"
"  -f, --force           пренебрегва несъществуващи файлове, не пита\n"
"  -i                    пита преди всяко триене\n"

#: src/rm.c:140
#, fuzzy
msgid ""
"  -I                    prompt once before removing more than three files, "
"or\n"
"                          when removing recursively; less intrusive than -"
"i,\n"
"                          while still giving protection against most "
"mistakes\n"
"      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or\n"
"                          always (-i); without WHEN, prompt always\n"
msgstr ""
"  -I                    пита веднъж преди изтриването на повече от три "
"файла\n"
"                          или при рекурсивно триене.  По-малко досадно от -"
"i,\n"
"                          но все пак защитава срещу повечето грешки\n"
"      --interactive[=КОГА]  пита според КОГА: never, once (-I) или always (-"
"i).\n"
"                          Без КОГА пита винаги\n"

#: src/rm.c:147
msgid ""
"      --one-file-system  when removing a hierarchy recursively, skip any\n"
"                          directory that is on a file system different from\n"
"                          that of the corresponding command line argument\n"
msgstr ""
"      --one-file-system  при рекурсивно изтриване на файлове, пропуска\n"
"                          каталози, които са на файлова система, различна "
"от\n"
"                          тази на съответния аргумент на командния ред\n"

#: src/rm.c:152
#, fuzzy
msgid ""
"      --no-preserve-root  do not treat '/' specially\n"
"      --preserve-root[=all]  do not remove '/' (default);\n"
"                              with 'all', reject any command line argument\n"
"                              on a separate device from its parent\n"
msgstr ""
"      --no-preserve-root да не се обработва „/“ по-особено\n"
"      --preserve-root   да не се действа рекурсивно от „/“ (по "
"подразбиране)\n"
"  -r, -R, --recursive   изтрива рекурсивно каталозите и съдържанието им\n"
"  -v, --verbose         съобщава какво се прави\n"

#: src/rm.c:158
#, fuzzy
msgid ""
"  -r, -R, --recursive   remove directories and their contents recursively\n"
"  -d, --dir             remove empty directories\n"
"  -v, --verbose         explain what is being done\n"
msgstr ""
"      --no-preserve-root да не се обработва „/“ по-особено\n"
"      --preserve-root   да не се действа рекурсивно от „/“ (по "
"подразбиране)\n"
"  -r, -R, --recursive   изтрива рекурсивно каталозите и съдържанието им\n"
"  -v, --verbose         съобщава какво се прави\n"

#: src/rm.c:165
msgid ""
"\n"
"By default, rm does not remove directories.  Use the --recursive (-r or -R)\n"
"option to remove each listed directory, too, along with all of its "
"contents.\n"
msgstr ""
"\n"
"По подразбиране rm не изтрива каталози. За целта ползвайте опцията --"
"recursive\n"
"(-r или -R), която ще изтрие всеки изброен каталог, заедно със съдържанието "
"му.\n"

#: src/rm.c:170
#, fuzzy, c-format
msgid ""
"\n"
"To remove a file whose name starts with a '-', for example '-foo',\n"
"use one of these commands:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"
msgstr ""
"\n"
"За да се изтрие файл, чието име започва с „-“ (напр. „-трънки“),\n"
"използвайте една от командите:\n"
"  %s -- -трънки\n"
"\n"
"  %s ./-трънки\n"

#: src/rm.c:179
#, fuzzy
msgid ""
"\n"
"Note that if you use rm to remove a file, it might be possible to recover\n"
"some of its contents, given sufficient expertise and/or time.  For greater\n"
"assurance that the contents are truly unrecoverable, consider using shred.\n"
msgstr ""
"\n"
"Забележете, че ако използвате rm, за да изтриете даден файл, обикновено е\n"
"възможно съдържанието му да бъде възстановено. Ако искате да си гарантирате, "
"че\n"
"съдържанието му е напълно невъзстановимо, помислете дали да не използвате "
"shred.\n"

#: src/rm.c:297
msgid "you may not abbreviate the --no-preserve-root option"
msgstr ""

#: src/rm.c:309
#, fuzzy, c-format
msgid "unrecognized --preserve-root argument: %s"
msgstr "непознат префикс: %s"

#: src/rm.c:359
#, fuzzy, c-format
msgid "%s: remove %<PRIuMAX> argument recursively? "
msgid_plural "%s: remove %<PRIuMAX> arguments recursively? "
msgstr[0] "%s: да се изтрият ли рекурсивно всички аргументи? "
msgstr[1] "%s: да се изтрият ли рекурсивно всички аргументи? "

#: src/rm.c:362
#, fuzzy, c-format
msgid "%s: remove %<PRIuMAX> argument? "
msgid_plural "%s: remove %<PRIuMAX> arguments? "
msgstr[0] "%s: да се изтрият ли всички аргументи"
msgstr[1] "%s: да се изтрият ли всички аргументи"

#: src/rmdir.c:133 src/rmdir.c:232
#, c-format
msgid "removing directory, %s"
msgstr "изтриване на директорията „%s“"

#: src/rmdir.c:147
#, c-format
msgid "failed to remove directory %s"
msgstr "неуспешно изтриване на директорията „%s“"

#: src/rmdir.c:164
msgid ""
"Remove the DIRECTORY(ies), if they are empty.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ignore each failure that is solely because a directory\n"
"                    is non-empty\n"
msgstr ""
"Изтриване на ДИРЕКТОРИите, ако са празни.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  пренебрегване на проблеми поради непразни директории\n"

#: src/rmdir.c:171
msgid ""
"  -p, --parents   remove DIRECTORY and its ancestors; e.g., 'rmdir -p a/b/c' "
"is\n"
"                    similar to 'rmdir a/b/c a/b a'\n"
"  -v, --verbose   output a diagnostic for every directory processed\n"
msgstr ""
"  -p, --parents   изтриване на ДИРЕКТОРИЯта, след което се прави опит за\n"
"                  изтриването на родителските ДИРЕКТОРИи.  Напр.\n"
"                  „rmdir -p a/b/c“ е същото като „rmdir a/b/c a/b a“.\n"
"  -v, --verbose   извеждане на съобщение за всяка обработена директория\n"

#: src/rmdir.c:241
#, c-format
msgid "failed to remove %s"
msgstr "файлът „%s“ не може да се изтрие"

#: src/runcon.c:78
#, c-format
msgid ""
"Usage: %s CONTEXT COMMAND [args]\n"
"  or:  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [args]\n"
msgstr ""

#: src/runcon.c:82
msgid ""
"Run a program in a different SELinux security context.\n"
"With neither CONTEXT nor COMMAND, print the current security context.\n"
msgstr ""

#: src/runcon.c:89
msgid ""
"  CONTEXT            Complete security context\n"
"  -c, --compute      compute process transition context before modifying\n"
"  -t, --type=TYPE    type (for same role as parent)\n"
"  -u, --user=USER    user identity\n"
"  -r, --role=ROLE    role\n"
"  -l, --range=RANGE  levelrange\n"
"\n"
msgstr ""

#: src/runcon.c:139
#, fuzzy
msgid "multiple roles"
msgstr "множество „!“"

#: src/runcon.c:144
#, fuzzy
msgid "multiple types"
msgstr "множество „!“"

#: src/runcon.c:149
#, fuzzy
msgid "multiple users"
msgstr "множество „!“"

#: src/runcon.c:154
#, fuzzy
msgid "multiple levelranges"
msgstr "мултиплексиран файл"

#: src/runcon.c:172 src/runcon.c:208
#, fuzzy
msgid "failed to get current context"
msgstr "неуспешно връщане към родителската директория"

#: src/runcon.c:182
#, c-format
msgid "you must specify -c, -t, -u, -l, -r, or context"
msgstr ""

#: src/runcon.c:190
#, fuzzy, c-format
msgid "no command specified"
msgstr "не е открита команда"

#: src/runcon.c:195
#, fuzzy, c-format
msgid "%s may be used only on a SELinux kernel"
msgstr "опцията „--acls“ може да се използва само при архиви във формат POSIX"

#: src/runcon.c:222
#, fuzzy
msgid "failed to compute a new context"
msgstr "файлът „%s“ не може да се отвори наново с режим „%s“"

#: src/runcon.c:236
#, fuzzy, c-format
msgid "failed to set new user: %s"
msgstr "неуспешно задаване на двоичен режим за „%s“"

#: src/runcon.c:239
#, fuzzy, c-format
msgid "failed to set new type: %s"
msgstr "неуспешно задаване на двоичен режим за „%s“"

#: src/runcon.c:242
#, fuzzy, c-format
msgid "failed to set new range: %s"
msgstr "променливата на средата „%s“ не може да се зададе"

#: src/runcon.c:245
#, fuzzy, c-format
msgid "failed to set new role: %s"
msgstr "променливата на средата „%s“ не може да се зададе"

#: src/runcon.c:254
#, fuzzy, c-format
msgid "unable to set security context %s"
msgstr ""
"%s: ПРЕДУПРЕЖДЕНИЕ: контекстът за сигурност на „%s“ не може да се получи: %s"

#: src/seq.c:75
#, c-format
msgid ""
"Usage: %s [OPTION]... LAST\n"
"  or:  %s [OPTION]... FIRST LAST\n"
"  or:  %s [OPTION]... FIRST INCREMENT LAST\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… ПОСЛЕДНО\n"
"     или: %s [ОПЦИЯ]… ПЪРВО ПОСЛЕДНО\n"
"     или: %s [ОПЦИЯ]… ПЪРВО СТЪПКА ПОСЛЕДНО\n"

#: src/seq.c:80
msgid "Print numbers from FIRST to LAST, in steps of INCREMENT.\n"
msgstr ""

#: src/seq.c:86
#, fuzzy
msgid ""
"  -f, --format=FORMAT      use printf style floating-point FORMAT\n"
"  -s, --separator=STRING   use STRING to separate numbers (default: \\n)\n"
"  -w, --equal-width        equalize width by padding with leading zeroes\n"
msgstr ""
"Извежда числата от ПЪРВО до ПОСЛЕДНО със стъпка СТЪПКА.\n"
"\n"
"  -f, --format=ФОРМАТ      използва ФОРМАТ за плаваща запетая на printf\n"
"  -s, --separator=НИЗ      ползва НИЗ, за да разделя числата (по подразб. "
"\\n)\n"
"  -w, --equal-width        подравнява ширината, попълвайки в началото с "
"нули\n"

#: src/seq.c:93
#, fuzzy
msgid ""
"\n"
"If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\n"
"omitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\n"
"The sequence of numbers ends when the sum of the current number and\n"
"INCREMENT would become greater than LAST.\n"
"FIRST, INCREMENT, and LAST are interpreted as floating point values.\n"
"INCREMENT is usually positive if FIRST is smaller than LAST, and\n"
"INCREMENT is usually negative if FIRST is greater than LAST.\n"
"INCREMENT must not be 0; none of FIRST, INCREMENT and LAST may be NaN.\n"
msgstr ""
"\n"
"Ако ПЪРВО или СТЪПКА са пропуснати, по подразбиране се използва 1.  Например "
"ако\n"
"е пропусната СТЪПКА, по подразбиране тя е 1 дори и ако ПОСЛЕДНО е по-малко "
"от\n"
"ПЪРВО.  ПЪРВО, СТЪПКА И ПОСЛЕДНО се интерпретират като числа с плаваща "
"запетая.\n"
"Обикновено СТЪПКА е положителна, ако ПЪРВО е по-малко от ПОСЛЕДНО и "
"отрицателна\n"
"иначе.  ФОРМАТът трябва да бъде подходящ за извеждането на едно число с "
"плаваща\n"
"запетая; по подразбиране е %.ТОЧНОСТf, ако всяко от ПЪРВО, СТЪПКА И ПОСЛЕДНО "
"е\n"
"число с плаваща запетая с максимална точност TOЧНОСТ и %g иначе.\n"

#: src/seq.c:104
msgid ""
"FORMAT must be suitable for printing one argument of type 'double';\n"
"it defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\n"
"decimal numbers with maximum precision PREC, and to %g otherwise.\n"
msgstr ""

#: src/seq.c:150
#, c-format
msgid "invalid floating point argument: %s"
msgstr "неправилно число с плаваща запетая като аргумент: %s"

#: src/seq.c:156
#, fuzzy, c-format
msgid "invalid %s argument: %s"
msgstr "неправилен аргумент „%3$s“ за опцията „%1$s%2$s“"

#: src/seq.c:263
#, fuzzy, c-format
msgid "format %s has unknown %%%c directive"
msgstr "%s има непознат файлов тип"

#: src/seq.c:633
#, c-format
msgid "format string may not be specified when printing equal width strings"
msgstr ""
"не може да се използва форматен низ, когато се извеждат низове с еднаква "
"ширина"

#: src/seq.c:670
#, fuzzy, c-format
msgid "invalid Zero increment value: %s"
msgstr "Неправилно ниво на инкрементален архив"

#: src/set-fields.c:167
#, fuzzy
msgid "invalid byte or character range"
msgstr "неправилен клас знаци"

#: src/set-fields.c:168
#, fuzzy
msgid "invalid field range"
msgstr "Неправилен край на диапазон"

#: src/set-fields.c:175 src/set-fields.c:221
msgid "byte/character positions are numbered from 1"
msgstr ""

#: src/set-fields.c:176 src/set-fields.c:222
#, fuzzy
msgid "fields are numbered from 1"
msgstr "номерът на поле е нула"

#: src/set-fields.c:196
#, fuzzy
msgid "invalid range with no endpoint: -"
msgstr "Неправилен край на диапазон"

#: src/set-fields.c:210
#, fuzzy
msgid "invalid decreasing range"
msgstr "неправилен израз"

#: src/set-fields.c:259
#, fuzzy, c-format
msgid "byte/character offset %s is too large"
msgstr "байтовото отместване %s е твърде дълго"

#: src/set-fields.c:260
#, c-format
msgid "field number %s is too large"
msgstr "номерът на поле %s е твърде голям"

#: src/set-fields.c:271
#, fuzzy, c-format
msgid "invalid byte/character position %s"
msgstr "неправилен знак на позиция %d в низа за изнасяне за %s"

#: src/set-fields.c:272
#, fuzzy, c-format
msgid "invalid field value %s"
msgstr "неправилен аргумент „%s“ за опцията „--bytes“"

#: src/set-fields.c:280
#, fuzzy
msgid "missing list of byte/character positions"
msgstr "липсва списък позиции"

#: src/set-fields.c:281
msgid "missing list of fields"
msgstr "липсва списък полета"

#. This is a proper name. See the gettext manual, section Names.
#: src/shred.c:74
msgid "Colin Plumb"
msgstr "Colin Plumb"

#: src/shred.c:171
#, fuzzy
msgid ""
"Overwrite the specified FILE(s) repeatedly, in order to make it harder\n"
"for even very expensive hardware probing to recover the data.\n"
msgstr ""
"Заличава многократно посочените ФАЙЛ(ове) с цел да се затрудни значително\n"
"възстановяването на данните от тях дори и с използване на специална "
"апаратура.\n"
"\n"

#: src/shred.c:175
#, fuzzy
msgid ""
"\n"
"If FILE is -, shred standard output.\n"
msgstr "Ако за ФАЙЛ е използвано „-“, се чете от стандартния вход."

#: src/shred.c:182
#, fuzzy, c-format
msgid ""
"  -f, --force    change permissions to allow writing if necessary\n"
"  -n, --iterations=N  overwrite N times instead of the default (%d)\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\n"
msgstr ""
"  -f, --force    ако трябва, променя режимът за достъп, за да се позволи "
"запис\n"
"  -n, --iterations=N  Заличава N пъти (по подразбиране %d пъти)\n"
"      --random-source=ФАЙЛ  чете случайни байтове от ФАЙЛ (вместо /dev/"
"urandom)\n"
"  -s, --size=N   заличава N байта (приемат се суфикси като K, M, G)\n"

#: src/shred.c:188
#, fuzzy
msgid ""
"  -u             deallocate and remove file after overwriting\n"
"      --remove[=HOW]  like -u but give control on HOW to delete;  See below\n"
"  -v, --verbose  show progress\n"
"  -x, --exact    do not round file sizes up to the next full block;\n"
"                   this is the default for non-regular files\n"
"  -z, --zero     add a final overwrite with zeros to hide shredding\n"
msgstr ""
"  -u, --remove   съкращава до нулева дължина и изтрива файла след "
"заличаването\n"
"  -v, --verbose  показва информация за напредъка\n"
"  -x, --exact    не закръглява размерите на файловете до следващия пълен "
"блок;\n"
"                   за специални файлове и каталози това е по подразбиране\n"
"  -z, --zero     накрая заличава с нули, за да се скрие използването на "
"shred\n"

#: src/shred.c:198
#, fuzzy
msgid ""
"\n"
"Delete FILE(s) if --remove (-u) is specified.  The default is not to remove\n"
"the files because it is common to operate on device files like /dev/hda,\n"
"and those files usually should not be removed.\n"
"The optional HOW parameter indicates how to remove a directory entry:\n"
"'unlink' => use a standard unlink call.\n"
"'wipe' => also first obfuscate bytes in the name.\n"
"'wipesync' => also sync each obfuscated byte to disk.\n"
"The default mode is 'wipesync', but note it can be expensive.\n"
"\n"
msgstr ""
"\n"
"Ако ФАЙЛ е -, заличава стандартния изход.\n"
"\n"
"Изтрива ФАЙЛ(овете), ако е посочена опция --remove (-u).  По подразбиране\n"
"файловете не се изтриват, защото е обичайно shred да се използва за "
"устройства\n"
"като /dev/hda, а обикновено такива файлове не трябва да се изтриват.  Когато "
"се\n"
"действа върху обикновени файлове, повечето хора използват опцията --remove.\n"
"\n"

#: src/shred.c:210
msgid ""
"CAUTION: Note that shred relies on a very important assumption:\n"
"that the file system overwrites data in place.  This is the traditional\n"
"way to do things, but many modern file system designs do not satisfy this\n"
"assumption.  The following are examples of file systems on which shred is\n"
"not effective, or is not guaranteed to be effective in all file system "
"modes:\n"
"\n"
msgstr ""
"ВНИМАНИЕ: Забележете, че shred разчита на следното съществено "
"предположение:\n"
"файловата система заличава данните на мястото им.  Традиционно се прави "
"точно\n"
"това, но замисълът на много от модерните файлови системи е такъв, че те не\n"
"отговарят на това предположение.  Следват примери на файлови системи, при "
"които\n"
"shred не е ефективна команда или поне не се гарантира да бъде ефективна при\n"
"всички режими на работа на файловата система:\n"
"\n"

#: src/shred.c:218
msgid ""
"* log-structured or journaled file systems, such as those supplied with\n"
"AIX and Solaris (and JFS, ReiserFS, XFS, Ext3, etc.)\n"
"\n"
"* file systems that write redundant data and carry on even if some writes\n"
"fail, such as RAID-based file systems\n"
"\n"
"* file systems that make snapshots, such as Network Appliance's NFS server\n"
"\n"
msgstr ""
"- log-структурираните или журнални файлови системи като JFS, ReiserFS, XFS,\n"
"  Ext3 (включително файловите системи, разпространявани с AIX и Solaris)\n"
"\n"
"- файловите системи, които записват излишни данни и ги пазят, дори когато "
"някой\n"
"  записва върху файла, например файловите системи, използващи RAID\n"
"\n"
"- файловите системи, които правят копия, като напр. NFS-сървърът на\n"
"  Network Appliance\n"
"\n"

#: src/shred.c:228
msgid ""
"* file systems that cache in temporary locations, such as NFS\n"
"version 3 clients\n"
"\n"
"* compressed file systems\n"
"\n"
msgstr ""

#: src/shred.c:235
#, fuzzy
msgid ""
"In the case of ext3 file systems, the above disclaimer applies\n"
"(and shred is thus of limited effectiveness) only in data=journal mode,\n"
"which journals file data in addition to just metadata.  In both the\n"
"data=ordered (default) and data=writeback modes, shred works as usual.\n"
"Ext3 journaling modes can be changed by adding the data=something option\n"
"to the mount options for a particular file system in the /etc/fstab file,\n"
"as documented in the mount man page (man mount).\n"
"\n"
msgstr ""
"- файловите системи които кешират информацията на временни места, например\n"
"  клиентите на NFS, версия 3\n"
"\n"
"- компресиращите файлови системи\n"
"\n"
"По отношение на файловата система ext3 горното предупреждение е приложимо\n"
"(и следователно shred е с ограничена ефективност) само в режим "
"data=journal,\n"
"при който освен метаданните и данните от файловете влизат в журнала.  Както "
"при\n"
"data=ordered (по подразбиране), така и при data=writeback, shred работи\n"
"както трябва.  Журналният режим на Ext3 може да бъде избран посредством\n"
"добавяне на опция data=нещо към опциите при монтиране на съответната "
"файлова\n"
"система във файла /etc/fstab, както това е описано в man-страницата на "
"mount\n"
"(използвайте: man mount).\n"
"\n"
"Трябва да се има предвид още и това, че резервните копия и отдалечени "
"огледала\n"
"също могат да съдържат копия на файла, които не могат да бъдат отстранени и\n"
"дават възможност заличеният със shred файл да бъде възстановен.\n"

#: src/shred.c:245
#, fuzzy
msgid ""
"In addition, file system backups and remote mirrors may contain copies\n"
"of the file that cannot be removed, and that will allow a shredded file\n"
"to be recovered later.\n"
msgstr ""
"- файлови системи, които кешират информацията на временни места, като "
"клиентите\n"
"  на NFS версия 3\n"
"\n"
"- компресираните файлови системи\n"
"\n"
"Освен това резервните копия на файловите системи могат да съдържат копия на\n"
"файла, които не могат да бъдат изтрити и които ще позволят по-късно "
"изтритият\n"
"файл да бъде възстановен.\n"

#: src/shred.c:344
#, c-format
msgid "%s: fdatasync failed"
msgstr "%s: неуспешно извикване на fdatasync"

#: src/shred.c:355
#, c-format
msgid "%s: fsync failed"
msgstr "%s: неуспешно извикване на fsync"

#: src/shred.c:472
#, c-format
msgid "%s: cannot rewind"
msgstr "%s: битовете не могат да се обръщат"

#: src/shred.c:492
#, c-format
msgid "%s: pass %lu/%lu (%s)..."
msgstr "%s: итерация %lu/%lu (%s)..."

#: src/shred.c:543
#, c-format
msgid "%s: error writing at offset %s"
msgstr "%s: грешка при запис на отместване %s"

#: src/shred.c:564
#, c-format
msgid "%s: lseek failed"
msgstr "%s: неуспешно извикване на lseek"

#: src/shred.c:576
#, c-format
msgid "%s: file too large"
msgstr "%s: файлът е твърде дълъг"

#: src/shred.c:600
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s"
msgstr "%s: итерация %lu/%lu (%s)...%s"

#: src/shred.c:616
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s/%s %d%%"
msgstr "%s: итерация %lu/%lu (%s)...%s/%s %d%%"

#: src/shred.c:874
#, c-format
msgid "%s: fstat failed"
msgstr "%s: неуспешно извикване на fstat"

#: src/shred.c:885
#, c-format
msgid "%s: invalid file type"
msgstr "%s: недопустим тип на файла"

#: src/shred.c:890
#, c-format
msgid "%s: file has negative size"
msgstr "%s: файлът има отрицателен размер"

#: src/shred.c:986 src/sort.c:976 src/split.c:475
#, c-format
msgid "%s: error truncating"
msgstr "%s: неуспешно съкращаване"

#: src/shred.c:1005
#, c-format
msgid "%s: fcntl failed"
msgstr "%s: неуспешно извикване на fcntl"

#: src/shred.c:1010
#, c-format
msgid "%s: cannot shred append-only file descriptor"
msgstr "%s: не може да се заличава файл с режим на достъп само за добавяне"

#: src/shred.c:1093
#, c-format
msgid "%s: removing"
msgstr "%s: изтриване"

#: src/shred.c:1118
#, c-format
msgid "%s: renamed to %s"
msgstr "%s: преименуван на %s"

#: src/shred.c:1127
#, c-format
msgid "%s: failed to remove"
msgstr "%s: не може да се отстрани"

#: src/shred.c:1131
#, c-format
msgid "%s: removed"
msgstr "%s: изтрит"

#: src/shred.c:1138 src/shred.c:1181
#, c-format
msgid "%s: failed to close"
msgstr "%s: не може да се затвори"

#: src/shred.c:1174
#, c-format
msgid "%s: failed to open for writing"
msgstr "%s: не може да се отвори в режим за писане"

#: src/shred.c:1237
#, fuzzy
msgid "invalid number of passes"
msgstr "Неправилен брой елементи"

#: src/shred.c:1242 src/shuf.c:462 src/sort.c:4512
msgid "multiple random sources specified"
msgstr "указани са множество източници на случайност"

#: src/shred.c:1256
#, fuzzy
msgid "invalid file size"
msgstr "Неправилен размер на запис"

#: src/shuf.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"  or:  %s -e [OPTION]... [ARG]...\n"
"  or:  %s -i LO-HI [OPTION]...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [ФАЙЛ]\n"
"     или: %s -e [ОПЦИЯ]… [АРГУМЕНТ]…\n"
"     или: %s -i ОТ-ДО [ОПЦИЯ]…\n"

#: src/shuf.c:68
#, fuzzy
msgid "Write a random permutation of the input lines to standard output.\n"
msgstr "Запис във файл с това ИМЕ вместо на стандартния изход"

#: src/shuf.c:75
#, fuzzy
msgid ""
"  -e, --echo                treat each ARG as an input line\n"
"  -i, --input-range=LO-HI   treat each number LO through HI as an input "
"line\n"
"  -n, --head-count=COUNT    output at most COUNT lines\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -r, --repeat              output lines can be repeated\n"
msgstr ""
"  -e, --echo                работи с всеки АРГУМЕНТ като с входен ред\n"
"  -i, --input-range=ОТ-ДО   работи с всяко число от ОТ до ДО като с входен "
"ред\n"
"  -n, --head-lines=БРОЙ     извежда най-много БРОЙ реда\n"
"  -o, --output=ФАЙЛ         извежда резултата във ФАЙЛ вместо на станд. "
"изход\n"
"      --random-source=ФАЙЛ  чете случайни байтове от ФАЙЛ (вместо /dev/"
"urandom)\n"
"  -z, --zero-terminated     завършва редовете с нулев байт вместо с нов ред\n"

#: src/shuf.c:226
#, fuzzy
msgid "too many input lines"
msgstr "не са зададени входни файлове"

#: src/shuf.c:418
msgid "multiple -i options specified"
msgstr "посочени са много опции -i"

#: src/shuf.c:425 src/shuf.c:431 src/shuf.c:436
#, fuzzy
msgid "invalid input range"
msgstr "Неправилен край на диапазон"

#: src/shuf.c:449
#, fuzzy, c-format
msgid "invalid line count: %s"
msgstr "%s: грешен номер на ред"

#: src/shuf.c:456 src/sort.c:4506
msgid "multiple output files specified"
msgstr "указани са множество изходни файлове"

#: src/shuf.c:486
#, c-format
msgid "cannot combine -e and -i options"
msgstr "не може да се комбинират опциите -e и -i"

#: src/shuf.c:570
msgid "no lines to repeat"
msgstr ""

#: src/sleep.c:44
#, c-format
msgid ""
"Usage: %s NUMBER[SUFFIX]...\n"
"  or:  %s OPTION\n"
"Pause for NUMBER seconds.  SUFFIX may be 's' for seconds (the default),\n"
"'m' for minutes, 'h' for hours or 'd' for days.  NUMBER need not be an\n"
"integer.  Given two or more arguments, pause for the amount of time\n"
"specified by the sum of their values.\n"
"\n"
msgstr ""
"Употреба: %s БРОЙ[СУФИКС]…\n"
"     или: %s ОПЦИЯ\n"
"Изчакване на този БРОЙ периоди — стандартно са секунди.  СУФИКСът може да "
"бъде\n"
"„s“ за секунди (стандартно), „m“ за минути, „h“ за часове или „d“ за дни.\n"
"БРОят трябва да бъде произволно число с плаваща запетая.  При повече от "
"един\n"
"аргументи се чака сумата от посочените времена.\n"
"\n"

#: src/sleep.c:132 src/timeout.c:332
#, c-format
msgid "invalid time interval %s"
msgstr "неправилен интервал за време „%s“"

#: src/sleep.c:143 src/tail.c:1311
msgid "cannot read realtime clock"
msgstr "часовникът в реално време не може да се чете"

#: src/sort.c:424
msgid "Write sorted concatenation of all FILE(s) to standard output.\n"
msgstr ""
"Извеждане на подреденото обединено съдържание на всички ФАЙЛ(ове) на "
"стандартния изход\n"

#: src/sort.c:431
msgid ""
"Ordering options:\n"
"\n"
msgstr ""
"Опции за подредба:\n"
"\n"

#: src/sort.c:435
msgid ""
"  -b, --ignore-leading-blanks  ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks не отчита интервалите в началото\n"
"  -d, --dictionary-order      отчита само интервалите и буквено-цифровите "
"знаци\n"
"  -f, --ignore-case           приравнява малките с главните букви\n"

#: src/sort.c:441
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n"
msgstr ""
"  -g, --general-numeric-sort  подредба като числа\n"
"  -i, --ignore-nonprinting    подредба само по видимите знаци, а не "
"интервалите\n"
"  -M, --month-sort            подредба като месеци: (друго) < „ЯНУ“ < … < "
"“ДЕК“\n"

#: src/sort.c:446
msgid ""
"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n"
msgstr ""
"  -h, --human-numeric-sort    „човешка“ подредба (със зачитане на 2K, 1G…)\n"

#: src/sort.c:449
msgid ""
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -R, --random-sort           shuffle, but group identical keys.  See "
"shuf(1)\n"
"      --random-source=FILE    get random bytes from FILE\n"
"  -r, --reverse               reverse the result of comparisons\n"
msgstr ""
"  -n, --numeric-sort          подредба според числовата стойност на "
"низовете\n"
"  -R, --random-sort           случайна подредба с групиране на еднаквите\n"
"                              ключове (вж. „shuf(1)“)\n"
"      --random-source=ФАЙЛ    четене на случайни байтове от ФАЙЛ (вместо\n"
"                              „/dev/urandom“)\n"
"  -r, --reverse               подредба в обратен ред\n"

#: src/sort.c:455
msgid ""
"      --sort=WORD             sort according to WORD:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          natural sort of (version) numbers within text\n"
"\n"
msgstr ""
"      --sort=ДУМА             подредба според ДУМАта:\n"
"                                „general-numeric“≡„-g“, „human-numeric“≡„-"
"h“,\n"
"                                „month“≡„-M“, „numeric“≡„-n“, „random“≡„-"
"R“,\n"
"                                „version“≡„-V“\n"
"  -V, --version-sort          естествена подредба като числа-версии\n"
"\n"

#: src/sort.c:463
msgid ""
"Other options:\n"
"\n"
msgstr ""
"Други опции:\n"
"\n"

#: src/sort.c:467
msgid ""
"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
"                            for more use temp files\n"
msgstr ""
"      --batch-size=БРОЙ     сливане на максимално такъв БРОЙ входа "
"наведнъж,\n"
"                            за повече да се ползват временни файлове\n"

#: src/sort.c:471
msgid ""
"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
"  -C, --check=quiet, --check=silent  like -c, but do not report first bad "
"line\n"
"      --compress-program=PROG  compress temporaries with PROG;\n"
"                              decompress them with PROG -d\n"
msgstr ""
"  -c, --check, --check=diagnose-first  само се проверява дали входните данни "
"са\n"
"                                       подредени, без подредба\n"
"  -C, --check=quiet, --check=silent    като „-c“, но без извеждане на "
"първия\n"
"                                       сгрешен ред\n"
"      --compress-program=ПРОГРАМА      компресиране на временните резултати "
"с\n"
"                                       тази ПРОГРАМА, декомпресиране с:\n"
"                                       „ПРОГРАМАта -d“\n"

#: src/sort.c:478
msgid ""
"      --debug               annotate the part of the line used to sort,\n"
"                              and warn about questionable usage to stderr\n"
"      --files0-from=F       read input from the files specified by\n"
"                            NUL-terminated names in file F;\n"
"                            If F is - then read names from standard input\n"
msgstr ""
"      --debug               анотиране на частта от реда, използвана за\n"
"                            подредбата и предупреждаване за неправилна "
"употреба\n"
"                            на стандартната грешка\n"
"      --files0-from=ФАЙЛ    за вход се ползват файловете изброени в този "
"ФАЙЛ,\n"
"                            разделени с нулев знак.  Имената се изчитат от\n"
"                            стандартния вход, ако ФАЙЛът е „-“\n"

#: src/sort.c:485
msgid ""
"  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
"  -m, --merge               merge already sorted files; do not sort\n"
msgstr ""
"  -k, --key=КЛЮЧ            подредба според мястото и вида на дадения КЛЮЧ\n"
"  -m, --merge               сливане на вече подредени файлове, не се "
"извършва\n"
"                            допълнително подреждане\n"

#: src/sort.c:489
msgid ""
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"  -o, --output=ФАЙЛ         запазване на резултата във ФАЙЛа вместо на\n"
"                            стандартния изход\n"
"  -s, --stable              стабилна подредба, прескачане на последната/\n"
"                            резервната\n"
"  -S, --buffer-size=РАЗМЕР  използване на буфер в паметта с този РАЗМЕР\n"

#: src/sort.c:495
#, c-format
msgid ""
"  -t, --field-separator=SEP  use SEP instead of non-blank to blank "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or "
"%s;\n"
"                              multiple options specify multiple directories\n"
"      --parallel=N          change the number of sorts run concurrently to "
"N\n"
"  -u, --unique              with -c, check for strict ordering;\n"
"                              without -c, output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=РАЗДЕЛИТЕЛ\n"
"                            използване на този РАЗДЕЛИТЕЛ вместо преход от "
"видим\n"
"                            знак към интервал\n"
"  -T, --temporary-directory=ДИРЕКТОРИЯ\n"
"                            използване на тази ДИРЕКТОРИЯ директория за "
"временни\n"
"                            файлове вместо „$TMPDIR“ или „%s“.  Задайте  "
"няколко\n"
"                            такива опции за няколко директории\n"
"      --parallel=БРОЙ       ползване на този БРОЙ паралелни подредби\n"
"  -u, --unique              с „-c“ проверка за строга наредба, иначе се\n"
"                            извежда само първият от група еквивалентни "
"редове\n"

#: src/sort.c:509
msgid ""
"\n"
"KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is "
"a\n"
"field number and C a character position in the field; both are origin 1, "
"and\n"
"the stop position defaults to the line's end.  If neither -t nor -b is in\n"
"effect, characters in a field are counted from the beginning of the "
"preceding\n"
"whitespace.  OPTS is one or more single-letter ordering options "
"[bdfgiMhnRrV],\n"
"which override global ordering options for that key.  If no key is given, "
"use\n"
"the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"\n"
"КЛЮЧът е ПОЛЕ[.ЗНАК][ОПЦИИ][,ПОЛЕ[.ЗНАК][ОПЦИИ]] за началната и крайната\n"
"позиции, където номерът на ПОЛЕто и мястото на ЗНАКа в полето се броят от "
"1.\n"
"Когато не е указан край се използва редът до края му, а ако не е зададен "
"КЛЮЧ,\n"
"се използва целият ред.  Ако не е зададена някоя от опциите „-t“ и „-b“,\n"
"знаците в полето се броят от началото на предхождащото бяло поле.  ОПЦИИте "
"са\n"
"подмножество на „bdfgiMhnRrV“ и задават подредбата с приоритет пред "
"глобалните\n"
"опции за наредба на това поле.\n"
"\n"
"РАЗМЕРът може да бъде следван от някой от следните множители:\n"

#: src/sort.c:522
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"% 1% от паметта, b 1, K 1024 (стандартно) и т.н. за M, G, T, P, E, Z, Y.\n"
"\n"
"••• ВНИМАНИЕ •••\n"
"Локалът, посочен в обкръжението, влияе на подредбата!\n"
"Използвайте LC_ALL=C, за да получите традиционната, при която се сравнява "
"според\n"
"стойността на байтовете.\n"

#: src/sort.c:720
#, c-format
msgid "waiting for %s [-d]"
msgstr "изчакване на „%s“ [-d]"

#: src/sort.c:725
#, c-format
msgid "%s [-d] terminated abnormally"
msgstr "„%s“ [-d] бе прекратен неочаквано"

#: src/sort.c:880
#, c-format
msgid "cannot create temporary file in %s"
msgstr "не може да се създаде временен файл в „%s“"

#: src/sort.c:995 src/sort.c:2104 src/sort.c:3141 src/sort.c:3784
#: src/sort.c:3875 src/sort.c:3878
msgid "open failed"
msgstr "неуспешно отваряне"

#: src/sort.c:1015
msgid "fflush failed"
msgstr "неуспешно изчистване на буферите с „fflush“"

#: src/sort.c:1020 src/sort.c:2107 src/sort.c:4782
msgid "close failed"
msgstr "неуспешно затваряне"

#: src/sort.c:1159
msgid "couldn't create temporary file"
msgstr "неуспешно създаване на временен файл"

#: src/sort.c:1198
#, c-format
msgid "couldn't create process for %s -d"
msgstr "неуспешно създаване на процес за „%s -d“"

#: src/sort.c:1271
#, c-format
msgid "warning: cannot remove: %s"
msgstr "ПРЕДУПРЕЖДЕНИЕ: „%s“ не може да се изтрие"

#: src/sort.c:1357
#, c-format
msgid "invalid --%s argument %s"
msgstr "неправилен аргумент „%2$s“ за опцията „--%1$s“"

#: src/sort.c:1360
#, c-format
msgid "minimum --%s argument is %s"
msgstr "минималният аргумент за опцията „--%s“ е „%s“"

#: src/sort.c:1375
#, c-format
msgid "--%s argument %s too large"
msgstr "аргументът „%2$s“ за опцията „--%1$s“ е прекалено голям"

#: src/sort.c:1378
#, c-format
msgid "maximum --%s argument with current rlimit is %s"
msgstr "максималният аргумент, който опцията „--%s“ приема в момента, е: %s"

#: src/sort.c:1460
msgid "number in parallel must be nonzero"
msgstr "паралелността не може да е 0"

#: src/sort.c:1543
msgid "stat failed"
msgstr "неуспешно изпълнение на „stat“"

#: src/sort.c:1805
msgid "read failed"
msgstr "неуспешно прочитане"

#: src/sort.c:2122
#, c-format
msgid "string transformation failed"
msgstr "неуспешно преобразуване на низове"

#: src/sort.c:2125
#, c-format
msgid "the untransformed string was %s"
msgstr "непреобразуваният низ бе „%s“"

#: src/sort.c:2288
#, c-format
msgid "^ no match for key\n"
msgstr "↑ няма съвпадение по ключа\n"

#: src/sort.c:2460
#, c-format
msgid "obsolescent key %s used; consider %s instead"
msgstr "използваният ключ „%s“ е остарял, заменете го с „%s“"

#: src/sort.c:2467
#, c-format
msgid "key %lu has zero width and will be ignored"
msgstr "ключ №%lu е с нулева дължина и се прескача"

#: src/sort.c:2476
#, c-format
msgid "leading blanks are significant in key %lu; consider also specifying 'b'"
msgstr ""
"водещите интервали се значими за ключ №%lu.  Може да укажете и опцията „b“"

#: src/sort.c:2489
#, c-format
msgid "key %lu is numeric and spans multiple fields"
msgstr "ключ №%lu е число и заема няколко полета"

#: src/sort.c:2521
#, c-format
msgid "option '-%s' is ignored"
msgid_plural "options '-%s' are ignored"
msgstr[0] "опцията „-%s“ се прескача"
msgstr[1] "опциите „-%s“ се прескачат"

#: src/sort.c:2527
#, c-format
msgid "option '-r' only applies to last-resort comparison"
msgstr "опцията „-r“ се отнася само за последната (резервна) подредба"

#: src/sort.c:2801 src/sort.c:2810
msgid "write failed"
msgstr "неуспешен запис"

#: src/sort.c:2853
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s: %s:%s: разбърканост: "

#: src/sort.c:2856
msgid "standard error"
msgstr "стандартна грешка"

#: src/sort.c:3768
msgid "cannot read"
msgstr "не може да се прочете"

#: src/sort.c:4047
#, c-format
msgid "%s: invalid field specification %s"
msgstr "%s: неправилно указано поле — „%s“"

#: src/sort.c:4057
#, c-format
msgid "options '-%s' are incompatible"
msgstr "опциите „-%s“ са несъвместими"

#: src/sort.c:4107
#, c-format
msgid "%s: invalid count at start of %s"
msgstr "%s: грешен номер на ред в началото на „%s“"

#: src/sort.c:4366
msgid "invalid number after '-'"
msgstr "грешно число след „--“"

#: src/sort.c:4373 src/sort.c:4459 src/sort.c:4487
msgid "invalid number after '.'"
msgstr "грешно число след „.“"

#: src/sort.c:4386 src/sort.c:4492
msgid "stray character in field spec"
msgstr "излишен знак в указателя на поле"

#: src/sort.c:4433
msgid "multiple compress programs specified"
msgstr "указани са множество програми за компресиране"

#: src/sort.c:4450
msgid "invalid number at field start"
msgstr "неправилно число в началото на поле"

#: src/sort.c:4454 src/sort.c:4482
msgid "field number is zero"
msgstr "номерът на поле е 0"

#: src/sort.c:4463
msgid "character offset is zero"
msgstr "отместването по знак е 0"

#: src/sort.c:4478
msgid "invalid number after ','"
msgstr "неправилно число след „.“"

#: src/sort.c:4528
msgid "empty tab"
msgstr "празна табулация"

#: src/sort.c:4611 src/wc.c:784
#, c-format
msgid "cannot read file names from %s"
msgstr "имената на файловете не могат да се прочетат от „%s“"

#: src/sort.c:4633
#, c-format
msgid "%s:%lu: invalid zero-length file name"
msgstr "„%s:%lu“: име с нулева дължина е неправилно за файл"

#: src/sort.c:4639
#, c-format
msgid "no input from %s"
msgstr "няма вход от „%s“"

#: src/sort.c:4692
#, c-format
msgid "text ordering performed using %s sorting rules"
msgstr "подредба според правилата „%s“"

#: src/sort.c:4696
msgid "text ordering performed using simple byte comparison"
msgstr "подредба чрез побайтово сравнение"

#: src/sort.c:4728
#, c-format
msgid "extra operand %s not allowed with -%c"
msgstr "опцията „-%2$c“ е несъвместима с допълнителния операнд „%1$s“"

#: src/split.c:209
#, c-format
msgid "the suffix length needs to be at least %<PRIuMAX>"
msgstr "дължината на суфикса трябва да е поне %<PRIuMAX>"

#: src/split.c:226
#, c-format
msgid "Usage: %s [OPTION]... [FILE [PREFIX]]\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ФАЙЛ[ПРЕФИКС]]\n"

#: src/split.c:230
msgid ""
"Output pieces of FILE to PREFIXaa, PREFIXab, ...;\n"
"default size is 1000 lines, and default PREFIX is 'x'.\n"
msgstr ""
"Разделя ВХОДа на парчета ПРЕФИКСaa, ПРЕФИКСab,… с фиксиран размер.\n"
"Стандартно ПРЕФИКСът е „x“, а размерът — 1000 реда.\n"

#: src/split.c:238
#, c-format
msgid ""
"  -a, --suffix-length=N   generate suffixes of length N (default %d)\n"
"      --additional-suffix=SUFFIX  append an additional SUFFIX to file names\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file\n"
"  -d                      use numeric suffixes starting at 0, not "
"alphabetic\n"
"      --numeric-suffixes[=FROM]  same as -d, but allow setting the start "
"value\n"
"  -x                      use hex suffixes starting at 0, not alphabetic\n"
"      --hex-suffixes[=FROM]  same as -x, but allow setting the start value\n"
"  -e, --elide-empty-files  do not generate empty output files with '-n'\n"
"      --filter=COMMAND    write to shell COMMAND; file name is $FILE\n"
"  -l, --lines=NUMBER      put NUMBER lines/records per output file\n"
"  -n, --number=CHUNKS     generate CHUNKS output files; see explanation "
"below\n"
"  -t, --separator=SEP     use SEP instead of newline as the record "
"separator;\n"
"                            '\\0' (zero) specifies the NUL character\n"
"  -u, --unbuffered        immediately copy input to output with '-n r/...'\n"
msgstr ""
"-a, --suffix-length=ДЪЛЖИНА\n"
"                          суфиксите да са с тази ДЪЛЖИНА (стандартно — %d)\n"
"      --additional-suffix=СУФИКС\n"
"                          добавяне на този СУФИКС към имената на файловете\n"
"  -b, --bytes=БАЙТОВЕ     изходните файлове да съдържат този брой БАЙТОВЕ\n"
"  -C, --line-bytes=РАЗМЕР включване на записи с максимално този кумулативен\n"
"                          размер във всеки изходен файл\n"
"  -d                      десетични суфикси, почващи от 0\n"
"      --numeric-suffixes[=НАЧАЛО]\n"
"                          като „-d“, но може да зададете НАЧАЛОто\n"
"  -x                      шестнадесетични суфикси, почващи от 0\n"
"      --hex-suffixes[=НАЧАЛО]\n"
"                          като „-x“, но може да зададете НАЧАЛОто\n"
"  -e, --elide-empty-files без генериране на празни изходни файлове при "
"ползване\n"
"                          на „-n“\n"
"      --filter=КОМАНДА    запис към тази КОМАНДА, името на файл е „$FILE“\n"
"  -l, --lines=БРОЙ        извеждане на този БРОЙ редове/записи в изходен "
"файл\n"
"  -n, --number=БРОЙ       извеждане на този БРОЙ изходни файлове, вж. по-"
"долу\n"
"  -t, --separator=РАЗДЕЛИТЕЛ\n"
"                          разделяне на записите с този РАЗДЕЛИТЕЛ вместо нов "
"ред,\n"
"                          за нулев байт използвайте „\\0“\n"
"  -u, --unbuffered        незабавно копиране на входа към изхода с „-n r/…“\n"

#: src/split.c:256
msgid ""
"      --verbose           print a diagnostic just before each\n"
"                            output file is opened\n"
msgstr ""
"      --verbose           извеждане на диагностично съобщение преди "
"отварянето\n"
"                          на всеки изходен файл\n"

#: src/split.c:263
msgid ""
"\n"
"CHUNKS may be:\n"
"  N       split into N files based on size of input\n"
"  K/N     output Kth of N to stdout\n"
"  l/N     split into N files without splitting lines/records\n"
"  l/K/N   output Kth of N to stdout without splitting lines/records\n"
"  r/N     like 'l' but use round robin distribution\n"
"  r/K/N   likewise but only output Kth of N to stdout\n"
msgstr ""
"\n"
"ПАРЧЕТАта може да са:\n"
"  N       разделяне на такъв брой файлове на базата на размера на входа\n"
"  K/N     извеждане на всеки K-ти от общо N файла на стандартния изход\n"
"  l/N     разделяне на N файла без разделяне на редове/записи\n"
"  l/K/N   извеждане на всеки K-ти от общо N файл без разделяне на редове/"
"записи\n"
"          на стандартния изход\n"
"  r/N     като „l“ но с последователно разпределение\n"
"  r/K/N   същото като „r/N“ и с извеждане на всеки K-ти от общо N на "
"стандартния\n"
"          изход\n"

#: src/split.c:450
msgid "output file suffixes exhausted"
msgstr "суфиксите за изходни файлове се изчерпаха"

#: src/split.c:462
#, c-format
msgid "creating file %s\n"
msgstr "създава се файл „%s“\n"

#: src/split.c:471
#, c-format
msgid "%s would overwrite input; aborting"
msgstr "„%s“ ще презапише изхода, отказ на изпълнение"

#: src/split.c:488
msgid "failed to set FILE environment variable"
msgstr "променливата от обкръжението „FILE“ не може да се зададе"

#: src/split.c:490
#, c-format
msgid "executing with FILE=%s\n"
msgstr "изпълнение с „FILE=%s“\n"

#: src/split.c:492
msgid "failed to create pipe"
msgstr "неуспешно създаване на програмен канал"

#: src/split.c:506
msgid "closing prior pipe"
msgstr "предишният програмен канал се затваря"

#: src/split.c:508
msgid "closing output pipe"
msgstr "затваряне на изходния програмен канал"

#: src/split.c:512
msgid "moving input pipe"
msgstr "преместване на входния програмен канал"

#: src/split.c:514
msgid "closing input pipe"
msgstr "затваряне на входния програмен канал"

#: src/split.c:519
#, c-format
msgid "failed to run command: \"%s -c %s\""
msgstr "неуспешно изпълнение на командата „%s -c %s“"

#: src/split.c:525
msgid "failed to close input pipe"
msgstr "неуспешна затваряне на входния програмен канал"

#: src/split.c:561
msgid "waiting for child process"
msgstr "изчакване на дъщерния процес"

#: src/split.c:571
#, c-format
msgid "with FILE=%s, signal %s from command: %s"
msgstr "при „FILE=%s“, сигнал %s от командата „%s“"

#: src/split.c:579
#, c-format
msgid "with FILE=%s, exit %d from command: %s"
msgstr "при „FILE=%s“, код за изход %d от командата „%s“"

#: src/split.c:586
#, c-format
msgid "unknown status from command (0x%X)"
msgstr "непознат код за състояние от команда (0x%X)"

#: src/split.c:1274
#, c-format
msgid "cannot split in more than one way"
msgstr "не може да се разделя по повече от един начин"

#: src/split.c:1286 src/split.c:1401 src/split.c:1602
msgid "invalid number of chunks"
msgstr "неправилен брой парчета"

#: src/split.c:1291
msgid "invalid chunk number"
msgstr "неправилен номер на парче"

#: src/split.c:1338
msgid "invalid suffix length"
msgstr "неправилна дължина на суфикс"

#: src/split.c:1412
msgid "empty record separator"
msgstr "празен разделител на записи"

#: src/split.c:1423
#, c-format
msgid "multi-character separator %s"
msgstr "разделител от множество знаци „%s“"

#: src/split.c:1431
msgid "multiple separator characters specified"
msgstr "указани да множество знаци за разделители"

#: src/split.c:1462
#, c-format
msgid "line count option -%s%c... is too large"
msgstr "опцията за брой редове „-%s%c“… е твърде голямa"

#: src/split.c:1479
#, c-format
msgid "%s: invalid start value for numerical suffix"
msgstr "%s: неправилна начална стойност за числов суфикс"

#: src/split.c:1480
#, c-format
msgid "%s: invalid start value for hexadecimal suffix"
msgstr "%s: неправилна начална стойност за шестнадесетичен суфикс"

#: src/split.c:1504
msgid "invalid IO block size"
msgstr "неправилен размер на входно/изходен блок: %s"

#: src/split.c:1522
#, c-format
msgid "--filter does not process a chunk extracted to stdout"
msgstr ""
"опцията „--filter“ не се прилага към парчета, изведени на стандартния вход"

#: src/split.c:1562
#, c-format
msgid "numerical suffix start value is too large for the suffix length"
msgstr ""
"началната стойност на числовия суфикс е прекалено голяма за дължината му"

#: src/split.c:1594
#, c-format
msgid "%s: cannot determine file size"
msgstr "%s: размерът на файла не може да бъде определен"

#. This is a proper name. See the gettext manual, section Names.
#: src/stat.c:190
msgid "Michael Meskes"
msgstr "Michael Meskes"

#: src/stat.c:951
#, fuzzy, c-format
msgid "failed to canonicalize %s"
msgstr "променливата на средата „%s“ не може да се зададе"

#: src/stat.c:1238
#, fuzzy, c-format
msgid "warning: unrecognized escape '\\%c'"
msgstr "ВНИМАНИЕ: непознато екраниране „\\%c“"

#: src/stat.c:1293
#, c-format
msgid "%s: invalid directive"
msgstr "%s: неправилна команда"

#: src/stat.c:1340
#, c-format
msgid "warning: backslash at end of format"
msgstr "внимание: обратна наклонена черта в края на форматен низ"

#: src/stat.c:1371
#, c-format
msgid "using %s to denote standard input does not work in file system mode"
msgstr ""

#: src/stat.c:1378
#, c-format
msgid "cannot read file system information for %s"
msgstr "не може да се прочете от файловата система информация за %s"

#: src/stat.c:1399
#, fuzzy, c-format
msgid "cannot stat standard input"
msgstr "Стандартният вход не може да се затвори"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' with --file-system, and NOT from printf.
#: src/stat.c:1435
msgid ""
"  File: \"%n\"\n"
"    ID: %-8i Namelen: %-7l Type: %T\n"
"Block size: %-10s Fundamental block size: %S\n"
"Blocks: Total: %-10b Free: %-10f Available: %a\n"
"Inodes: Total: %-10c Free: %d\n"
msgstr ""

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1456
msgid ""
"  File: %N\n"
"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
msgstr ""

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1466
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %-5h Device type: %t,%T\n"
msgstr ""

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1474
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
msgstr ""

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1483
msgid "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
msgstr ""

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1493
#, c-format
msgid "Context: %C\n"
msgstr ""

#: src/stat.c:1501
msgid ""
"Access: %x\n"
"Modify: %y\n"
"Change: %z\n"
" Birth: %w\n"
msgstr ""

#: src/stat.c:1519
msgid "Display file or file system status.\n"
msgstr ""

#: src/stat.c:1525
#, fuzzy
msgid ""
"  -L, --dereference     follow links\n"
"  -f, --file-system     display file system status instead of file status\n"
msgstr ""
"Извежда състоянието на файл или файлова система.\n"
"\n"
"  -L, --dereference     следва символните връзки\n"
"  -f, --file-system     извежда състоянието на файловата система, вместо на "
"файла\n"

#: src/stat.c:1529
#, fuzzy
msgid ""
"  -c  --format=FORMAT   use the specified FORMAT instead of the default;\n"
"                          output a newline after each use of FORMAT\n"
"      --printf=FORMAT   like --format, but interpret backslash escapes,\n"
"                          and do not output a mandatory trailing newline;\n"
"                          if you want a newline, include \\n in FORMAT\n"
"  -t, --terse           print the information in terse form\n"
msgstr ""
"  -c  --format=ФОРМАТ   да се използва посоченият ФОРМАТ, вместо "
"подразбиращия се;\n"
"                          да се изведе нов ред след всяко използване на "
"ФОРМАТ\n"
"      --printf=ФОРМАТ   като --format, но да се интерпретират обратно "
"наклонените черти\n"
"                          и да не се извежда задължителния завършващ нов "
"ред.\n"
"                          Ако искате нов ред, вмъкнете \\n във ФОРМАТ.\n"
"  -t, --terse           информацията да се извежда в сбита форма\n"

#: src/stat.c:1540
#, fuzzy
msgid ""
"\n"
"The valid format sequences for files (without --file-system):\n"
"\n"
"  %a   access rights in octal (note '#' and '0' printf flags)\n"
"  %A   access rights in human readable form\n"
"  %b   number of blocks allocated (see %B)\n"
"  %B   the size in bytes of each block reported by %b\n"
"  %C   SELinux security context string\n"
msgstr ""
"\n"
"Допустими ФОРМАТи за файлове (без --file-system) са:\n"
"\n"
"  %a   Режим за достъп като осмично число\n"
"  %A   Режим за достъп във формат удобен за четене от хора\n"
"  %b   Брой заделени блокове (вж. %B)\n"
"  %B   Размерът в байтове на всеки блок, съобщен от %b\n"

#: src/stat.c:1549
#, fuzzy
msgid ""
"  %d   device number in decimal\n"
"  %D   device number in hex\n"
"  %f   raw mode in hex\n"
"  %F   file type\n"
"  %g   group ID of owner\n"
"  %G   group name of owner\n"
msgstr ""
"  %d   Десетичен номер на устройство\n"
"  %D   Шестнадесетичен номер на устройство\n"
"  %f   Шестнадесетичен суров режим (raw mode)\n"
"  %F   Тип на файла\n"
"  %g   Номер на групата на собственика\n"
"  %G   Име на групата на собственика\n"

#: src/stat.c:1557
#, fuzzy
msgid ""
"  %h   number of hard links\n"
"  %i   inode number\n"
"  %m   mount point\n"
"  %n   file name\n"
"  %N   quoted file name with dereference if symbolic link\n"
"  %o   optimal I/O transfer size hint\n"
"  %s   total size, in bytes\n"
"  %t   major device type in hex, for character/block device special files\n"
"  %T   minor device type in hex, for character/block device special files\n"
msgstr ""
"  %h   Брой твърди връзки\n"
"  %i   Номер на i-възел\n"
"  %n   Име на файла\n"
"  %N   Име на файла в кавички и сочен файл, ако е символна връзка\n"
"  %o   размер на входно-изходния блок\n"
"  %s   Общ размер в байтове\n"
"  %t   Голям шестнадесетичен номер на устройство\n"
"  %T   Малък шестнадесетичен номер на устройство\n"

#: src/stat.c:1568
#, fuzzy
msgid ""
"  %u   user ID of owner\n"
"  %U   user name of owner\n"
"  %w   time of file birth, human-readable; - if unknown\n"
"  %W   time of file birth, seconds since Epoch; 0 if unknown\n"
"  %x   time of last access, human-readable\n"
"  %X   time of last access, seconds since Epoch\n"
"  %y   time of last data modification, human-readable\n"
"  %Y   time of last data modification, seconds since Epoch\n"
"  %z   time of last status change, human-readable\n"
"  %Z   time of last status change, seconds since Epoch\n"
"\n"
msgstr ""
"  %u   Потребителски номер на собственика\n"
"  %U   Потребителско име на собственика\n"
"  %x   Време на последен достъп\n"
"  %X   Време на последен достъп в секунди от Епохата\n"
"  %y   Време на последно изменение (modification)\n"
"  %Y   Време на последно изменение в секунди от Епохата\n"
"  %z   Време на последна промяна (change)\n"
"  %Z   Време на последна промяна в секунди от Епохата\n"
"\n"

#: src/stat.c:1582
#, fuzzy
msgid ""
"Valid format sequences for file systems:\n"
"\n"
"  %a   free blocks available to non-superuser\n"
"  %b   total data blocks in file system\n"
"  %c   total file nodes in file system\n"
"  %d   free file nodes in file system\n"
"  %f   free blocks in file system\n"
msgstr ""
"Валидни формати за файловите системи са:\n"
"\n"
"  %a   Свободни блокове, достъпни за обикновени потребители\n"
"  %b   Общ брой блокове за данни във файловата система\n"
"  %c   Общ брой файлови възли във файловата система\n"
"  %d   Свободни файлови възли във файловата система\n"
"  %f   Свободни блокове във файловата система\n"

#: src/stat.c:1591
#, fuzzy
msgid ""
"  %i   file system ID in hex\n"
"  %l   maximum length of filenames\n"
"  %n   file name\n"
"  %s   block size (for faster transfers)\n"
"  %S   fundamental block size (for block counts)\n"
"  %t   file system type in hex\n"
"  %T   file system type in human readable form\n"
msgstr ""
"  %i   Шестнадесетичен индекс на файловата система\n"
"  %l   Максимална дължина на файловите имена\n"
"  %n   Име на файла\n"
"  %s   Оптимален размер на блока за бърз трансфер\n"
"  %S   Основен размер на блока (при броене на блоковете)\n"
"  %t   Типът като шестнадесетично число\n"
"  %T   Типът във вид за четене от човек\n"

#: src/stat.c:1601
#, c-format
msgid ""
"\n"
"--terse is equivalent to the following FORMAT:\n"
"    %s"
msgstr ""

#: src/stat.c:1612
#, c-format
msgid ""
"--terse --file-system is equivalent to the following FORMAT:\n"
"    %s"
msgstr ""

#: src/stdbuf.c:91
#, fuzzy, c-format
msgid "Usage: %s OPTION... COMMAND\n"
msgstr "Употреба: %s [ОПЦИЯ]… ФАЙЛ…\n"

#: src/stdbuf.c:92
msgid ""
"Run COMMAND, with modified buffering operations for its standard streams.\n"
msgstr ""

#: src/stdbuf.c:98
msgid ""
"  -i, --input=MODE   adjust standard input stream buffering\n"
"  -o, --output=MODE  adjust standard output stream buffering\n"
"  -e, --error=MODE   adjust standard error stream buffering\n"
msgstr ""

#: src/stdbuf.c:105
msgid ""
"\n"
"If MODE is 'L' the corresponding stream will be line buffered.\n"
"This option is invalid with standard input.\n"
msgstr ""

#: src/stdbuf.c:108
msgid ""
"\n"
"If MODE is '0' the corresponding stream will be unbuffered.\n"
msgstr ""

#: src/stdbuf.c:111
msgid ""
"\n"
"Otherwise MODE is a number which may be followed by one of the following:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"In this case the corresponding stream will be fully buffered with the "
"buffer\n"
"size set to MODE bytes.\n"
msgstr ""

#: src/stdbuf.c:118
msgid ""
"\n"
"NOTE: If COMMAND adjusts the buffering of its standard streams ('tee' does\n"
"for example) then that will override corresponding changes by 'stdbuf'.\n"
"Also some filters (like 'dd' and 'cat' etc.) don't use streams for I/O,\n"
"and are thus unaffected by 'stdbuf' settings.\n"
msgstr ""

#: src/stdbuf.c:243
#, fuzzy, c-format
msgid "failed to find %s"
msgstr "неуспешно задаване на двоичен режим за „%s“"

#: src/stdbuf.c:267 src/stdbuf.c:300
#, fuzzy, c-format
msgid "failed to update the environment with %s"
msgstr "променливата на средата „%s“ не може да бъде изтрита"

#: src/stdbuf.c:346
#, c-format
msgid "line buffering stdin is meaningless"
msgstr ""

#: src/stdbuf.c:377
#, c-format
msgid "you must specify a buffering mode option"
msgstr ""

#: src/stty.c:531
#, c-format
msgid ""
"Usage: %s [-F DEVICE | --file=DEVICE] [SETTING]...\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-a|--all]\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-g|--save]\n"
msgstr ""
"Употреба: %s [-F УСТРОЙСТВО | --file=УСТРОЙСТВО] [НАСТРОЙКА]…\n"
"     или: %s [-F УСТРОЙСТВО | --file=УСТРОЙСТВО] [-a|--all]\n"
"     или: %s [-F УСТРОЙСТВО | --file=УСТРОЙСТВО] [-g|--save]\n"

#: src/stty.c:537
msgid "Print or change terminal characteristics.\n"
msgstr ""

#: src/stty.c:543
#, fuzzy
msgid ""
"  -a, --all          print all current settings in human-readable form\n"
"  -g, --save         print all current settings in a stty-readable form\n"
"  -F, --file=DEVICE  open and use the specified DEVICE instead of stdin\n"
msgstr ""
"Извежда или променя характеристиките на терминала\n"
"\n"
"  -a, --all          извежда всички текущи настройки в удобен за четене вид\n"
"  -g, --save         извежда всички текущи настройки във формат, четим от "
"stty\n"
"  -F, --file=УСТРОЙСТВО отваря и използва посоченото УСТРОЙСТВО вместо стд."
"вход\n"

#: src/stty.c:550
msgid ""
"\n"
"Optional - before SETTING indicates negation.  An * marks non-POSIX\n"
"settings.  The underlying system defines which settings are available.\n"
msgstr ""
"\n"
"Минус преди НАСТРОЙКА показва отрицание.  Знак * означава не POSIX "
"настройка.\n"
"Кои настройки са допустими зависи от използваната система.\n"

#: src/stty.c:555
#, fuzzy
msgid ""
"\n"
"Special characters:\n"
msgstr "неправилен клас знаци"

#: src/stty.c:559
msgid " * discard CHAR  CHAR will toggle discarding of output\n"
msgstr ""

#: src/stty.c:564
msgid ""
" * dsusp CHAR    CHAR will send a terminal stop signal once input flushed\n"
msgstr ""

#: src/stty.c:568
#, fuzzy
msgid ""
"   eof CHAR      CHAR will send an end of file (terminate the input)\n"
"   eol CHAR      CHAR will end the line\n"
msgstr ""
"\n"
"Управляващи кодове:\n"
" * dsusp ЗНАК    ЗНАК ще изпрати сигнал terminal stop, когато входът "
"изпрати\n"
"   eof ЗНАК      ЗНАК ще изпрати сигнал край на файл (ще прекрати входа)\n"
"   eol ЗНАК      ЗНАК ще завърши реда\n"

#: src/stty.c:573
msgid " * eol2 CHAR     alternate CHAR for ending the line\n"
msgstr ""

#: src/stty.c:577
#, fuzzy
msgid ""
"   erase CHAR    CHAR will erase the last character typed\n"
"   intr CHAR     CHAR will send an interrupt signal\n"
"   kill CHAR     CHAR will erase the current line\n"
msgstr ""
" * eol2 ЗНАК     алтернативен ЗНАК за край на реда\n"
"   erase ЗНАК    ЗНАК ще изтрие последния въведен знак\n"
"   intr ЗНАК     ЗНАК ще изпрати сигнал за прекъсване\n"
"   kill ЗНАК     ЗНАК ще изтрие текущия ред\n"

#: src/stty.c:583
msgid " * lnext CHAR    CHAR will enter the next character quoted\n"
msgstr ""

#: src/stty.c:588
msgid " * status CHAR   CHAR will send an info signal\n"
msgstr ""

#: src/stty.c:592
msgid "   quit CHAR     CHAR will send a quit signal\n"
msgstr ""

#: src/stty.c:596
msgid " * rprnt CHAR    CHAR will redraw the current line\n"
msgstr ""

#: src/stty.c:600
#, fuzzy
msgid ""
"   start CHAR    CHAR will restart the output after stopping it\n"
"   stop CHAR     CHAR will stop the output\n"
"   susp CHAR     CHAR will send a terminal stop signal\n"
msgstr ""
"   stop ЗНАК     ЗНАК ще спре извеждането\n"
"   susp ЗНАК     ЗНАК ще изпрати сигнал „спиране на терминала“\n"
" * swtch ЗНАК    ЗНАК ще превключи на друг слой на обвивката (shell layer)\n"
" * werase ЗНАК   ЗНАК ще изтрие последната въведена дума\n"

#: src/stty.c:606
msgid " * swtch CHAR    CHAR will switch to a different shell layer\n"
msgstr ""

#: src/stty.c:611
msgid " * werase CHAR   CHAR will erase the last word typed\n"
msgstr ""

#: src/stty.c:615
#, fuzzy
msgid ""
"\n"
"Special settings:\n"
"   N             set the input and output speeds to N bauds\n"
msgstr ""
"\n"
"Специални настройки:\n"
"  N             посочва скорости за входа и изхода N бода\n"
" * cols N        казва на ядрото, че терминалът има N стълба\n"
" * columns N     същото като cols N\n"

#: src/stty.c:621
#, fuzzy
msgid ""
" * cols N        tell the kernel that the terminal has N columns\n"
" * columns N     same as cols N\n"
msgstr ""
"\n"
"Специални настройки:\n"
"  N             посочва скорости за входа и изхода N бода\n"
" * cols N        казва на ядрото, че терминалът има N стълба\n"
" * columns N     същото като cols N\n"

#: src/stty.c:626
#, c-format
msgid ""
" * [-]drain      wait for transmission before applying settings (%s by "
"default)\n"
msgstr ""

#: src/stty.c:628
#, fuzzy
msgid "on"
msgstr "Завършен"

#: src/stty.c:628
msgid "off"
msgstr ""

#: src/stty.c:629
msgid "   ispeed N      set the input speed to N\n"
msgstr ""

#: src/stty.c:633
msgid " * line N        use line discipline N\n"
msgstr ""

#: src/stty.c:637
#, fuzzy
msgid ""
"   min N         with -icanon, set N characters minimum for a completed "
"read\n"
"   ospeed N      set the output speed to N\n"
msgstr ""
"   ispeed N      посочва скорост на входа N бода\n"
" * line N        ползва редова дисциплина N\n"
"   min N         с -icanon посочва поне N знака за завършено четене\n"
"   ospeed N      посочва скорост на изхода N бода\n"

#: src/stty.c:642
#, fuzzy
msgid ""
" * rows N        tell the kernel that the terminal has N rows\n"
" * size          print the number of rows and columns according to the "
"kernel\n"
msgstr ""
" * rows N        казва на ядрото, че терминалът има N реда\n"
" * size          извежда броя редове и стълбове според ядрото\n"
"   speed         извежда скоростта на терминала\n"
"   time N       с -icanon посочва прекъсване при четене до N десети от "
"секундата\n"

#: src/stty.c:647
#, fuzzy
msgid ""
"   speed         print the terminal speed\n"
"   time N        with -icanon, set read timeout of N tenths of a second\n"
msgstr ""
" * rows N        казва на ядрото, че терминалът има N реда\n"
" * size          извежда броя редове и стълбове според ядрото\n"
"   speed         извежда скоростта на терминала\n"
"   time N       с -icanon посочва прекъсване при четене до N десети от "
"секундата\n"

#: src/stty.c:651
#, fuzzy
msgid ""
"\n"
"Control settings:\n"
"   [-]clocal     disable modem control signals\n"
"   [-]cread      allow input to be received\n"
msgstr ""
"\n"
"Управляващи настройки:\n"
"   [-]clocal     забранява сигналите управляващите сигнали за модем\n"
"   [-]cread      позволява да се получава входа\n"
" * [-]crtscts    позволява диалог (handshaking) RTS/CTS\n"
"   csN           посочва размер на знаците до N бита, N е от 5 до 8\n"

#: src/stty.c:658
msgid " * [-]crtscts    enable RTS/CTS handshaking\n"
msgstr ""

#: src/stty.c:663
msgid " * [-]cdtrdsr    enable DTR/DSR handshaking\n"
msgstr ""

#: src/stty.c:667
msgid "   csN           set character size to N bits, N in [5..8]\n"
msgstr ""

#: src/stty.c:670
#, fuzzy
msgid ""
"   [-]cstopb     use two stop bits per character (one with '-')\n"
"   [-]hup        send a hangup signal when the last process closes the tty\n"
"   [-]hupcl      same as [-]hup\n"
"   [-]parenb     generate parity bit in output and expect parity bit in "
"input\n"
"   [-]parodd     set odd parity (or even parity with '-')\n"
msgstr ""
"   [-]cstopb     използва два стоп-бита на знак (един с „-“)\n"
"   [-]hup        изпраща сигнал за увисване, ako всички процеси затворят "
"tty\n"
"   [-]hupcl      същото като [-]hup\n"
"   [-]parenb     генерира на изхода и очаква на входа бит за четност\n"
"   [-]parodd     посочва текова четност (четна с „-“)\n"

#: src/stty.c:678
msgid " * [-]cmspar     use \"stick\" (mark/space) parity\n"
msgstr ""

#: src/stty.c:682
#, fuzzy
msgid ""
"\n"
"Input settings:\n"
"   [-]brkint     breaks cause an interrupt signal\n"
"   [-]icrnl      translate carriage return to newline\n"
"   [-]ignbrk     ignore break characters\n"
"   [-]igncr      ignore carriage return\n"
"   [-]ignpar     ignore characters with parity errors\n"
msgstr ""
"\n"
"Настройки на входа:\n"
"   [-]brkint     прекъсванията да довеждат до сигнал за прекъсване\n"
"   [-]icrnl      превежда кодовете за връщане на курсора в кодове за нов "
"ред\n"
"   [-]ignbrk     пренебрегва знаците за прекъсване\n"
"   [-]igncr      пренебрегва знаците за връщане на курсора\n"

#: src/stty.c:692
msgid ""
" * [-]imaxbel    beep and do not flush a full input buffer on a character\n"
msgstr ""

#: src/stty.c:696
#, fuzzy
msgid ""
"   [-]inlcr      translate newline to carriage return\n"
"   [-]inpck      enable input parity checking\n"
"   [-]istrip     clear high (8th) bit of input characters\n"
msgstr ""
"   [-]ignpar     пренебрегва знаците с грешка на четността\n"
" * [-]imaxbel    звуков сигнал и запазване на препълнен буфер при нов знак\n"
"   [-]inlcr      превежда кодовете за нов ред в кодове за връщане на "
"курсора\n"
"   [-]inpck      позволява проверка за четността на входа\n"
"   [-]istrip     изчиства старшия (8-мия) бит на входните знаци\n"

#: src/stty.c:702
msgid " * [-]iutf8      assume input characters are UTF-8 encoded\n"
msgstr ""
" * [-]iutf8      да се предполага, че входните знаци са кодирани в UTF-8\n"

#: src/stty.c:707
#, fuzzy
msgid " * [-]iuclc      translate uppercase characters to lowercase\n"
msgstr ""
" * [-]iutf8      да се предполага, че входните знаци са кодирани в UTF-8\n"

#: src/stty.c:712
msgid ""
" * [-]ixany      let any character restart output, not only start character\n"
msgstr ""

#: src/stty.c:716
#, fuzzy
msgid ""
"   [-]ixoff      enable sending of start/stop characters\n"
"   [-]ixon       enable XON/XOFF flow control\n"
"   [-]parmrk     mark parity errors (with a 255-0-character sequence)\n"
"   [-]tandem     same as [-]ixoff\n"
msgstr ""
" * [-]iuclc      превежда знаците от горен регистър в долен регистър\n"
" * [-]ixany      всеки знак да рестартира извеждането (не само знака за "
"старт)\n"
"   [-]ixoff      позволява изпращането на знаци за старт/стоп\n"
"   [-]ixon       позволява управление на потока XON/XOFF (т.е. Ctrl-S/Ctrl-"
"Q)\n"
"   [-]parmrk     маркира грешките по четност (с последователност 255-0)\n"
"   [-]tandem     същото като [-]ixoff\n"

#: src/stty.c:722
msgid ""
"\n"
"Output settings:\n"
msgstr ""

#: src/stty.c:727
msgid " * bsN           backspace delay style, N in [0..1]\n"
msgstr ""

#: src/stty.c:732
msgid " * crN           carriage return delay style, N in [0..3]\n"
msgstr ""

#: src/stty.c:737
msgid " * ffN           form feed delay style, N in [0..1]\n"
msgstr ""

#: src/stty.c:742
msgid " * nlN           newline delay style, N in [0..1]\n"
msgstr ""

#: src/stty.c:747
msgid " * [-]ocrnl      translate carriage return to newline\n"
msgstr ""

#: src/stty.c:752
msgid ""
" * [-]ofdel      use delete characters for fill instead of NUL characters\n"
msgstr ""

#: src/stty.c:757
msgid ""
" * [-]ofill      use fill (padding) characters instead of timing for delays\n"
msgstr ""

#: src/stty.c:762
msgid " * [-]olcuc      translate lowercase characters to uppercase\n"
msgstr ""

#: src/stty.c:767
msgid " * [-]onlcr      translate newline to carriage return-newline\n"
msgstr ""

#: src/stty.c:772
msgid " * [-]onlret     newline performs a carriage return\n"
msgstr ""

#: src/stty.c:777
msgid " * [-]onocr      do not print carriage returns in the first column\n"
msgstr ""

#: src/stty.c:781
msgid "   [-]opost      postprocess output\n"
msgstr ""

#: src/stty.c:785
msgid ""
" * tabN          horizontal tab delay style, N in [0..3]\n"
" * tabs          same as tab0\n"
" * -tabs         same as tab3\n"
msgstr ""

#: src/stty.c:792
msgid " * vtN           vertical tab delay style, N in [0..1]\n"
msgstr ""

#: src/stty.c:796
msgid ""
"\n"
"Local settings:\n"
"   [-]crterase   echo erase characters as backspace-space-backspace\n"
msgstr ""

#: src/stty.c:802
#, fuzzy
msgid ""
" * crtkill       kill all line by obeying the echoprt and echoe settings\n"
" * -crtkill      kill all line by obeying the echoctl and echok settings\n"
msgstr ""
"\n"
"Локални настройки:\n"
"   [-]crterase   ехо на кодовете за изтриване като backspace-интервал-"
"backspace\n"
" * crtkill       убива реда според на настройките echoprt и echoe\n"
" * -crtkill      убива реда според на настройките echoctl и echok\n"

#: src/stty.c:808
msgid " * [-]ctlecho    echo control characters in hat notation ('^c')\n"
msgstr ""

#: src/stty.c:812
#, fuzzy
msgid "   [-]echo       echo input characters\n"
msgstr ""
" * [-]iutf8      да се предполага, че входните знаци са кодирани в UTF-8\n"

#: src/stty.c:816
msgid " * [-]echoctl    same as [-]ctlecho\n"
msgstr ""

#: src/stty.c:820
msgid ""
"   [-]echoe      same as [-]crterase\n"
"   [-]echok      echo a newline after a kill character\n"
msgstr ""

#: src/stty.c:825
msgid " * [-]echoke     same as [-]crtkill\n"
msgstr ""

#: src/stty.c:829
msgid "   [-]echonl     echo newline even if not echoing other characters\n"
msgstr ""

#: src/stty.c:833
msgid ""
" * [-]echoprt    echo erased characters backward, between '\\' and '/'\n"
msgstr ""

#: src/stty.c:838
msgid " * [-]extproc    enable \"LINEMODE\"; useful with high latency links\n"
msgstr ""

#: src/stty.c:843
msgid " * [-]flusho     discard output\n"
msgstr ""

#: src/stty.c:847
#, c-format
msgid ""
"   [-]icanon     enable special characters: %s\n"
"   [-]iexten     enable non-POSIX special characters\n"
msgstr ""

#: src/stty.c:858
#, fuzzy
msgid ""
"   [-]isig       enable interrupt, quit, and suspend special characters\n"
"   [-]noflsh     disable flushing after interrupt and quit special "
"characters\n"
msgstr ""
"   [-]isig       позволява управляващите кодове за interrupt, quit и "
"suspend\n"
"   [-]noflsh     забранява моменталното извеждане след кодове interrupt и "
"quit\n"
" * [-]prterase   същото като [-]echoprt\n"
" * [-]tostop     спира фоновите задачи, които се опитват да пишат на "
"терминала\n"
" * [-]xcase      с icanon извежда главните букви като предшествани от „\\“ "
"малки\n"

#: src/stty.c:863
msgid " * [-]prterase   same as [-]echoprt\n"
msgstr ""

#: src/stty.c:868
msgid ""
" * [-]tostop     stop background jobs that try to write to the terminal\n"
msgstr ""

#: src/stty.c:873
msgid ""
" * [-]xcase      with icanon, escape with '\\' for uppercase characters\n"
msgstr ""

#: src/stty.c:877
msgid ""
"\n"
"Combination settings:\n"
msgstr ""

#: src/stty.c:882
msgid " * [-]LCASE      same as [-]lcase\n"
msgstr ""

#: src/stty.c:886
#, fuzzy
msgid ""
"   cbreak        same as -icanon\n"
"   -cbreak       same as icanon\n"
msgstr ""
"\n"
"Комбинирани настройки:\n"
" * [-]LCASE      същото като [-]lcase\n"
"   cbreak        същото като -icanon\n"
"   -cbreak       същото като icanon\n"

#: src/stty.c:890
#, fuzzy
msgid ""
"   cooked        same as brkint ignpar istrip icrnl ixon opost isig\n"
"                 icanon, eof and eol characters to their default values\n"
"   -cooked       same as raw\n"
msgstr ""
"   cooked        същото като brkint ignpar istrip icrnl ixon opost isig "
"icanon\n"
"                 управляващите символи eof и eol имат стандартното си "
"значение\n"
"   -cooked       същото като raw\n"
"   crt           същото като echoe echoctl echoke\n"

#: src/stty.c:895
#, fuzzy, c-format
msgid "   crt           same as %s\n"
msgstr " !             Стартиране на вторична командна обвивка\n"

#: src/stty.c:905
#, c-format
msgid ""
"   dec           same as %s intr ^c erase 0177\n"
"                 kill ^u\n"
msgstr ""

#: src/stty.c:920
msgid " * [-]decctlq    same as [-]ixany\n"
msgstr ""

#: src/stty.c:924
msgid ""
"   ek            erase and kill characters to their default values\n"
"   evenp         same as parenb -parodd cs7\n"
"   -evenp        same as -parenb cs8\n"
msgstr ""

#: src/stty.c:930
msgid " * [-]lcase      same as xcase iuclc olcuc\n"
msgstr ""

#: src/stty.c:934
msgid ""
"   litout        same as -parenb -istrip -opost cs8\n"
"   -litout       same as parenb istrip opost cs7\n"
msgstr ""

#: src/stty.c:938
#, fuzzy, c-format
msgid ""
"   nl            same as %s\n"
"   -nl           same as %s\n"
msgstr "  -I R                        същото като --replace=R\n"

#: src/stty.c:956
msgid ""
"   oddp          same as parenb parodd cs7\n"
"   -oddp         same as -parenb cs8\n"
"   [-]parity     same as [-]evenp\n"
"   pass8         same as -parenb -istrip cs8\n"
"   -pass8        same as parenb istrip cs7\n"
msgstr ""
"   oddp          същото като parenb parodd cs7\n"
"   -oddp         същото като -parenb cs8\n"
"   [-]parity     същото като [-]evenp\n"
"   pass8         същото като -parenb -istrip cs8\n"
"   -pass8        същото като parenb istrip cs7\n"

#: src/stty.c:963
#, fuzzy, c-format
msgid ""
"   raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\n"
"                 -isig%s min 1 time 0\n"
"   -raw          same as cooked\n"
msgstr ""
"   raw           същото като -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl  -ixon  -ixoff  -iuclc  -ixany\n"
"                 -imaxbel -opost -isig -icanon -xcase min 1 time 0\n"
"   -raw          същото като\n"

#: src/stty.c:982
#, fuzzy, c-format
msgid ""
"   sane          same as cread -ignbrk brkint -inlcr -igncr icrnl\n"
"                 icanon iexten echo echoe echok -echonl -noflsh\n"
"                 %s\n"
"                 %s\n"
"                 %s,\n"
"                 all special characters to their default values\n"
msgstr ""
"   sane          същото като -ignbrk brkint -inlcr -igncr icrnl -iutf8\n"
"                 -ixoff -iuclc -ixany imaxbel opost -olcuc -ocrnl onlcr\n"
"                 -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\n"
"                 isig icanon iexten echo echoe echok -echonl -noflsh\n"
"                 -xcase -tostop -echoprt echoctl echoke, всички управляващи\n"
"                 знаци запазват стандартната си стойност.\n"

#: src/stty.c:1068
msgid ""
"\n"
"Handle the tty line connected to standard input.  Without arguments,\n"
"prints baud rate, line discipline, and deviations from stty sane.  In\n"
"settings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 or\n"
"127; special values ^- or undef used to disable special characters.\n"
msgstr ""
"\n"
"Управлява терминалната линия, свързана на стандартния изход.  Без аргументи\n"
"извежда скоростта в бодове (т.е. бит/сек), дисциплината на линията и\n"
"различията от stty sane.  В настройките ЗНАК се задава буквално или кодиран\n"
"като ^c, 0x37, 0177 или 127; специалните стойности ^- и undef се използват,\n"
"за да се забранят съответните управляващи знаци.\n"

#: src/stty.c:1097
#, c-format
msgid "missing argument to %s"
msgstr "липсва аргумент за %s"

#: src/stty.c:1140 src/stty.c:1258
#, c-format
msgid "invalid argument %s"
msgstr "неправилен аргумент %s"

#: src/stty.c:1192
#, fuzzy, c-format
msgid "%s: error setting %s"
msgstr "грешка при анализа на „%s“"

#: src/stty.c:1234
#, c-format
msgid "invalid line discipline %s"
msgstr "неправилна дисциплина на редовете %s"

#: src/stty.c:1326
msgid "only one device may be specified"
msgstr "може да се посочва само едно устройство"

#: src/stty.c:1360
msgid ""
"the options for verbose and stty-readable output styles are\n"
"mutually exclusive"
msgstr ""
"опциите за подробен и stty-четим изходен стил\n"
"взаимно се изключват"

#: src/stty.c:1366
msgid "when specifying an output style, modes may not be set"
msgstr "при посочване на изходен стил не може да се настройват режими"

#: src/stty.c:1384
#, c-format
msgid "%s: couldn't reset non-blocking mode"
msgstr "%s: не може да се презададе режимът non-blocking"

#: src/stty.c:1447
#, c-format
msgid "%s: unable to perform all requested operations"
msgstr "%s: не може да се осъществят всички поискани операции"

#: src/stty.c:1792
#, c-format
msgid "%s: no size information for this device"
msgstr "%s: няма информация за размера на това устройство"

#: src/stty.c:2321
#, fuzzy
msgid "invalid integer argument"
msgstr "неправилен размер на контекста"

#. This is a proper name. See the gettext manual, section Names.
#: src/sum.c:38
msgid "Kayvan Aghaiepour"
msgstr "Kayvan Aghaiepour"

#: src/sum.c:63
msgid "Print checksum and block counts for each FILE.\n"
msgstr "Извеждане на контролната сума и броя блокове за всеки ФАЙЛ.\n"

#: src/sum.c:69
msgid ""
"\n"
"  -r              use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"\n"
"  -r             използване на алгоритъма от BSD, блоковете са по 1K\n"
"  -s, --sysv     използване на алгоритъма от System V, блоковете са по 512B\n"

#: src/sync.c:64
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "Употреба: %s [ОПЦИЯ] [ФАЙЛ]…\n"

#: src/sync.c:65
msgid ""
"Synchronize cached writes to persistent storage\n"
"\n"
"If one or more files are specified, sync only them,\n"
"or their containing file systems.\n"
"\n"
msgstr ""
"Синхронизиране на кешираните записи с устройствата за постоянно съхранение\n"
"\n"
"Ако са указани файлове, се синхронизират само те или само файловите системи, "
"на\n"
"които принадлежат.\n"
"\n"

#: src/sync.c:73
msgid "  -d, --data             sync only file data, no unneeded metadata\n"
msgstr ""
"  -d, --data             синхронизиране само на данните, а не и на "
"метаданните\n"

#: src/sync.c:76
msgid "  -f, --file-system      sync the file systems that contain the files\n"
msgstr ""
"  -f, --file-system      синхронизиране на файловите системи на файловете\n"

#: src/sync.c:115
#, c-format
msgid "error opening %s"
msgstr "грешка при отварянето на „%s“"

#: src/sync.c:126
#, c-format
msgid "couldn't reset non-blocking mode %s"
msgstr "режимът без блокиране не може да се зададе наново „%s“"

#: src/sync.c:157
#, c-format
msgid "error syncing %s"
msgstr "грешка при синхронизирането на „%s“"

#: src/sync.c:215
msgid "cannot specify both --data and --file-system"
msgstr "опциите „--data“ и „--file-system“ са несъвместими"

#: src/sync.c:219
msgid "--data needs at least one argument"
msgstr "опцията „--data“ изисква поне един аргумент"

#: src/system.h:344
#, c-format
msgid ""
"\n"
"NOTE: your shell may have its own version of %s, which usually supersedes\n"
"the version described here.  Please refer to your shell's documentation\n"
"for details about the options it supports.\n"
msgstr ""
"\n"
"ЗАБЕЛЕЖКА: Обвивката ви може да има своя собствена версия на %s.\n"
"Тя обикновено се предпочита пред версията, описана тук. Моля обърнете се\n"
"към документацията на използваната от вас обвивка за поддържаните от нея "
"опции.\n"

#: src/system.h:350
msgid "      --help     display this help and exit\n"
msgstr "      --help     извеждане на тази помощ и изход\n"

#: src/system.h:352
msgid "      --version  output version information and exit\n"
msgstr "      --version  извеждане на версията на GNU sed и изход\n"

#: src/system.h:580
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"Ако няма ФАЙЛ или ако ФАЙЛ е -, се чете от стандартния вход.\n"

#: src/system.h:587
#, fuzzy
msgid ""
"\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"Аргументите, които са задължителни за дългите опции, са задължителни и за "
"късите\n"
"варианти.\n"

#: src/system.h:595
msgid ""
"\n"
"The SIZE argument is an integer and optional unit (example: 10K is "
"10*1024).\n"
"Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""

#: src/system.h:605
#, c-format
msgid ""
"\n"
"Display values are in units of the first available SIZE from --block-size,\n"
"and the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\n"
"Otherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n"
msgstr ""

#: src/system.h:615
#, fuzzy
msgid ""
"\n"
"The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control method may be selected via the --backup option or "
"through\n"
"the VERSION_CONTROL environment variable.  Here are the values:\n"
"\n"
msgstr ""
"Суфиксът за резервни копия е „~“, освен при промяна със „--suffix“ или с\n"
"променлива на средата „SIMPLE_BACKUP_SUFFIX“.  Методът за управление на\n"
"версиите може да се посочва с „--backup“ или с променливата "
"„VERSION_CONTROL“.\n"
"Допустими стойности са:\n"
"\n"
"  none, off       никога да не се правят резервни копия\n"
"  t, numbered     да се правят номерирани резервни копия\n"
"  nil, existing   номерирани, ако вече има номерирани, иначе — прости\n"
"  never, simple   винаги да се правят прости резервни копия\n"

#: src/system.h:622
msgid ""
"  none, off       never make backups (even if --backup is given)\n"
"  numbered, t     make numbered backups\n"
"  existing, nil   numbered if numbered backups exist, simple otherwise\n"
"  simple, never   always make simple backups\n"
msgstr ""
"  none, off       никога да не се правят резервни копия (освен при --"
"backup)\n"
"  numbered, t     да се правят номерирани резервни копия\n"
"  existing, nil   номерирани, ако вече са правени номерирани, а прости "
"иначе\n"
"  simple, never   винаги да се правят прости резервни копия\n"

#: src/system.h:652
#, fuzzy, c-format
msgid ""
"\n"
"%s online help: <%s>\n"
msgstr "Уеб страница на „%s“: <%s>\n"

#. TRANSLATORS: Replace LANG_CODE in this URL with your language code
#. <https://translationproject.org/team/LANG_CODE.html> to form one of
#. the URLs at https://translationproject.org/team/.  Otherwise, replace
#. the entire URL with your translation team's email address.
#: src/system.h:663
msgid "Report any translation bugs to <https://translationproject.org/team/>\n"
msgstr ""

#: src/system.h:666
#, c-format
msgid "Full documentation <%s%s>\n"
msgstr ""

#: src/system.h:668
#, c-format
msgid "or available locally via: info '(coreutils) %s%s'\n"
msgstr ""

#: src/system.h:679
#, c-format
msgid "Try '%s --help' for more information.\n"
msgstr "За повече информация изпълнете „%s --help“.\n"

#: src/system.h:723
#, c-format
msgid ""
"WARNING: Circular directory structure.\n"
"This almost certainly means that you have a corrupted file system.\n"
"NOTIFY YOUR SYSTEM MANAGER.\n"
"The following directory is part of the cycle:\n"
"  %s\n"
msgstr ""
"ВНИМАНИЕ: Циклична каталожна структура.\n"
"Това почти със сигурност означава, че имате повредена файлова система.\n"
"ИЗВЕСТЕТЕ ВАШИЯ СИСТЕМЕН АДМИНИСТРАТОР.\n"
"Следващият каталог е част от цикъла:\n"
"  %s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/tac.c:57
msgid "Jay Lepreau"
msgstr "Jay Lepreau"

#: src/tac.c:136
#, fuzzy
msgid "Write each FILE to standard output, last line first.\n"
msgstr ""
"Извежда на стандартния изход всеки ФАЙЛ, последеният ред е пръв.\n"
"Без ФАЙЛ или ако ФАЙЛ е -, се чете от стандартния вход.\n"
"\n"

#: src/tac.c:143
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before             прикрепя разделителя преди, а не след\n"
"  -r, --regex              интерпретира разделителя като регулярен израз\n"
"  -s, --separator=НИЗ      вместо кода за нов ред, използва като разделител "
"НИЗ\n"

#: src/tac.c:223 src/tac.c:233 src/tac.c:343
#, c-format
msgid "%s: seek failed"
msgstr "%s: неуспешно позициониране (seek) във файл"

#: src/tac.c:276
msgid "record too large"
msgstr "твърде дълъг запис"

#: src/tac.c:458
#, fuzzy, c-format
msgid "failed to create temporary file in %s"
msgstr "временният файл „%s“ не може да се отвори: %s"

#: src/tac.c:466
#, fuzzy, c-format
msgid "failed to open %s for writing"
msgstr "„/dev/tty“ не може да се отвори за четене"

#: src/tac.c:484
#, fuzzy, c-format
msgid "failed to rewind stream for %s"
msgstr "файлът „%s“ не може да се отвори наново с режим „%s“"

#: src/tac.c:521 src/tac.c:533
#, c-format
msgid "%s: write error"
msgstr "%s: грешка при запис"

#: src/tac.c:582
#, fuzzy, c-format
msgid "failed to open %s for reading"
msgstr "„/dev/tty“ не може да се отвори за четене"

#: src/tac.c:650
msgid "separator cannot be empty"
msgstr "разделителят не може да бъде празен"

#. This is a proper name. See the gettext manual, section Names.
#: src/tail.c:78
msgid "Ian Lance Taylor"
msgstr "Ian Lance Taylor"

#: src/tail.c:269
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""
"Извеждане на последните %d реда от всеки ФАЙЛ на стандартния изход.\n"
"Когато има повече от един ФАЙЛ, пред всеки се поставя заглавие с името му.\n"

#: src/tail.c:277
msgid ""
"  -c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\n"
"                             output starting with byte NUM of each file\n"
msgstr ""
"  -c, --bytes=[+]БАЙТ      извеждане на този брой от последните БАЙТове.\n"
"                           „+“ води до извеждане на съдържанието на всеки "
"файл\n"
"                           след този БАЙТ\n"

#: src/tail.c:281
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                             an absent option argument means 'descriptor'\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""
"  -f, --follow[={name|descriptor}]\n"
"                           извеждане на добавяните данни към файла.  "
"Липсата\n"
"                           на аргумент е еднозначна с „--follow=descriptor“\n"
"  -F                       същото като „--follow=name --retry“\n"

#: src/tail.c:287
#, c-format
msgid ""
"  -n, --lines=[+]NUM       output the last NUM lines, instead of the last "
"%d;\n"
"                             or use -n +NUM to output starting with line "
"NUM\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                             changed size after N (default %d) iterations\n"
"                             to see if it has been unlinked or renamed\n"
"                             (this is the usual case of rotated log files);\n"
"                             with inotify, this option is rarely useful\n"
msgstr ""
"  -n, --lines=[+]РЕД       извеждане на този брой от последните РЕДове "
"вместо %d\n"
"                            „+“ води до извеждане на съдържанието на всеки "
"файл\n"
"                           след този РЕД\n"
"      --max-unchanged-stats=N\n"
"                           при ползването на „--follow=name“ всеки ФАЙЛ, "
"който\n"
"                           не си е сменил размера след N (стандартно %d)\n"
"                           итерации, се отваря наново за да се провери, дали "
"не\n"
"                           е бил изтрит или преименуван (което е обичайно "
"при\n"
"                           подмяна на журналните файлове).  При наличието "
"на\n"
"                           „inotify“ рядко се налага ползвате тази опция\n"

#: src/tail.c:300
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"      --retry              keep trying to open a file if it is inaccessible\n"
msgstr ""
"      --pid=ИД_ПР          заедно с „-f“ — „tail“ приключва след края на "
"командата\n"
"                           с този ИДентификатор_на_ПРОЦЕС\n"
"  -q, --quiet, --silent    без извеждане на заглавия с имената на файловете\n"
"      --retry              продължаване с опитите да се отворят и "
"недостъпните\n"
"                           файлове\n"

#: src/tail.c:305
msgid ""
"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\n"
"                             (default 1.0) between iterations;\n"
"                             with inotify and --pid=P, check process P at\n"
"                             least once every N seconds\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""
"  -s, --sleep-interval=N   с „-f“ се изчаква приблизително N секунди "
"(стандартно\n"
"                           е 1.0) между итерациите.  При ползване на "
"„inotify“ и\n"
"                           „--pid=ПРОЦЕС“ — ПРОЦЕСЪТ се проверява поне "
"веднъж на\n"
"                           всеки N секунди\n"
"  -v, --verbose            заглавията винаги да съдържат имената на "
"файловете\n"

#: src/tail.c:317
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"\n"
msgstr ""
"\n"
"БРОят може да бъде следван от следните суфикси-множители:\n"
"b≡512, kB≡1000, K≡1024, MB≡1000×1000, M≡1024×1024,\n"
"GB≡1000×1000×1000, G≡1024×1024×1024 и т.н. за „T“, „P“, „E“, „Z“ и „Y“.\n"
"Приемат се и двоични префикси: KiB≡K, MiB≡M и т.н.\n"

#: src/tail.c:325
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file in a way that accommodates renaming, removal and creation.\n"
msgstr ""
"При ползването на „--follow“ („-f“), „tail“ следва файловия дескриптор — "
"дори\n"
"файлът да бъде преименуван или преместен, командата ще го следи.  "
"Стандартното\n"
"поведение не е подходящо, когато важното е името на файла, а не дескриптора\n"
"(примерно при редовната подмяна на журналните файлове).  В такива случаи\n"
"ползвайте „--follow=name“.  Така се следи файла с точно това име, без\n"
"преименуването, изтриването и създаването да пречат.\n"

#: src/tail.c:416
#, c-format
msgid "closing %s (fd=%d)"
msgstr "Затваряне на „%s“ (файлов дескриптор=%d)"

#: src/tail.c:515
#, c-format
msgid "%s: cannot seek to end-relative offset %s"
msgstr "%s: не може да се отиде на отместване „%s“ спрямо края на файла"

#: src/tail.c:951
#, c-format
msgid "cannot determine location of %s. reverting to polling"
msgstr ""
"местоположението на „%s“ не може да се определи, ще се ползва периодична "
"проверка"

#: src/tail.c:1007
#, c-format
msgid "%s has been replaced with an untailable symbolic link"
msgstr "„%s“ е заменен с файл, с който командата „tail“ не може да работи"

#: src/tail.c:1022
#, c-format
msgid "%s has become inaccessible"
msgstr "„%s“ е станал недостъпен"

#: src/tail.c:1040
#, c-format
msgid "%s has been replaced with an untailable file%s"
msgstr "„%s“ е заменен с файл, с който командата „tail“ не може да работи%s"

#: src/tail.c:1042 src/tail.c:2048
msgid "; giving up on this name"
msgstr ", името няма да се обработва повече"

#: src/tail.c:1048
#, c-format
msgid "%s has been replaced with an untailable remote file"
msgstr ""
"„%s“ е заменен с отдалечен файл, с който командата „tail“ не може да работи"

#: src/tail.c:1069
#, c-format
msgid "%s has become accessible"
msgstr "„%s“ е станал достъпен"

#: src/tail.c:1081
#, c-format
msgid "%s has appeared;  following new file"
msgstr "„%s“ се е появил — следва се краят на новия файл"

#: src/tail.c:1091
#, c-format
msgid "%s has been replaced;  following new file"
msgstr "„%s“ е заменен — следва се краят на новия файл"

#: src/tail.c:1206
#, c-format
msgid "%s: cannot change nonblocking mode"
msgstr "%s: не може да се смени режимът към такъв без блокиране"

#: src/tail.c:1252 src/tail.c:1427
#, c-format
msgid "%s: file truncated"
msgstr "%s: файлът е съкратен"

#: src/tail.c:1286 src/tail.c:1628
#, c-format
msgid "no files remaining"
msgstr "няма повече файлове"

#: src/tail.c:1522
#, c-format
msgid "cannot watch parent directory of %s"
msgstr ""
"текущата родителска директория не може да се наблюдава (в момента е „%s“)"

#: src/tail.c:1525 src/tail.c:1542 src/tail.c:1752
#, c-format
msgid "inotify resources exhausted"
msgstr "ресурсите за „inotify“ са изчерпани"

#: src/tail.c:1546 src/tail.c:1760
#, c-format
msgid "cannot watch %s"
msgstr "„%s“ не може да се наблюдава"

#: src/tail.c:1595
#, c-format
msgid "%s was replaced"
msgstr "„%s“ бе заменен"

#: src/tail.c:1667
msgid "error waiting for inotify and output events"
msgstr "грешка при изчакването на изходни събития и такива от „inotify“"

#: src/tail.c:1695
msgid "error reading inotify event"
msgstr "грешка при четене на събития от „inotify“"

#: src/tail.c:1714
#, c-format
msgid "directory containing watched file was removed"
msgstr "директория с наблюдавани файлове е премахната"

#: src/tail.c:2046
#, c-format
msgid "%s: cannot follow end of this type of file%s"
msgstr "%s: краят на този вид файлове не може да се следва%s"

#: src/tail.c:2227
msgid "invalid maximum number of unchanged stats between opens"
msgstr ""
"неправилен максимален брой достъпвания без промяна на информацията за достъп"

#: src/tail.c:2235
msgid "invalid PID"
msgstr "неправилен номер на процес"

#: src/tail.c:2251
#, c-format
msgid "invalid number of seconds: %s"
msgstr "неправилен брой секунди: %s"

#: src/tail.c:2270
#, c-format
msgid "option used in invalid context -- %c"
msgstr "опцията е използвана в неправилен контекст — „%c“"

#: src/tail.c:2282
#, c-format
msgid "warning: --retry ignored; --retry is useful only when following"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: опцията „--retry“ се пренебрегва — тя важи само при следване"

#: src/tail.c:2286
#, c-format
msgid "warning: --retry only effective for the initial open"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: опцията „--retry“ важи само при първоначалното отваряне"

#: src/tail.c:2291
#, c-format
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: номерът на процес се пренебрегва, опцията „--pid=PID“ важи "
"само при следване"

#: src/tail.c:2294
#, c-format
msgid "warning: --pid=PID is not supported on this system"
msgstr "ПРЕДУПРЕЖДЕНИЕ: опцията „--pid=PID“ не се поддържа на тази система"

#: src/tail.c:2400
#, c-format
msgid "cannot follow %s by name"
msgstr "„%s“ не може да се следва според името"

#: src/tail.c:2415
#, c-format
msgid "warning: following standard input indefinitely is ineffective"
msgstr "внимание: безкрайното следване на стандартния вход е безполезно"

#: src/tail.c:2512
#, c-format
msgid "inotify cannot be used, reverting to polling"
msgstr "„inotify“ липсва, ще се ползва периодична проверка"

#: src/tee.c:88
msgid ""
"Copy standard input to each FILE, and also to standard output.\n"
"\n"
"  -a, --append              append to the given FILEs, do not overwrite\n"
"  -i, --ignore-interrupts   ignore interrupt signals\n"
msgstr ""
"Копиране на стандартния изход във всеки от ФАЙЛовете, а също и на "
"стандартния изход.\n"
"\n"
"  -a, --append              добавяне (а не заместване) към посочените "
"ФАЙЛове\n"
"  -i, --ignore-interrupts   заглушаването на сигналите за прекъсване\n"

#: src/tee.c:94
msgid ""
"  -p                        diagnose errors writing to non pipes\n"
"      --output-error[=MODE]   set behavior on write error.  See MODE below\n"
msgstr ""
"  -p                        диагностициране на грешките при запис в обект, "
"който\n"
"                            не е програмен канал\n"
"      --output-error[=РЕЖИМ]\n"
"                            поведение при грешка при запис.  Вижте „РЕЖИМ“\n"

#: src/tee.c:100
msgid ""
"\n"
"MODE determines behavior with write errors on the outputs:\n"
"  'warn'         diagnose errors writing to any output\n"
"  'warn-nopipe'  diagnose errors writing to any output not a pipe\n"
"  'exit'         exit on error writing to any output\n"
"  'exit-nopipe'  exit on error writing to any output not a pipe\n"
"The default MODE for the -p option is 'warn-nopipe'.\n"
"The default operation when --output-error is not specified, is to\n"
"exit immediately on error writing to a pipe, and diagnose errors\n"
"writing to non pipe outputs.\n"
msgstr ""
"\n"
"РЕЖИМът определя поведението при грешка при извеждане на изхода:\n"
"  ⁃ warn         извеждане на причината за грешката във всички ситуации\n"
"  ⁃ warn-nopipe  извеждане на причината за грешката, освен при писане в "
"канал\n"
"  ⁃ exit         изход при грешка във всички ситуации\n"
"  ⁃ exit-nopipe  изход при грешка, освен при писане в програмен канал\n"
"Стандартният РЕЖИМ при опция „-p“ е „warn-nopipe“.\n"
"Стандартното действие, когато не е зададена опцията „--output-error“, е\n"
"незабавен изход при писане към програмен канал, а иначе е да изведе\n"
"съобщение с обяснение за грешката.\n"

#: src/test.c:126
#, c-format
msgid "missing argument after %s"
msgstr "липсва аргумент след „%s“"

#: src/test.c:162
#, c-format
msgid "invalid integer %s"
msgstr "неправилно цяло число „%s“"

#: src/test.c:244
#, c-format
msgid "%s expected"
msgstr "очаква се „%s“"

#: src/test.c:247
#, c-format
msgid "%s expected, found %s"
msgstr "очаква се „%s“, а е получено „%s“"

#: src/test.c:328
msgid "-nt does not accept -l"
msgstr "опцията „-nt“ е несъвместима с „-l“"

#: src/test.c:341
msgid "-ef does not accept -l"
msgstr "опцията „-ef“ е несъвместима с „-l“"

#: src/test.c:357
msgid "-ot does not accept -l"
msgstr "опцията „-ot“ е несъвместима с „-l“"

#: src/test.c:366
#, c-format
msgid "%s: unknown binary operator"
msgstr "%s: непознат бинарен оператор"

#: src/test.c:396
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: очаква се унарен оператор"

#: src/test.c:632
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: очаква се бинарен оператор"

#: src/test.c:690
msgid ""
"Usage: test EXPRESSION\n"
"  or:  test\n"
"  or:  [ EXPRESSION ]\n"
"  or:  [ ]\n"
"  or:  [ OPTION\n"
msgstr ""
"Употреба: test ИЗРАЗ\n"
"     или: test\n"
"     или: [ ИЗРАЗ ]\n"
"     или: [ ]\n"
"     или: [ ОПЦИЯ\n"

#: src/test.c:697
msgid ""
"Exit with the status determined by EXPRESSION.\n"
"\n"
msgstr ""
"Изход с код-състояние, определен от ИЗРАЗ.\n"
"\n"

#: src/test.c:703
msgid ""
"\n"
"An omitted EXPRESSION defaults to false.  Otherwise,\n"
"EXPRESSION is true or false and sets exit status.  It is one of:\n"
msgstr ""
"\n"
"Ако ИЗРАЗът е изпуснат, се приема лъжа.  Иначе ИЗРАЗ е истина и лъжа и "
"определя\n"
"кода на завършване.  Той може да бъде:\n"

#: src/test.c:708
msgid ""
"\n"
"  ( EXPRESSION )               EXPRESSION is true\n"
"  ! EXPRESSION                 EXPRESSION is false\n"
"  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\n"
"  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\n"
msgstr ""
"\n"
"  ( ИЗРАЗ )                    ИЗРАЗът е истина\n"
"  ! ИЗРАЗ                      ИЗРАЗът е лъжа\n"
"  ИЗРАЗ_1 -a ИЗРАЗ_2           както ИЗРАЗ_1, така и ИЗРАЗ_2 са истина\n"
"  ИЗРАЗ_1 -o ИЗРАЗ_2           поне един от ИЗРАЗ_1 и ИЗРАЗ_2 е истина\n"

#: src/test.c:715
msgid ""
"\n"
"  -n STRING            the length of STRING is nonzero\n"
"  STRING               equivalent to -n STRING\n"
"  -z STRING            the length of STRING is zero\n"
"  STRING1 = STRING2    the strings are equal\n"
"  STRING1 != STRING2   the strings are not equal\n"
msgstr ""
"\n"
"  [-n] НИЗ             НИЗът е с ненулева дължина\n"
"  НИЗ                  същото като „-n НИЗ“\n"
"  -z НИЗ               НИЗът е с дължина нула\n"
"  НИЗ_1 = НИЗ_2        низовете са еднакви\n"
"  НИЗ_1 != НИЗ_2       низовете не са еднакви\n"

#: src/test.c:723
msgid ""
"\n"
"  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\n"
"  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\n"
"  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\n"
"  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\n"
"  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\n"
"  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\n"
msgstr ""
"\n"
"  ЦЯЛО_1 -eq ЦЯЛО_2       ЦЯЛО_1 е равно на ЦЯЛО_2\n"
"  ЦЯЛО_1 -ge ЦЯЛО_2       ЦЯЛО_1 е по-голямо или равно на ЦЯЛО_2\n"
"  ЦЯЛО_1 -gt ЦЯЛО_2       ЦЯЛО_1 е по-голямо от ЦЯЛО_2\n"
"  ЦЯЛО_1 -le ЦЯЛО_2       ЦЯЛО_1 е по-малко или равно на ЦЯЛО_2\n"
"  ЦЯЛО_1 -lt ЦЯЛО_2       ЦЯЛО_1 е по-малко от ЦЯЛО_2\n"
"  ЦЯЛО_1 -ne ЦЯЛО_2       ЦЯЛО_1 е различно от ЦЯЛО_2\n"

#: src/test.c:732
msgid ""
"\n"
"  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\n"
"  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\n"
"  FILE1 -ot FILE2   FILE1 is older than FILE2\n"
msgstr ""
"\n"
"  ФАЙЛ_1 -ef ФАЙЛ_2   ФАЙЛ_1 и ФАЙЛ_2 имат равни номера на устройство и i-"
"възел\n"
"  ФАЙЛ_1 -nt ФАЙЛ_2   ФАЙЛ_1 е по-нов (според датата на изменение) от "
"ФАЙЛ_2\n"
"  ФАЙЛ_1 -ot ФАЙЛ_2   ФАЙЛ_1 е по-стар (според датата на изменение) от "
"ФАЙЛ_2\n"

#: src/test.c:738
msgid ""
"\n"
"  -b FILE     FILE exists and is block special\n"
"  -c FILE     FILE exists and is character special\n"
"  -d FILE     FILE exists and is a directory\n"
"  -e FILE     FILE exists\n"
msgstr ""
"\n"
"  -b ФАЙЛ     ФАЙЛът съществува и е специален блоков файл\n"
"  -c ФАЙЛ     ФАЙЛът съществува и е специален символен файл\n"
"  -d ФАЙЛ     ФАЙЛът съществува и е директория\n"
"  -e ФАЙЛ     ФАЙЛът съществува\n"

#: src/test.c:745
msgid ""
"  -f FILE     FILE exists and is a regular file\n"
"  -g FILE     FILE exists and is set-group-ID\n"
"  -G FILE     FILE exists and is owned by the effective group ID\n"
"  -h FILE     FILE exists and is a symbolic link (same as -L)\n"
"  -k FILE     FILE exists and has its sticky bit set\n"
msgstr ""
"  -f ФАЙЛ     ФАЙЛът съществува и е обикновен файл\n"
"  -g ФАЙЛ     ФАЙЛът съществува и при изпълнение задава група\n"
"  -h ФАЙЛ     ФАЙЛът съществува и е символна връзка (същото като „-L“)\n"
"  -G ФАЙЛ     ФАЙЛът съществува и се притежава от действащата група\n"
"  -k ФАЙЛ     ФАЙЛът съществува и е със sticky bit\n"

#: src/test.c:752
msgid ""
"  -L FILE     FILE exists and is a symbolic link (same as -h)\n"
"  -N FILE     FILE exists and has been modified since it was last read\n"
"  -O FILE     FILE exists and is owned by the effective user ID\n"
"  -p FILE     FILE exists and is a named pipe\n"
"  -r FILE     FILE exists and read permission is granted\n"
"  -s FILE     FILE exists and has a size greater than zero\n"
msgstr ""
"  -L ФАЙЛ     ФАЙЛът съществува и е символна връзка (същото като „-h“)\n"
"  -N ФАЙЛ     ФАЙЛът съществува и е променен след последното четене от него\n"
"  -O ФАЙЛ     ФАЙЛът съществува и се притежава от действащия потребител\n"
"  -p ФАЙЛ     ФАЙЛът съществува и е именуван канал\n"
"  -r ФАЙЛ     ФАЙЛът съществува и е достъпен за четене\n"
"  -s ФАЙЛ     ФАЙЛът съществува и има ненулев размер\n"

#: src/test.c:760
msgid ""
"  -S FILE     FILE exists and is a socket\n"
"  -t FD       file descriptor FD is opened on a terminal\n"
"  -u FILE     FILE exists and its set-user-ID bit is set\n"
"  -w FILE     FILE exists and write permission is granted\n"
"  -x FILE     FILE exists and execute (or search) permission is granted\n"
msgstr ""
"  -S ФАЙЛ     ФАЙЛът съществува и е гнездо\n"
"  -t [FD]     файловият дескриптор FD е отворен на терминал\n"
"  -u ФАЙЛ     ФАЙЛът съществува и при изпълнение задава потребител\n"
"  -w ФАЙЛ     ФАЙЛът съществува и е достъпен за запис\n"
"  -x ФАЙЛ     ФАЙЛът съществува и е изпълним файл (при каталог: може да се "
"търси)\n"

#: src/test.c:767
msgid ""
"\n"
"Except for -h and -L, all FILE-related tests dereference symbolic links.\n"
"Beware that parentheses need to be escaped (e.g., by backslashes) for "
"shells.\n"
"INTEGER may also be -l STRING, which evaluates to the length of STRING.\n"
msgstr ""
"\n"
"Освен при „-h“ и -„L“ всички файлови проверки се правят към сочените от\n"
"символни връзки файлове.  При повечето обвивки „(“, „)“ трябва да бъдат\n"
"екранирани (напр. с „\\“).\n"
"\n"
"Вместо ЦЯЛО число може да ползвате и „-l НИЗ“, което дава дължината на "
"НИЗа.\n"

#: src/test.c:773
msgid ""
"\n"
"NOTE: Binary -a and -o are inherently ambiguous.  Use 'test EXPR1 && test\n"
"EXPR2' or 'test EXPR1 || test EXPR2' instead.\n"
msgstr ""
"\n"
"ВНИМАНИЕ: Двоичните „-a“ и „-o“ не са еднозначни!  Вместо тях ползвайте:\n"
"„test ИЗРАЗ_1 && test ИЗРАЗ_2“ или „test ИЗРАЗ_1 || test ИЗРАЗ_2“.\n"

#: src/test.c:778
msgid ""
"\n"
"NOTE: [ honors the --help and --version options, but test does not.\n"
"test treats each of those as it treats any other nonempty STRING.\n"
msgstr ""
"\n"
"ВНИМАНИЕ: „[“ приема опциите „--help“ и „--version“, а „test“ — не!\n"
"„test“ ги обработва по същия начин както произволен друг непразен НИЗ.\n"

#: src/test.c:783
msgid "test and/or ["
msgstr "„test“ и/или „[“"

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:795
msgid "Kevin Braunsdorf"
msgstr "Kevin Braunsdorf"

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:796
msgid "Matthew Bradburn"
msgstr "Matthew Bradburn"

#: src/test.c:850
#, c-format
msgid "missing %s"
msgstr "липсва „%s“"

#: src/test.c:864
#, c-format
msgid "extra argument %s"
msgstr "излишен аргумент „%s“"

#: src/timeout.c:135
#, c-format
msgid "warning: timer_settime"
msgstr ""

#: src/timeout.c:140
#, fuzzy, c-format
msgid "warning: timer_create"
msgstr "предупреждение: "

#: src/timeout.c:207
#, c-format
msgid "sending signal %s to command %s"
msgstr ""

#: src/timeout.c:235
#, fuzzy, c-format
msgid ""
"Usage: %s [OPTION] DURATION COMMAND [ARG]...\n"
"  or:  %s [OPTION]\n"
msgstr "Употреба: %s [ОПЦИЯ]… КОМАНДА [ПЪРВОНАЧАЛЕН_АРГУМЕНТ]…\n"

#: src/timeout.c:239
msgid "Start COMMAND, and kill it if still running after DURATION.\n"
msgstr ""

#: src/timeout.c:245
msgid ""
"      --preserve-status\n"
"                 exit with the same status as COMMAND, even when the\n"
"                   command times out\n"
"      --foreground\n"
"                 when not running timeout directly from a shell prompt,\n"
"                   allow COMMAND to read from the TTY and get TTY signals;\n"
"                   in this mode, children of COMMAND will not be timed out\n"
"  -k, --kill-after=DURATION\n"
"                 also send a KILL signal if COMMAND is still running\n"
"                   this long after the initial signal was sent\n"
"  -s, --signal=SIGNAL\n"
"                 specify the signal to be sent on timeout;\n"
"                   SIGNAL may be a name like 'HUP' or a number;\n"
"                   see 'kill -l' for a list of signals\n"
msgstr ""

#: src/timeout.c:260
msgid "  -v, --verbose  diagnose to stderr any signal sent upon timeout\n"
msgstr ""

#: src/timeout.c:266
msgid ""
"\n"
"DURATION is a floating point number with an optional suffix:\n"
"'s' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for "
"days.\n"
"A duration of 0 disables the associated timeout.\n"
msgstr ""

#: src/timeout.c:271
msgid ""
"\n"
"If the command times out, and --preserve-status is not set, then exit with\n"
"status 124.  Otherwise, exit with the status of COMMAND.  If no signal\n"
"is specified, send the TERM signal upon timeout.  The TERM signal kills\n"
"any process that does not block or catch that signal.  It may be necessary\n"
"to use the KILL (9) signal, since this signal cannot be caught, in which\n"
"case the exit status is 128+9 rather than 124.\n"
msgstr ""

#: src/timeout.c:346 src/timeout.c:403
#, fuzzy, c-format
msgid "warning: sigprocmask"
msgstr "предупреждение: %s: %s"

#: src/timeout.c:425
#, c-format
msgid "warning: disabling core dumps failed"
msgstr ""

# QUOTE
#: src/timeout.c:544
#, fuzzy, c-format
msgid "error waiting for command"
msgstr "грешка при изчакване на „%s“"

#: src/timeout.c:555
#, fuzzy, c-format
msgid "the monitored command dumped core"
msgstr "Командата генерира „core“\n"

#: src/timeout.c:568
#, fuzzy, c-format
msgid "unknown status from command (%d)"
msgstr "непозната команда: „%c“"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:44
msgid "Jim Kingdon"
msgstr "Jim Kingdon"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:46
msgid "Randy Smith"
msgstr "Randy Smith"

#: src/touch.c:116 src/touch.c:310
#, c-format
msgid "invalid date format %s"
msgstr "неправилен формат за дата „%s“"

#: src/touch.c:192
#, c-format
msgid "cannot touch %s"
msgstr "не може да се изпълни „touch“ върху „%s“"

#: src/touch.c:198
#, c-format
msgid "setting times of %s"
msgstr "задава се време на „%s“"

#: src/touch.c:214
msgid ""
"Update the access and modification times of each FILE to the current time.\n"
"\n"
"A FILE argument that does not exist is created empty, unless -c or -h\n"
"is supplied.\n"
"\n"
"A FILE argument string of - is handled specially and causes touch to\n"
"change the times of the file associated with standard output.\n"
msgstr ""
"Задаване на времето за достъп и промяна на всеки от ФАЙЛовете да е "
"текущото.\n"
"\n"
"Ако ФАЙЛът не съществува, той се създава като празен файл, освен ако е "
"зададена\n"
"някоя от опциите „-c“ или „-h“.\n"
"\n"
"Ако ФАЙЛът е „-“, той се обработва по специален начин — „touch“ променя\n"
"времената на файла, към който стандартният изход е пренасочен.\n"

#: src/touch.c:226
msgid ""
"  -a                     change only the access time\n"
"  -c, --no-create        do not create any files\n"
"  -d, --date=STRING      parse STRING and use it instead of current time\n"
"  -f                     (ignored)\n"
msgstr ""
"  -a                     задаване само на времето за достъп\n"
"  -c, --no-create        без създаване на файловете, ако не съществуват\n"
"  -d, --date=НИЗ         анализ на НИЗа като време и ползване вместо "
"текущото\n"
"  -f                     (пренебрегва се)\n"

#: src/touch.c:232
msgid ""
"  -h, --no-dereference   affect each symbolic link instead of any "
"referenced\n"
"                         file (useful only on systems that can change the\n"
"                         timestamps of a symlink)\n"
"  -m                     change only the modification time\n"
msgstr ""
"  -h, --no-dereference   действа върху символните връзки, вместо върху "
"сочените\n"
"                         файлове (само при системи, позволяващи промяна на\n"
"                         времевите клейма на символни връзки)\n"
"  -m                     задаване само на времето на последна промяна\n"

#: src/touch.c:238
msgid ""
"  -r, --reference=FILE   use this file's times instead of current time\n"
"  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time\n"
"      --time=WORD        change the specified time:\n"
"                           WORD is access, atime, or use: equivalent to -a\n"
"                           WORD is modify or mtime: equivalent to -m\n"
msgstr ""
"  -r, --reference=ФАЙЛ   използване на времето на този ФАЙЛ вместо текущото\n"
"  -t ВРЕМЕ               ползване на [[ГГ]ГГ]ММДДччММ[.сс] вместо текущото "
"време\n"
"     --time=ВИД          задаване този ВИД време:\n"
"                           ⁃ „access“/„atime“/„use“≡„-а“: последен достъп\n"
"                           ⁃ „modify“/„mtime“≡„-m“: промяна\n"

#: src/touch.c:247
msgid ""
"\n"
"Note that the -d and -t options accept different time-date formats.\n"
msgstr ""
"\n"
"Опциите „-d“ и „-t“ приемат различни формати за време и дата!\n"

#: src/touch.c:336
#, c-format
msgid "cannot specify times from more than one source"
msgstr "не може да се посочват времена с повече от един източник"

#: src/touch.c:410
#, c-format
msgid ""
"warning: 'touch %s' is obsolete; use 'touch -t %04ld%02d%02d%02d%02d.%02d'"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: „touch %s“ e остарял вариант!  Ползвайте:\n"
"„touch -t %04ld%02d%02d%02d%02d.%02d“"

#: src/tr.c:287
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "Употреба: %s [ОПЦИЯ]… МНОЖЕСТВО_1 [МНОЖЕСТВО_2]\n"

#: src/tr.c:291
#, fuzzy
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, -C, --complement    use the complement of SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each sequence of a repeated character\n"
"                            that is listed in the last specified SET,\n"
"                            with a single occurrence of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""
"Превежда или отстранява знаци и/или повторения от стандартния вход,\n"
"пише на стандартния изход.\n"
"\n"
"  -c, -C, --complement    първо заменя МНОЖ1 с неговото допълнение\n"
"  -d, --delete            отстранява знаците от МНОЖ1, не превежда\n"
"  -s, --squeeze-repeats   заменя всяка входяща редица от един и същ повтарящ "
"се\n"
"                            знак, описан в МНОЖ1, с един такъв знак\n"
"  -t, --truncate-set1     първо съкращава МНОЖ1 до дължината на МНОЖ2\n"

#: src/tr.c:304
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"МНОЖ се задават като низове от знаци.  Повечето представят себе си.\n"
"Интерпретирани последователности са следните:\n"
"\n"
"  \\NNN            знакът с осмичен код NNN (1 до 3 осмични цифри)\n"
"  \\\\              обратна наклонена черта\n"
"  \\a              BEL (звуков сигнал)\n"
"  \\b              backspace\n"
"  \\f              form feed (край на страницата)\n"
"  \\n              нов ред (new line)\n"
"  \\r              връщане на курсора (return)\n"
"  \\t              хоризонтална табулация\n"

#: src/tr.c:318
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v              вертикална табулация\n"
"  ЗНАК1-ЗНАК2     всички знаци от ЗНАК1 до ЗНАК2\n"
"  [ЗНАК*]         (само при МНОЖ2) копия на ЗНАК до достигане дължината на "
"МНОЖ1\n"
"  [ЗНАК*ПОВТ]     ПОВТ броя на ЗНАК; ПОВТ е осмично число, ако започва с 0\n"
"  [:alnum:]       всички букви и цифри\n"
"  [:alpha:]       всички букви\n"
"  [:blank:]       всички празни знаци (интервал, табулации)\n"
"  [:cntrl:]       всички управляващи символи\n"
"  [:digit:]       всички цифри\n"

#: src/tr.c:329
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]       всички видими знаци с изключение на интервали, табулации и "
"др.\n"
"  [:lower:]       всички малки букви\n"
"  [:print:]       всички видими знаци, включително интервали, табулации\n"
"  [:punct:]       всички препинателни знаци\n"
"  [:space:]       хоризонтално или вертикално бяло поле\n"
"  [:upper:]       всички главни букви\n"
"  [:xdigit:]      всички шестнадесетични цифри\n"
"  [=ЗНАК=]        всички знаци, еквивалентни на ЗНАК\n"

#: src/tr.c:339
#, fuzzy
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  -s uses the last\n"
"specified SET, and occurs after translation or deletion.\n"
msgstr ""
"Излишните знаци от МНОЖ2\n"
"се пренебрегват.  Само за знаците от [:lower:] и [:upper:] е гарантирано, че "
"ще\n"
"са подредени последователно; използвани в МНОЖ2 при превод, те могат да "
"бъдат\n"
"използвани само в двойки, за да означат смяна на големи/малки букви.  "

#: src/tr.c:507
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, %c"
msgstr ""
"внимание: двусмислената осмична последователност \\%c%c%c е интерпретирана\n"
"\tкато двубайтовата последователност \\0%c%c, %c"

#: src/tr.c:516
#, fuzzy, c-format
msgid "warning: an unescaped backslash at end of string is not portable"
msgstr "внимание: обратна наклонена черта в края на форматен низ"

#: src/tr.c:666
#, fuzzy, c-format
msgid "range-endpoints of '%s-%s' are in reverse collating sequence order"
msgstr "граници на интервала „%s-%s“ са в обратен ред"

#: src/tr.c:812
#, c-format
msgid "invalid repeat count %s in [c*n] construct"
msgstr "неправилен брой повторения %s в конструкция [c*n]"

#: src/tr.c:888
#, fuzzy, c-format
msgid "missing character class name '[::]'"
msgstr "Неправилно име на клас знаци"

#: src/tr.c:891
#, fuzzy, c-format
msgid "missing equivalence class character '[==]'"
msgstr "липсва знак за клас на еквивалентност „[==]“"

#: src/tr.c:906
#, c-format
msgid "invalid character class %s"
msgstr "неправилен клас от символи %s"

#: src/tr.c:925
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s: класът на еквивалентност трябва да се означи само един знак"

#: src/tr.c:1205
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "лошо подравнена [:upper:] и/или [:lower:] конструкция"

#: src/tr.c:1309
msgid "too many characters in set"
msgstr "множество с твърде много знаци"

#: src/tr.c:1393
msgid ""
"when translating with string1 longer than string2,\n"
"the latter string must not end with a character class"
msgstr ""

#: src/tr.c:1449
msgid "the [c*] repeat construct may not appear in string1"
msgstr "конструкцията [c*] не може да се появява в МНОЖ1"

#: src/tr.c:1459
msgid "only one [c*] repeat construct may appear in string2"
msgstr "в МНОЖ2 може да се среща само конструкцията за повторение [c*]"

#: src/tr.c:1467
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "при превод не може да се срещат конструкции [=c=] в МНОЖ2"

#: src/tr.c:1474
#, fuzzy
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are 'upper' and 'lower'"
msgstr ""
"при превод единствените класове символи, които може да се срещат в\n"
"МНОЖ2 са „upper“ и „lower“"

#: src/tr.c:1489
msgid "when not truncating set1, string2 must be non-empty"
msgstr "когато не се съкращава МНОЖ1, МНОЖ2 трябва да бъде непразно"

#: src/tr.c:1498
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"при превод с допълнителни (обратни) класове символи, МНОЖ2 трябва\n"
"да изобразява всички знаци от областта в един"

#: src/tr.c:1507
msgid "the [c*] construct may appear in string2 only when translating"
msgstr "конструкцията [c*] може да се среща в МНОЖ2 само при превод"

#: src/tr.c:1759
#, fuzzy
msgid "Two strings must be given when both deleting and squeezing repeats."
msgstr ""
"когато едновременно се отстраняват повторения и изтрива знаци, трябва да са "
"дадени два низа"

#: src/tr.c:1761
msgid "Two strings must be given when translating."
msgstr "При превод трябва да се посочат два низа (множества)"

#: src/tr.c:1771
msgid "Only one string may be given when deleting without squeezing repeats."
msgstr ""
"Само един низ може да бъде даден, когато се изтрива без отстраняване на "
"повторенията"

#: src/true.c:38
#, c-format
msgid ""
"Usage: %s [ignored command line arguments]\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s [ПРЕНЕБРЕГНАТ_АРГУМЕНТ]…\n"
"     или: %s ОПЦИЯ\n"

#: src/true.c:45
msgid "Exit with a status code indicating success."
msgstr "Завършва с код-състояние, посочващ успех."

#: src/true.c:46
msgid "Exit with a status code indicating failure."
msgstr "Завършва с код-състояние, посочващ неуспех."

#: src/truncate.c:70
#, fuzzy, c-format
msgid "Usage: %s OPTION... FILE...\n"
msgstr "Употреба: %s [ОПЦИЯ]… ФАЙЛ…\n"

#: src/truncate.c:71
msgid ""
"Shrink or extend the size of each FILE to the specified size\n"
"\n"
"A FILE argument that does not exist is created.\n"
"\n"
"If a FILE is larger than the specified size, the extra data is lost.\n"
"If a FILE is shorter, it is extended and the extended part (hole)\n"
"reads as zero bytes.\n"
msgstr ""

#: src/truncate.c:83
msgid "  -c, --no-create        do not create any files\n"
msgstr ""

#: src/truncate.c:86
msgid ""
"  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\n"
msgstr ""

#: src/truncate.c:89
msgid ""
"  -r, --reference=RFILE  base size on RFILE\n"
"  -s, --size=SIZE        set or adjust the file size by SIZE bytes\n"
msgstr ""

#: src/truncate.c:95
msgid ""
"\n"
"SIZE may also be prefixed by one of the following modifying characters:\n"
"'+' extend by, '-' reduce by, '<' at most, '>' at least,\n"
"'/' round down to multiple of, '%' round up to multiple of.\n"
msgstr ""

#: src/truncate.c:123
#, c-format
msgid "overflow in %<PRIdMAX> * %<PRIdMAX> byte blocks for file %s"
msgstr ""

#: src/truncate.c:147
#, fuzzy, c-format
msgid "%s has unusable, apparently negative size"
msgstr "%s: файлът има отрицателен размер"

#: src/truncate.c:157 src/truncate.c:359
#, fuzzy, c-format
msgid "cannot get the size of %s"
msgstr "времето не може да се смени на „%s“"

#: src/truncate.c:179
#, fuzzy, c-format
msgid "overflow rounding up size of file %s"
msgstr "препълване на отместването при четене на файла %s"

#: src/truncate.c:189
#, fuzzy, c-format
msgid "overflow extending size of file %s"
msgstr "препълване на отместването при четене на файла %s"

#: src/truncate.c:204
#, c-format
msgid "failed to truncate %s at %<PRIdMAX> bytes"
msgstr ""

#: src/truncate.c:277
#, fuzzy, c-format
msgid "multiple relative modifiers specified"
msgstr "мултиплексиран знаков специален файл"

#: src/truncate.c:286
msgid "Invalid number"
msgstr "Неправилно число"

#: src/truncate.c:308
#, fuzzy, c-format
msgid "you must specify either %s or %s"
msgstr "трябва да посочите списък байтове, знаци или полета"

#: src/truncate.c:315
#, c-format
msgid "you must specify a relative %s with %s"
msgstr ""

#: src/truncate.c:322
#, c-format
msgid "%s was specified but %s was not"
msgstr ""

#: src/truncate.c:379
#, c-format
msgid "cannot open %s for writing"
msgstr "не може да се отвори %s за запис"

#. This is a proper name. See the gettext manual, section Names.
#: src/tsort.c:40
msgid "Mark Kettenis"
msgstr "Mark Kettenis"

#: src/tsort.c:82
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
msgstr ""
"Употреба: %s [ОПЦИЯ] [ФАЙЛ]\n"
"\n"
"Извеждане на напълно подреден списък, съвместим с частичната наредба във "
"ФАЙЛа.\n"

#: src/tsort.c:89 src/uptime.c:212
#, c-format
msgid "\n"
msgstr "\n"

#: src/tsort.c:475
#, c-format
msgid "%s: input contains an odd number of tokens"
msgstr "%s: входните данни съдържат нечетен брой лексеми"

#: src/tsort.c:521
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s: входният файл съдържа цикъл:"

#: src/tty.c:66
msgid ""
"Print the file name of the terminal connected to standard input.\n"
"\n"
"  -s, --silent, --quiet   print nothing, only return an exit status\n"
msgstr ""
"Извежда файловото име на терминала, свързан със стандартния вход.\n"
"\n"
"  -s, --silent, --quiet   не извежда нищо, връща само код на завършване\n"

#: src/tty.c:127
msgid "not a tty"
msgstr "не е tty"

#: src/uname.c:125
msgid ""
"Print certain system information.  With no OPTION, same as -s.\n"
"\n"
"  -a, --all                print all information, in the following order,\n"
"                             except omit -p and -i if unknown:\n"
"  -s, --kernel-name        print the kernel name\n"
"  -n, --nodename           print the network node hostname\n"
"  -r, --kernel-release     print the kernel release\n"
msgstr ""
"Извеждане на информация да системата.  Без никаква ОПЦИЯ е същото като с „-"
"s“.\n"
"\n"
"  -a, --all                извеждане на цялата информация в следния ред\n"
"                           („-p“ и „-i“ се пропускат, ако не са известни):\n"
"  -s, --kernel-name        име на ядрото\n"
"  -n, --nodename           име на компютъра в мрежата\n"
"  -r, --kernel-release     подверсия на ядрото\n"

#: src/uname.c:134
msgid ""
"  -v, --kernel-version     print the kernel version\n"
"  -m, --machine            print the machine hardware name\n"
"  -p, --processor          print the processor type (non-portable)\n"
"  -i, --hardware-platform  print the hardware platform (non-portable)\n"
"  -o, --operating-system   print the operating system\n"
msgstr ""
"  -v, --kernel-version     версия на ядрото\n"
"  -m, --machine            хардуерно име на машината\n"
"  -p, --processor          вид на микропроцесора (не е преносимо)\n"
"  -i, --hardware-platform  хардуерна платформа (не е преносимо)\n"
"  -o, --operating-system   операционна система\n"

#: src/uname.c:144
msgid ""
"Print machine architecture.\n"
"\n"
msgstr ""
"Извеждане на архитектурата на машината.\n"
"\n"

#: src/uname.c:287
msgid "cannot get system name"
msgstr "името на системата не може да се получи"

#: src/unexpand.c:82
msgid "Convert blanks in each FILE to tabs, writing to standard output.\n"
msgstr ""
"Замяна на интервалите във всеки ФАЙЛ и извеждане на стандартния изход\n"

#: src/unexpand.c:89
msgid ""
"  -a, --all        convert all blanks, instead of just initial blanks\n"
"      --first-only  convert only leading sequences of blanks (overrides -a)\n"
"  -t, --tabs=N     have tabs N characters apart instead of 8 (enables -a)\n"
msgstr ""
"  -a, --all        преобразуване на всички празни знаци, а не само в "
"началото\n"
"                   на редовете\n"
"      --first-only преобразуване на празните знаци само в началото на "
"редовете\n"
"                   (отменя „-a“)\n"
"  -t, --tabs=N     използване на табулации с размер N знака вместо през 8\n"
"                   (включва „-a“)\n"

#: src/unexpand.c:306
msgid "tab stop value is too large"
msgstr "табулацията е твърде дълга"

#: src/uniq.c:171
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ВХОД [ИЗХОД]]\n"

#: src/uniq.c:175
msgid ""
"Filter adjacent matching lines from INPUT (or standard input),\n"
"writing to OUTPUT (or standard output).\n"
"\n"
"With no options, matching lines are merged to the first occurrence.\n"
msgstr ""

#: src/uniq.c:184
#, fuzzy
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines, one for each group\n"
msgstr ""
"  -c, --count           редовете да се предхождат от брой срещания\n"
"  -d, --repeated        извежда само повтарящите се редове\n"

#: src/uniq.c:188
msgid ""
"  -D                    print all duplicate lines\n"
"      --all-repeated[=METHOD]  like -D, but allow separating groups\n"
"                                 with an empty line;\n"
"                                 METHOD={none(default),prepend,separate}\n"
msgstr ""

#: src/uniq.c:194
msgid "  -f, --skip-fields=N   avoid comparing the first N fields\n"
msgstr ""

#: src/uniq.c:197
msgid ""
"      --group[=METHOD]  show all items, separating groups with an empty "
"line;\n"
"                          METHOD={separate(default),prepend,append,both}\n"
msgstr ""

#: src/uniq.c:201
msgid ""
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
msgstr ""

#: src/uniq.c:209
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr "  -w, --check-chars=N   сравнява по не повече от N знака в редовете\n"

#: src/uniq.c:214
#, fuzzy
msgid ""
"\n"
"A field is a run of blanks (usually spaces and/or TABs), then non-blank\n"
"characters.  Fields are skipped before chars.\n"
msgstr ""
"\n"
"Полето се състои от бяло поле, следвано от видими знаци.\n"
"Fields are skipped before chars.\n"

#: src/uniq.c:219
msgid ""
"\n"
"Note: 'uniq' does not detect repeated lines unless they are adjacent.\n"
"You may want to sort the input first, or use 'sort -u' without 'uniq'.\n"
"Also, comparisons honor the rules specified by 'LC_COLLATE'.\n"
msgstr ""

#: src/uniq.c:437
msgid "too many repeated lines"
msgstr "твърде много повторени редове"

#: src/uniq.c:613
msgid "invalid number of fields to skip"
msgstr "неправилен брой полета за пропускане"

#: src/uniq.c:622
msgid "invalid number of bytes to skip"
msgstr "неправилен брой байтове за пропускане"

#: src/uniq.c:632
msgid "invalid number of bytes to compare"
msgstr "неправилен брой знаци за сравняване"

#: src/uniq.c:654
#, c-format
msgid "--group is mutually exclusive with -c/-d/-D/-u"
msgstr ""

#: src/uniq.c:661
#, fuzzy, c-format
msgid "grouping and printing repeat counts is meaningless"
msgstr ""
"безсмислено е да се извеждат всички повтарящи се редове и броя срещания"

#: src/uniq.c:668
#, c-format
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr ""
"безсмислено е да се извеждат всички повтарящи се редове и броя срещания"

#: src/unlink.c:45
#, c-format
msgid ""
"Usage: %s FILE\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s ФАЙЛ\n"
"     или: %s ФАЙЛ\n"

#: src/unlink.c:48
msgid ""
"Call the unlink function to remove the specified FILE.\n"
"\n"
msgstr ""
"Изтриване на посочения ФАЙЛ посредством системната функция „unlink“.\n"
"\n"

#: src/uptime.c:125
msgid "couldn't get boot time"
msgstr "не може да се получи времето на начално зареждане"

#. TRANSLATORS: This prints the current clock time.
#: src/uptime.c:136
msgid " %H:%M:%S  "
msgstr " %H:%M:%S  "

#: src/uptime.c:138
#, c-format
msgid " ??:????  "
msgstr " ??:????  "

#: src/uptime.c:140
#, c-format
msgid "up ???? days ??:??,  "
msgstr "???? дена ??:??,  "

#: src/uptime.c:144
#, c-format
msgid "up %ld day %2d:%02d,  "
msgid_plural "up %ld days %2d:%02d,  "
msgstr[0] "%ld ден %2d:%02d,  "
msgstr[1] "%ld дни %2d:%02d,  "

#: src/uptime.c:149
#, c-format
msgid "up  %2d:%02d,  "
msgstr "  %2d:%02d,  "

#: src/uptime.c:151
#, c-format
msgid "%lu user"
msgid_plural "%lu users"
msgstr[0] "%lu потребител"
msgstr[1] "%lu потребителя"

#: src/uptime.c:161
#, c-format
msgid ",  load average: %.2f"
msgstr ",  средно натоварване: %.2f"

#: src/uptime.c:199
#, c-format
msgid ""
"Print the current time, the length of time the system has been up,\n"
"the number of users on the system, and the average number of jobs\n"
"in the run queue over the last 1, 5 and 15 minutes."
msgstr ""
"Извеждане на текущото време, продължителността на времето, през което "
"системата е била\n"
"стартирана, броят потребители, използващи в момента системата, и средният "
"брой задачи\n"
"в опашката на многозадачния диспечер през последните 1, 5 и 15 минути."

#: src/uptime.c:208
#, c-format
msgid ""
"  Processes in\n"
"an uninterruptible sleep state also contribute to the load average.\n"
msgstr ""
"  Процесите, които спят,\n"
"  но не могат да бъдат прекъснати, също се броят в средното натоварване.\n"

#: src/uptime.c:214
#, c-format
msgid ""
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Ако не е посочен ФАЙЛ, се използва „%s“.  Най-често за ФАЙЛ се ползва „%s“.\n"

#: src/users.c:106
#, c-format
msgid ""
"Output who is currently logged in according to FILE.\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Извежда кой в момента е влязъл в системата според ФАЙЛ.\n"
"Ако не е посочен ФАЙЛ, използва %s. Често ФАЙЛ е %s.\n"
"\n"

#: src/wc.c:123
msgid ""
"Print newline, word, and byte counts for each FILE, and a total line if\n"
"more than one FILE is specified.  A word is a non-zero-length sequence of\n"
"characters delimited by white space.\n"
msgstr ""
"Извеждане на броя на новите редове, думи и байтове във всеки ФАЙЛ, както и\n"
"обща статистика, ако е посочен повече от един ФАЙЛ.  За дума се счита всяка\n"
"последователност от непразни знаци, разделени с празни като табулации,\n"
"интервали и др.\n"
"  -c, --bytes            извеждане на броя байтове\n"
"  -m, --chars            извеждане на броя букви\n"
"  -l, --lines            извеждане на броя редове\n"

#: src/wc.c:131
msgid ""
"\n"
"The options below may be used to select which counts are printed, always in\n"
"the following order: newline, word, character, byte, maximum line length.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"\n"
"Опциите по-долу определят кои статистики от следните, точно в този ред, се\n"
"извеждат: нови редове, думи, знаци, байтове, максимална дължина на ред.\n"
"  -c, --bytes            извеждане на броя на байтовете\n"
"  -m, --chars            извеждане на броя на знаците\n"
"  -l, --lines            извеждане на броя на новите редове\n"

#: src/wc.c:139
msgid ""
"      --files0-from=F    read input from the files specified by\n"
"                           NUL-terminated names in file F;\n"
"                           If F is - then read names from standard input\n"
"  -L, --max-line-length  print the maximum display width\n"
"  -w, --words            print the word counts\n"
msgstr ""
"      --files0-from=ФАЙЛ четене на файловете, чиито имена са изредени в "
"този\n"
"                         ФАЙЛ, като всяко име завършва с нулев байт.  Ако\n"
"                         ФАЙЛът е „-“, се чете от стандартния вход\n"
"  -L, --max-line-length  извеждане на дължината на най-дългия ред\n"
"  -w, --words            извеждане на броя думи\n"

#: src/who.c:213
msgid " old "
msgstr " стар "

#: src/who.c:443
msgid "system boot"
msgstr "стартиране на системата"

#: src/who.c:451 src/who.c:453
msgid "id="
msgstr "id="

#: src/who.c:466 src/who.c:471
msgid "term="
msgstr "term="

#: src/who.c:468 src/who.c:472
msgid "exit="
msgstr "exit="

#: src/who.c:489
msgid "LOGIN"
msgstr "ВХОД"

#: src/who.c:509
msgid "clock change"
msgstr "смяна на часа"

#: src/who.c:521 src/who.c:522
msgid "run-level"
msgstr "старт-ниво"

#: src/who.c:525 src/who.c:526
msgid "last="
msgstr "last="

#: src/who.c:557
#, c-format
msgid ""
"\n"
"# users=%lu\n"
msgstr ""
"\n"
"брой потребители - %lu\n"

#: src/who.c:563
msgid "NAME"
msgstr "ИМЕ"

#: src/who.c:563
msgid "LINE"
msgstr "ЛИНИЯ"

#: src/who.c:563
msgid "TIME"
msgstr "ВРЕМЕ"

#: src/who.c:563
msgid "IDLE"
msgstr "АЙЛЯК"

#: src/who.c:564
msgid "PID"
msgstr "PID"

#: src/who.c:564
msgid "COMMENT"
msgstr "КОМЕНТАР"

#: src/who.c:564
msgid "EXIT"
msgstr "ИЗХОД"

#: src/who.c:644
#, c-format
msgid "Usage: %s [OPTION]... [ FILE | ARG1 ARG2 ]\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ ФАЙЛ | АРГУМЕНТ_1 АРГУМЕНТ_2 ]\n"

#: src/who.c:645
msgid "Print information about users who are currently logged in.\n"
msgstr "Извеждане на информация кой в момента е влязъл в системата.\n"

#: src/who.c:648
msgid ""
"\n"
"  -a, --all         same as -b -d --login -p -r -t -T -u\n"
"  -b, --boot        time of last system boot\n"
"  -d, --dead        print dead processes\n"
"  -H, --heading     print line of column headings\n"
msgstr ""
"\n"
"  -a, --all         същото като „-b -d --login -p -r -t -T -u“\n"
"  -b, --boot        времето на последното начално зареждане\n"
"  -d, --dead        извеждане на броя умрели процеси\n"
"  -H, --heading     извеждане на заглавен ред\n"

#: src/who.c:655
msgid "  -l, --login       print system login processes\n"
msgstr "  -l, --login       извеждане на процесите за влизане в системата\n"

#: src/who.c:658
msgid ""
"      --lookup      attempt to canonicalize hostnames via DNS\n"
"  -m                only hostname and user associated with stdin\n"
"  -p, --process     print active processes spawned by init\n"
msgstr ""
"      --lookup      опит за извеждане на канонични мрежови имена на "
"компютрите\n"
"                    чрез DNS\n"
"  -m                само мрежовото име и потребителя, свързан на "
"стандартния\n"
"                    вход\n"
"  -p, --process     активни процеси, породени от „init“\n"

#: src/who.c:663
msgid ""
"  -q, --count       all login names and number of users logged on\n"
"  -r, --runlevel    print current runlevel\n"
"  -s, --short       print only name, line, and time (default)\n"
"  -t, --time        print last system clock change\n"
msgstr ""
"  -q, --count       извеждане на всички входни имена и броя на влезлите\n"
"                    потребители\n"
"  -r, --runlevel    извеждане на текущото ниво на стартиране\n"
"  -s, --short       извеждане само на името, линията и времето (по "
"подразбиране)\n"
"  -t, --time        извеждане на последната промяна на системния часовник\n"

#: src/who.c:669
msgid ""
"  -T, -w, --mesg    add user's message status as +, - or ?\n"
"  -u, --users       list users logged in\n"
"      --message     same as -T\n"
"      --writable    same as -T\n"
msgstr ""
"  -T, -w, --mesg    добавяне на състоянието на „mesg“ на потребителите\n"
"                    („+“, „-“ или „?“)\n"
"  -u, --users       извеждане на потребителите, влезли в системата\n"
"      --message     същото като „-T“\n"
"      --writable    същото като „-T“\n"

#: src/who.c:677
#, c-format
msgid ""
"\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"If ARG1 ARG2 given, -m presumed: 'am i' or 'mom likes' are usual.\n"
msgstr ""
"\n"
"Ако не е посочен ФАЙЛ, се използва „%s“.  Често ФАЙЛ е „%s“.\n"
"Ако са посочени АРГУМЕНТ_1 АРГУМЕНТ_2, се предполага „-m“:\n"
"обичайни са „am i“ и „съм аз“.\n"

#: src/whoami.c:45
msgid ""
"Print the user name associated with the current effective user ID.\n"
"Same as id -un.\n"
"\n"
msgstr ""
"Извежда името текущия действителен (effective) потребител.\n"
"Същото като id -un.\n"
"\n"

#: src/whoami.c:86
#, c-format
msgid "cannot find name for user ID %lu"
msgstr "не може да се намери името на потребител №%lu"

#: src/yes.c:41
#, c-format
msgid ""
"Usage: %s [STRING]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s [НИЗ]…\n"
"     или: %s ОПЦИЯ\n"

#: src/yes.c:47
msgid ""
"Repeatedly output a line with all specified STRING(s), or 'y'.\n"
"\n"
msgstr ""
"Непрекъснато извеждане на ред от посочените НИЗ(ове) или „y“.\n"
"\n"
